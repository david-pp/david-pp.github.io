<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="多线程,pthread," />





  <link rel="alternate" href="/atom.xml" title="TinyLab" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="目录
摘要  
译者序
Pthreads 概述 3.1 什么是线程? 3.2 什么是Pthreads? 3.3 为什么使用Pthreads? 3.4 使用线程设计程序   
Pthreads API编译多线程程序  
线程管理 5.1 创建和终止线程 5.2 向线程传递参数 5.3 连接（Joining）和分离（Detaching）线程 5.4 栈管理 5.5 其它函数   
互斥量（Mutex">
<meta property="og:type" content="article">
<meta property="og:title" content="POSIX多线程程序设计">
<meta property="og:url" content="http://yoursite.com/2009/02/05/posix-thread-cn/index.html">
<meta property="og:site_name" content="TinyLab">
<meta property="og:description" content="目录
摘要  
译者序
Pthreads 概述 3.1 什么是线程? 3.2 什么是Pthreads? 3.3 为什么使用Pthreads? 3.4 使用线程设计程序   
Pthreads API编译多线程程序  
线程管理 5.1 创建和终止线程 5.2 向线程传递参数 5.3 连接（Joining）和分离（Detaching）线程 5.4 栈管理 5.5 其它函数   
互斥量（Mutex">
<meta property="og:image" content="http://yoursite.com/images/2009-02-05-process.gif">
<meta property="og:updated_time" content="2016-11-02T09:51:27.459Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="POSIX多线程程序设计">
<meta name="twitter:description" content="目录
摘要  
译者序
Pthreads 概述 3.1 什么是线程? 3.2 什么是Pthreads? 3.3 为什么使用Pthreads? 3.4 使用线程设计程序   
Pthreads API编译多线程程序  
线程管理 5.1 创建和终止线程 5.2 向线程传递参数 5.3 连接（Joining）和分离（Detaching）线程 5.4 栈管理 5.5 其它函数   
互斥量（Mutex">
<meta name="twitter:image" content="http://yoursite.com/images/2009-02-05-process.gif">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2009/02/05/posix-thread-cn/"/>


  <title> POSIX多线程程序设计 | TinyLab </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?32177a2b43f11f13565131b8c1239878";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TinyLab</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep eyes on the star and feet on the ground.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                POSIX多线程程序设计
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-05T21:27:00+08:00" content="2009-02-05">
              2009-02-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/05/posix-thread-cn/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/05/posix-thread-cn/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li><a href="#abstract">摘要</a>  </li>
<li><a href="#david">译者序</a></li>
<li><a href="#pthread-intro">Pthreads 概述</a><br> 3.1 <a href="#3.1">什么是线程?</a><br> 3.2 <a href="#3.2">什么是Pthreads?</a><br> 3.3 <a href="#3.3">为什么使用Pthreads?</a><br> 3.4 <a href="#3.4">使用线程设计程序</a>   </li>
<li><a href="#4">Pthreads API编译多线程程序</a>  </li>
<li><a href="#5">线程管理</a><br> 5.1 <a href="#5.1">创建和终止线程</a><br> 5.2 <a href="#5.2">向线程传递参数</a><br> 5.3 <a href="#5.3">连接（Joining）和分离（Detaching）线程</a><br> 5.4 <a href="#5.4">栈管理</a><br> 5.5 <a href="#5.5">其它函数</a>   </li>
<li><a href="#6">互斥量（Mutex Variables）</a><br> 6.1 <a href="#6.1">互斥量概述</a><br> 6.2 <a href="#6.2">创建和销毁互斥量</a><br> 6.3 <a href="#6.3">锁定（Locking）和解锁（Unlocking）互斥量</a>  </li>
<li><a href="#7">条件变量（Condition Variable）</a><br> 7.1 <a href="#7.1">条件变量概述</a><br> 7.2 <a href="#7.2">创建和销毁条件变量</a><br> 7.3 <a href="#7.3">等待（Waiting）和发送信号（Signaling）</a>  </li>
<li><a href="#8">没有覆盖的主题</a></li>
<li><a href="#9">Pthread 库API参考</a>  </li>
<li><a href="#10">参考资料</a></li>
</ol>
<hr>
<h3 id="1-摘要"><a href="#1-摘要" class="headerlink" title=" 1. 摘要"></a><a id="abstract"></a> 1. 摘要</h3><p>在多处理器共享内存的架构中（如：对称多处理系统SMP），线程可以用于实现程序的并行性。历史上硬件销售商实现了各种私有版本的多线程库，使得软件开发者不得不关心它的移植性。对于UNIX系统，IEEE POSIX 1003.1标准定义了一个C语言多线程编程接口。依附于该标准的实现被称为POSIX theads 或 Pthreads。 </p>
<p>该教程介绍了Pthreads的概念、动机和设计思想。内容包含了Pthreads API主要的三大类函数：线程管理（Thread Managment）、互斥量（Mutex Variables）和条件变量（Condition Variables）。向刚开始学习Pthreads的程序员提供了演示例程。 </p>
<p>适于：刚开始学习使用线程实现并行程序设计；对于C并行程序设计有基本了解。不熟悉并行程序设计的可以参考EC3500: Introduction To Parallel Computing。</p>
<hr>
<h3 id="2-译者序"><a href="#2-译者序" class="headerlink" title=" 2. 译者序"></a><a id="david"></a> 2. 译者序</h3><p>三天时间，终于在工作期间，抽空把上一篇POSIX threads programing翻译完了。由于水平有限，翻译质量差强人意，若有不合理或错误之处，请您之处，在此深表感谢！有疑问点此查看原文。在参考部分提及的几本关于Pthreads库的大作及该文章原文和译文可在下面的连接下载：</p>
<ul>
<li>本篇及其英文原文:  <a href="http://download.csdn.net/source/992256" target="_blank" rel="external">http://download.csdn.net/source/992256</a></li>
<li>多线程编程指南:  <a href="http://download.csdn.net/source/992248" target="_blank" rel="external">http://download.csdn.net/source/992248</a></li>
<li>Programing with POSIX thread(强烈推荐): <a href="http://download.csdn.net/source/992239" target="_blank" rel="external">http://download.csdn.net/source/992239</a></li>
<li>Pthread Primer(强烈推荐): <a href="http://download.csdn.net/source/992213" target="_blank" rel="external">http://download.csdn.net/source/992213</a></li>
</ul>
<hr>
<h3 id="3-Pthreads概述"><a href="#3-Pthreads概述" class="headerlink" title=" 3. Pthreads概述"></a><a id="pthread-intro"></a> 3. Pthreads概述</h3><h4 id="3-1-什么是线程"><a href="#3-1-什么是线程" class="headerlink" title=" 3.1 什么是线程?"></a><a id="3.1"></a> 3.1 什么是线程?</h4><p>技术上，线程可以定义为：可以被操作系统调度的独立的指令流。但是这是什么意思呢？ </p>
<p>对于软件开发者，在主程序中运行的“函数过程”可以很好的描述线程的概念。 </p>
<p>进一步，想象下主程序（a.out）包含了许多函数，操作系统可以调度这些函数，使之同时或者（和）独立的执行。这就描述了“多线程”程序。<br>怎样完成的呢？ </p>
<p>在理解线程之前，应先对UNIX进程（process）有所了解。进程被操作系统创建，需要相当多的“额外开销”。进程包含了程序的资源和执行状态信息。如下： </p>
<ul>
<li>进程ID，进程group ID，用户ID和group ID </li>
<li>环境 </li>
<li>工作目录  </li>
<li>程序指令 </li>
<li>寄存器 </li>
<li>栈 </li>
<li>堆 </li>
<li>文件描述符 </li>
<li>信号操作（Signal actions） </li>
<li>共享库 </li>
<li>进程间通信工具（如：消息队列，管道，信号量或共享内存） </li>
</ul>
<p><img src="/images/2009-02-05-process.gif" alt="进程"></p>
<p>线程使用并存在于进程资源中，还可以被操作系统调用并独立地运行，这主要是因为线程仅仅复制必要的资源以使自己得以存在并执行。 </p>
<p>独立的控制流得以实现是因为线程维持着自己的： </p>
<ul>
<li>堆栈指针 </li>
<li>寄存器 </li>
<li>调度属性（如：策略或优先级） </li>
<li>待定的和阻塞的信号集合（Set of pending and blocked signals） </li>
<li>线程专用数据（TSD：Thread Specific Data.） </li>
</ul>
<p>因此，在UNIX环境下线程： </p>
<ul>
<li>存在于进程，使用进程资源 </li>
<li>拥有自己独立的控制流，只要父进程存在并且操作系统支持 </li>
<li>只复制必可以使得独立调度的必要资源 </li>
<li>可以和其他线程独立（或非独立的）地共享进程资源 </li>
<li>当父进程结束时结束，或者相关类似的 </li>
<li>是“轻型的”，因为大部分额外开销已经在进程创建时完成了 </li>
</ul>
<p>因为在同一个进程中的线程共享资源： </p>
<ul>
<li>一个线程对系统资源（如关闭一个文件）的改变对所有其它线程是可以见的 </li>
<li>两个同样值的指针指向相同的数据 </li>
<li>读写同一个内存位置是可能的，因此需要成员显式地使用同步 </li>
</ul>
<hr>
<h4 id="3-2-什么是-Pthreads"><a href="#3-2-什么是-Pthreads" class="headerlink" title=" 3.2 什么是 Pthreads?"></a><a id="3.2"></a> 3.2 什么是 Pthreads?</h4><p>历史上，硬件销售商实现了私有版本的多线程库。这些实现在本质上各自不同，使得程序员难于开发可移植的应用程序。 </p>
<p>为了使用线程所提供的强大优点，需要一个标准的程序接口。对于UNIX系统，IEEE POSIX 1003.1c（1995）标准制订了这一标准接口。依赖于该标准的实现就称为POSIX threads 或者Pthreads。现在多数硬件销售商也提供Pthreads，附加于私有的API。 </p>
<p>Pthreads 被定义为一些C语言类型和函数调用，用pthread.h头（包含）文件和线程库实现。这个库可以是其它库的一部分，如libc。 </p>
<hr>
<h4 id="3-3-为什么使用-Pthreads"><a href="#3-3-为什么使用-Pthreads" class="headerlink" title=" 3.3 为什么使用 Pthreads?"></a><a id="3.3"></a> 3.3 为什么使用 Pthreads?</h4><p>使用Pthreads的主要动机是提高潜在程序的性能。 </p>
<p>当与创建和管理进程的花费相比，线程可以使用操作系统较少的开销，管理线程需要较少的系统资源。 </p>
<p>例如，下表比较了fork()函数和pthread_create()函数所用的时间。计时反应了50,000个进程/线程的创建，使用时间工具实现，单位是秒，没有优化标志。 </p>
<p>备注：不要期待系统和用户时间加起来就是真实时间，因为这些SMP系统有多个CPU同时工作。这些都是近似值。 </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th rowspan="2">平台</th><br>            <th colspan="3">fork()</th><br>            <th colspan="3">pthread_create()</th><br>        </tr><br>        <tr><br>            <th>real</th><br>            <th>user</th><br>            <th>sys</th><br>            <th>real</th><br>            <th>user</th><br>            <th>sys</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>AMD 2.4 GHz Opteron (8cpus/node) </td><br>            <td>41.07</td><br>            <td>60.08</td><br>            <td>9.01</td><br>            <td>0.66</td><br>            <td>0.19</td><br>            <td>0.43</td><br>        </tr><br>        <tr><br>            <td>IBM 1.9 GHz POWER5 p5-575 (8cpus/node) </td><br>            <td>64.24</td><br>            <td>30.78</td><br>            <td>27.68</td><br>            <td>1.75</td><br>            <td>0.69</td><br>            <td>1.10</td><br>        </tr><br>        <tr><br>            <td>IBM 1.5 GHz POWER4 (8cpus/node) </td><br>            <td>104.05</td><br>            <td>48.64</td><br>            <td>47.21</td><br>            <td>2.01</td><br>            <td>1.00</td><br>            <td>1.52</td><br>        </tr><br>        <tr><br>            <td>INTEL 2.4 GHz Xeon (2 cpus/node) </td><br>            <td>54.95</td><br>            <td>1.54</td><br>            <td>20.78</td><br>            <td>1.64</td><br>            <td>0.67</td><br>            <td>0.90</td><br>        </tr><br>        <tr><br>            <td>INTEL 1.4 GHz Itanium2 (4 cpus/node)  </td><br>            <td>54.54</td><br>            <td>1.07</td><br>            <td>22.22</td><br>            <td>2.03</td><br>            <td>1.26</td><br>            <td>0.67</td><br>        </tr><br>    </tbody><br></table>

<p>在同一个进程中的所有线程共享同样的地址空间。较于进程间的通信，在许多情况下线程间的通信效率比较高，且易于使用。 </p>
<p>较于没有使用线程的程序，使用线程的应用程序有潜在的性能增益和实际的优点： </p>
<ul>
<li>CPU使用I/O交叠工作：例如，一个程序可能有一个需要较长时间的I/O操作，当一个线程等待I/O系统调用完成时，CPU可以被其它线程使用。 </li>
<li>优先/实时调度：比较重要的任务可以被调度，替换或者中断较低优先级的任务。 </li>
<li>异步事件处理：频率和持续时间不确定的任务可以交错。例如，web服务器可以同时为前一个请求传输数据和管理新请求。 </li>
</ul>
<p>考虑在SMP架构上使用Pthreads的主要动机是获的最优的性能。特别的，如果一个程序使用MPI在节点通信，使用Pthreads可以使得节点数据传输得到显著提高。 </p>
<p>例如： </p>
<ul>
<li>MPI库经常用共享内存实现节点任务通信，这至少需要一次内存复制操作（进程到进程）。 </li>
<li>Pthreads没有中间的内存复制，因为线程和一个进程共享同样的地址空间。没有数据传输。变成cache-to-CPU或memory-to-CPU的带宽（最坏情况），速度是相当的快。 </li>
<li>比较如下： </li>
</ul>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th>Platform</th><br>            <th>MPI Shared Memory Bandwidth(GB/sec) </th><br>            <th>Pthreads Worst Case Memory-to-CPU Bandwidth (GB/sec) </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>AMD 2.4 GHz Opteron </td><br>            <td>1.2</td><br>            <td>5.3</td><br>        </tr><br>        <tr><br>            <td>IBM 1.9 GHz POWER5 p5-575</td><br>            <td>4.1</td><br>            <td>16</td><br>        </tr><br>        <tr><br>            <td>IBM 1.5 GHz POWER4 </td><br>            <td>2.1</td><br>            <td>4</td><br>        </tr><br>        <tr><br>            <td>Intel 1.4 GHz Xeon </td><br>            <td>0.3</td><br>            <td>4.3</td><br>        </tr><br>        <tr><br>            <td>Intel 1.4 GHz Itanium 2</td><br>            <td>1.8</td><br>            <td>6.4</td><br>        </tr><br>    </tbody><br></table>

<hr>
<h4 id="3-4-使用线程设计程序"><a href="#3-4-使用线程设计程序" class="headerlink" title=" 3.4 使用线程设计程序"></a><a id="3.4"></a> 3.4 使用线程设计程序</h4><h5 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程:"></a>并行编程:</h5><p>在现代多CPU机器上，pthread非常适于并行编程。可以用于并行程序设计的，也可以用于pthread程序设计。 </p>
<p>并行程序要考虑许多，如下： </p>
<ul>
<li>用什么并行程序设计模型？ </li>
<li>问题划分 </li>
<li>加载平衡（Load balancing） </li>
<li>通信 </li>
<li>数据依赖 </li>
<li>同步和竞争条件 </li>
<li>内存问题 </li>
<li>I/O问题 </li>
<li>程序复杂度 </li>
<li>程序员的努力/花费/时间 </li>
<li>…  </li>
</ul>
<p>包含这些主题超出本教程的范围，有兴趣的读者可以快速浏览下“Introduction to Parallel Computing”教程。 </p>
<p>大体上，为了使用Pthreads的优点，必须将任务组织程离散的，独立的，可以并发执行的。例如，如果routine1和routine2可以互换，相互交叉和（或者）重叠，他们就可以线程化。 </p>
<p>拥有下述特性的程序可以使用pthreads： </p>
<ul>
<li>工作可以被多个任务同时执行，或者数据可以同时被多个任务操作。 </li>
<li>阻塞与潜在的长时间I/O等待。 </li>
<li>在某些地方使用很多CPU循环而其他地方没有。 </li>
<li>对异步事件必须响应。 </li>
<li>一些工作比其他的重要（优先级中断）。 </li>
</ul>
<p>Pthreads 也可以用于串行程序，模拟并行执行。很好例子就是经典的web浏览器，对于多数人，运行于单CPU的桌面/膝上机器，许多东西可以同时“显示”出来。 </p>
<p>使用线程编程的几种常见模型： </p>
<ul>
<li><p><strong>管理者/工作者（Manager/worker）</strong>：一个单线程，作为管理器将工作分配给其它线程（工作者），典型的，管理器处理所有输入和分配工作给其它任务。至少两种形式的manager/worker模型比较常用：静态worker池和动态worker池。 </p>
</li>
<li><p><strong>管道（Pipeline）</strong>：任务可以被划分为一系列子操作，每一个被串行处理，但是不同的线程并发处理。汽车装配线可以很好的描述这个模型。 </p>
</li>
<li><p><strong>Peer</strong>: 和manager/worker模型相似，但是主线程在创建了其它线程后，自己也参与工作。 </p>
</li>
</ul>
<h5 id="共享内存模型（Shared-Memory-Model）"><a href="#共享内存模型（Shared-Memory-Model）" class="headerlink" title="共享内存模型（Shared Memory Model）:"></a>共享内存模型（Shared Memory Model）:</h5><p>所有线程可以访问全局，共享内存 </p>
<p>线程也有自己私有的数据 </p>
<p>程序员负责对全局共享数据的同步存取（保护） </p>
<h5 id="线程安全（Thread-safeness）"><a href="#线程安全（Thread-safeness）" class="headerlink" title="线程安全（Thread-safeness）:"></a>线程安全（Thread-safeness）:</h5><p>线程安全：简短的说，指程序可以同时执行多个线程却不会“破坏“共享数据或者产生“竞争”条件的能力。 </p>
<p>例如：假设你的程序创建了几个线程，每一个调用相同的库函数： </p>
<ul>
<li>这个库函数存取/修改了一个全局结构或内存中的位置。 </li>
<li>当每个线程调用这个函数时，可能同时去修改这个全局结构活内存位置。 </li>
<li>如果函数没有使用同步机制去阻止数据破坏，这时，就不是线程安全的了。 </li>
</ul>
<p>如果你不是100%确定外部库函数是线程安全的，自己负责所可能引发的问题。 </p>
<p>建议：小心使用库或者对象，当不能明确确定是否是线程安全的。若有疑虑，假设其不是线程安全的直到得以证明。可以通过不断地使用不确定的函数找出问题所在。 </p>
<hr>
<h3 id="4-编译多线程程序"><a href="#4-编译多线程程序" class="headerlink" title=" 4. 编译多线程程序"></a><a id="4"></a> 4. 编译多线程程序</h3><p>下表列出了一些编译使用了pthreads库程序的命令： </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th>Compiler/Platform</th><br>            <th>Compiler Command</th><br>            <th>Description</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td rowspan="3">IBM AIX</td><br>            <td>xlc_r / cc_r </td><br>            <td>C (ANSI  /  non-ANSI) </td><br>        </tr><br>        <tr><br>            <td>xlC_r </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td>xlf_r -qnosave, xlf90_r -qnosave </td><br>            <td>Fortran - using IBM’s Pthreads API (non-portable) </td><br>        </tr><br>        <tr><br>            <td rowspan="2">INTEL Linux </td><br>            <td>icc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>icpc -pthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">PathScale Linux  </td><br>            <td>pathcc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>pathCC -pthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">PGI Linux </td><br>            <td>pgcc -lpthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>pgCC -lpthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">GNU Linux, AIX </td><br>            <td>gcc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>g++ -pthread </td><br>            <td>C++</td><br>        </tr><br>    </tbody><br></table>

<hr>
<h3 id="5-线程管理（Thread-Management）"><a href="#5-线程管理（Thread-Management）" class="headerlink" title=" 5. 线程管理（Thread Management）"></a><a id="5"></a> 5. 线程管理（Thread Management）</h3><h4 id="5-1-创建和结束线程"><a href="#5-1-创建和结束线程" class="headerlink" title=" 5.1 创建和结束线程"></a><a id="5.1"></a> 5.1 创建和结束线程</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_create (thread,attr,start_routine,arg)  
pthread_exit (status)  
pthread_attr_init (attr)  
pthread_attr_destroy (attr)  
</code></pre><p><strong>创建线程</strong>:  </p>
<p>最初，main函数包含了一个缺省的线程。其它线程则需要程序员显式地创建。 </p>
<p>pthread_create 创建一个新线程并使之运行起来。该函数可以在程序的任何地方调用。 </p>
<p>pthread_create参数： </p>
<pre><code>thread：返回一个不透明的，唯一的新线程标识符。 
attr：不透明的线程属性对象。可以指定一个线程属性对象，或者NULL为缺省值。 
start_routine：线程将会执行一次的C函数。 
arg: 传递给start_routine单个参数，传递时必须转换成指向void的指针类型。没有参数传递时，可设置为NULL。 
</code></pre><p>一个进程可以创建的线程最大数量取决于系统实现。 </p>
<p>一旦创建，线程就称为peers，可以创建其它线程。线程之间没有指定的结构和依赖关系。 </p>
<p>Q：一个线程被创建后，怎么知道操作系统何时调度该线程使之运行？ </p>
<p>A：除非使用了Pthreads的调度机制，否则线程何时何地被执行取决于操作系统的实现。强壮的程序应该不依赖于线程执行的顺序。</p>
<p><strong>线程属性</strong>:</p>
<p>线程被创建时会带有默认的属性。其中的一些属性可以被程序员用线程属性对象来修改。 </p>
<p>pthread_attr_init 和 pthread_attr_destroy用于初始化/销毁先成属性对象。 </p>
<p>其它的一些函数用于查询和设置线程属性对象的指定属性。 </p>
<p>一些属性下面将会讨论。 </p>
<p><strong>结束终止</strong>:  </p>
<p>结束线程的方法有一下几种： </p>
<ul>
<li>线程从主线程（main函数的初始线程）返回。 </li>
<li>线程调用了pthread_exit函数。 </li>
<li>其它线程使用 pthread_cancel函数结束线程。 </li>
<li>调用exec或者exit函数，整个进程结束。 </li>
</ul>
<p>pthread_exit用于显式退出线程。典型地，pthread_exit()函数在线程完成工作时，不在需要时候被调用，退出线程。 </p>
<p>如果main()在其他线程创建前用pthread_exit()退出了，其他线程将会继续执行。否则，他们会随着main的结束而终止。 </p>
<p>程序员可以可选择的指定终止状态，当任何线程连接（join）该线程时，该状态就返回给连接（join）该线程的线程。 </p>
<p>清理：pthread_exit()函数并不会关闭文件，任何在线程中打开的文件将会一直处于打开状态，知道线程结束。 </p>
<p>讨论：对于正常退出，可以免于调用pthread_exit()。当然，除非你想返回一个返回值。然而，在main中，有一个问题，就是当main结束时，其它线程还没有被创建。如果此时没有显式的调用pthread_exit()，当main结束时，进程（和所有线程）都会终止。可以在main中调用pthread_exit()，此时尽管在main中已经没有可执行的代码了，进程和所有线程将保持存活状态，。 </p>
<p><strong>例子: Pthread 创建和终止</strong></p>
<p>该例用pthread_create()创建了5个线程。每一个线程都会打印一条“Hello World”的消息，然后调用pthread_exit()终止线程。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NUM_THREADS     5 </div><div class="line"> </div><div class="line">void *PrintHello(void *threadid) </div><div class="line">&#123; </div><div class="line">   int tid; </div><div class="line">   tid = (int)threadid; </div><div class="line">   printf(&quot;Hello World! It&apos;s me, thread #%d!/n&quot;, tid); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t threads[NUM_THREADS]; </div><div class="line">   int rc, t; </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++)&#123; </div><div class="line">      printf(&quot;In main: creating thread %d/n&quot;, t); </div><div class="line">      rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t); </div><div class="line">      if (rc)&#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create() is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-2-向线程传递参数"><a href="#5-2-向线程传递参数" class="headerlink" title=" 5.2 向线程传递参数"></a><a id="5.2"></a> 5.2 向线程传递参数</h4><p>pthread_create()函数允许程序员想线程的start routine传递一个参数。当多个参数需要被传递时，可以通过定义一个结构体包含所有要传的参数，然后用pthread_create()传递一个指向改结构体的指针，来打破传递参数的个数的限制。<br>所有参数都应该传引用传递并转化成（void*）。 </p>
<pre><code>Q：怎样安全地向一个新创建的线程传递数据？ 
A：确保所传递的数据是线程安全的（不能被其他线程修改）。下面三个例子演示了那个应该和那个不应该。 
</code></pre><p>Example 1 - Thread Argument Passing  </p>
<p>下面的代码片段演示了如何向一个线程传递一个简单的整数。主线程为每一个线程使用一个唯一的数据结构，确保每个线程传递的参数是完整的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int *taskids[NUM_THREADS]; </div><div class="line"> </div><div class="line">for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">&#123; </div><div class="line">   taskids[t] = (int *) malloc(sizeof(int)); </div><div class="line">   *taskids[t] = t; </div><div class="line">   printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) taskids[t]); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example 2 - Thread Argument Passing  </p>
<p>例子展示了用结构体向线程设置/传递参数。每个线程获得一个唯一的结构体实例。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct thread_data&#123; </div><div class="line">   int  thread_id; </div><div class="line">   int  sum; </div><div class="line">   char *message; </div><div class="line">&#125;; </div><div class="line"> </div><div class="line">struct thread_data thread_data_array[NUM_THREADS]; </div><div class="line"> </div><div class="line">void *PrintHello(void *threadarg) </div><div class="line">&#123; </div><div class="line">   struct thread_data *my_data; </div><div class="line">   ... </div><div class="line">   my_data = (struct thread_data *) threadarg; </div><div class="line">   taskid = my_data-&gt;thread_id; </div><div class="line">   sum = my_data-&gt;sum; </div><div class="line">   hello_msg = my_data-&gt;message; </div><div class="line">   ... </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   ... </div><div class="line">   thread_data_array[t].thread_id = t; </div><div class="line">   thread_data_array[t].sum = sum; </div><div class="line">   thread_data_array[t].message = messages[t]; </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) &amp;thread_data_array[t]); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example 3 - Thread Argument Passing (Incorrect)  </p>
<p>例子演示了错误地传递参数。循环会在线程访问传递的参数前改变传递给线程的地址的内容。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int rc, t; </div><div class="line"> </div><div class="line">for(t=0; t&lt;NUM_THREADS; t++)  </div><div class="line">&#123; </div><div class="line">   printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) &amp;t); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-3-连接（Joining）和分离（Detaching）线程"><a href="#5-3-连接（Joining）和分离（Detaching）线程" class="headerlink" title=" 5.3 连接（Joining）和分离（Detaching）线程"></a><a id="5.3"></a> 5.3 连接（Joining）和分离（Detaching）线程</h4><p><strong>函数</strong>:  </p>
<pre><code>pthread_detach (threadid,status)  
pthread_attr_setdetachstate (attr,detachstate)  
pthread_attr_getdetachstate (attr,detachstate)  
pthread_join (threadid,status)  
</code></pre><p><strong>连接</strong>: </p>
<p>“连接”是一种在线程间完成同步的方法。例如： </p>
<p>pthread_join()函数阻赛调用线程知道threadid所指定的线程终止。 </p>
<p>如果在目标线程中调用pthread_exit()，程序员可以在主线程中获得目标线程的终止状态。 </p>
<p>连接线程只能用pthread_join()连接一次。若多次调用就会发生逻辑错误。 </p>
<p>两种同步方法，互斥量（mutexes）和条件变量（condition variables），稍后讨论。 </p>
<p>可连接（Joinable or Not）?  </p>
<p>当一个线程被创建，它有一个属性定义了它是可连接的（joinable）还是分离的（detached）。只有是可连接的线程才能被连接（joined），若果创建的线程是分离的，则不能连接。 </p>
<p>POSIX标准的最终草案指定了线程必须创建成可连接的。然而，并非所有实现都遵循此约定。 </p>
<p>使用pthread_create()的attr参数可以显式的创建可连接或分离的线程，典型四步如下： </p>
<ul>
<li>声明一个pthread_attr_t数据类型的线程属性变量 </li>
<li>用pthread_attr_init()初始化改属性变量 </li>
<li>用pthread_attr_setdetachstate()设置可分离状态属性 </li>
<li>完了后，用pthread_attr_destroy()释放属性所占用的库资源 </li>
</ul>
<p><strong>分离（Detaching）</strong>：</p>
<p>pthread_detach()可以显式用于分离线程，尽管创建时是可连接的。<br>没<br>有与pthread_detach()功能相反的函数 </p>
<p><strong>建议</strong>：</p>
<ul>
<li>若线程需要连接，考虑创建时显式设置为可连接的。因为并非所有创建线程的实现都是将线程创建为可连接的。 </li>
<li>若事先知道线程从不需要连接，考虑创建线程时将其设置为可分离状态。一些系统资源可能需要释放。 </li>
</ul>
<p><strong>例子: Pthread Joining</strong></p>
<p>Example Code - Pthread Joining  </p>
<p>这个例子演示了用Pthread join函数去等待线程终止。因为有些实现并不是默认创建线程是可连接状态，例子中显式地将其创建为可连接的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NUM_THREADS    3 </div><div class="line"> </div><div class="line">void *BusyWork(void *null) </div><div class="line">&#123; </div><div class="line">   int i; </div><div class="line">   double result=0.0; </div><div class="line">   for (i=0; i&lt;1000000; i++) </div><div class="line">   &#123; </div><div class="line">     result = result + (double)random(); </div><div class="line">   &#125; </div><div class="line">   printf(&quot;result = %e/n&quot;,result); </div><div class="line">   pthread_exit((void *) 0); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t thread[NUM_THREADS]; </div><div class="line">   pthread_attr_t attr; </div><div class="line">   int rc, t; </div><div class="line">   void *status; </div><div class="line"> </div><div class="line">   /* Initialize and set thread detached attribute */ </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line"> </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">   &#123; </div><div class="line">      printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">      rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, NULL);  </div><div class="line">      if (rc) </div><div class="line">      &#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create()  </div><div class="line">                is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   /* Free attribute and wait for the other threads */ </div><div class="line">   pthread_attr_destroy(&amp;attr); </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">   &#123; </div><div class="line">      rc = pthread_join(thread[t], &amp;status); </div><div class="line">      if (rc) </div><div class="line">      &#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_join()  </div><div class="line">                is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">      printf(&quot;Completed join with thread %d status= %ld/n&quot;,t, (long)status); </div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-4-栈管理"><a href="#5-4-栈管理" class="headerlink" title=" 5.4 栈管理"></a><a id="5.4"></a> 5.4 栈管理</h4><p><strong>函数</strong>:  </p>
<pre><code>pthread_attr_getstacksize (attr, stacksize)  
pthread_attr_setstacksize (attr, stacksize)  
pthread_attr_getstackaddr (attr, stackaddr)  
pthread_attr_setstackaddr (attr, stackaddr)  
</code></pre><p><strong>防止栈问题</strong>:</p>
<p>POSIX标准并没有指定线程栈的大小，依赖于实现并随实现变化。 </p>
<p>很容易超出默认的栈大小，常见结果：程序终止或者数据损坏。 </p>
<p>安全和可移植的程序应该不依赖于默认的栈限制，但是取而代之的是用pthread_attr_setstacksize分配足够的栈大小。 </p>
<p>pthread_attr_getstackaddr和pthread_attr_setstackaddr函数可以被程序用于将栈设置在指定的内存区域。 </p>
<p>在LC上的一些实际例子:  </p>
<p>默认栈大小经常变化很大，最大值也变化很大，可能会依赖于每个节点的线程数目。 </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th> Node Architecture</th><br>            <th> #CPUS </th><br>            <th> Memory(GB) </th><br>            <th> Default Size (bytes) </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td> AMD Opteron </td><br>            <td> 8 </td><br>            <td> 16 </td><br>            <td> 2,097,152 </td><br>        </tr><br>        <tr><br>            <td> Intel IA64 </td><br>            <td> 4 </td><br>            <td> 8 </td><br>            <td> 33,554,432 </td><br>        </tr><br>        <tr><br>            <td> Intel IA32 </td><br>            <td> 2 </td><br>            <td> 4 </td><br>            <td> 2,097,152 </td><br>        </tr><br>        <tr><br>            <td> IBM Power5 </td><br>            <td> 8 </td><br>            <td> 32 </td><br>            <td> 196,608</td><br>        </tr><br>        <tr><br>            <td> IBM Power4 </td><br>            <td> 8 </td><br>            <td> 16 </td><br>            <td> 196,608</td><br>        </tr><br>        <tr><br>            <td> IBM Power3 </td><br>            <td> 16 </td><br>            <td> 32 </td><br>            <td> 98,304 </td><br>        </tr><br>    </tbody><br></table>


<p><strong>例子: 栈管理</strong></p>
<p>Example Code - Stack Management  </p>
<p>这个例子演示了如何去查询和设定线程栈大小。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NTHREADS 4 </div><div class="line">#define N 1000 </div><div class="line">#define MEGEXTRA 1000000 </div><div class="line">  </div><div class="line">pthread_attr_t attr; </div><div class="line">  </div><div class="line">void *dowork(void *threadid) </div><div class="line">&#123; </div><div class="line">   double A[N][N]; </div><div class="line">   int i,j,tid; </div><div class="line">   size_t mystacksize; </div><div class="line"> </div><div class="line">   tid = (int)threadid; </div><div class="line">   pthread_attr_getstacksize (&amp;attr, &amp;mystacksize); </div><div class="line">   printf(&quot;Thread %d: stack size = %li bytes /n&quot;, tid, mystacksize); </div><div class="line">   for (i=0; i&lt;N; i++) </div><div class="line">     for (j=0; j&lt;N; j++) </div><div class="line">      A[i][j] = ((i*j)/3.452) + (N-i); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line">  </div><div class="line">int main(int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t threads[NTHREADS]; </div><div class="line">   size_t stacksize; </div><div class="line">   int rc, t; </div><div class="line">  </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_getstacksize (&amp;attr, &amp;stacksize); </div><div class="line">   printf(&quot;Default stack size = %li/n&quot;, stacksize); </div><div class="line">   stacksize = sizeof(double)*N*N+MEGEXTRA; </div><div class="line">   printf(&quot;Amount of stack needed per thread = %li/n&quot;,stacksize); </div><div class="line">   pthread_attr_setstacksize (&amp;attr, stacksize); </div><div class="line">   printf(&quot;Creating threads with stack size = %li bytes/n&quot;,stacksize); </div><div class="line">   for(t=0; t&lt;NTHREADS; t++)&#123; </div><div class="line">      rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (void *)t); </div><div class="line">      if (rc)&#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create() is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line">   printf(&quot;Created %d threads./n&quot;, t); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-5-其他各种函数"><a href="#5-5-其他各种函数" class="headerlink" title=" 5.5 其他各种函数"></a><a id="5.5"></a> 5.5 其他各种函数</h4><pre><code>pthread_self ()  
pthread_equal (thread1,thread2)  
</code></pre><p>pthread_self返回调用该函数的线程的唯一，系统分配的线程ID。 </p>
<p>pthread_equal比较两个线程ID,若不同返回0，否则返回非0值。 </p>
<p>注意这两个函数中的线程ID对象是不透明的，不是轻易能检查的。因为线程ID是不透明的对象，所以C语言的==操作符不能用于比较两个线程ID。 </p>
<pre><code>pthread_once (once_control, init_routine)  
</code></pre><p>pthread_once 在一个进程中仅执行一次init_routine。任何线程第一次调用该函数会执行给定的init_routine，不带参数，任何后续调用都没有效果。 </p>
<p>init_routine函数一般是初始化的程序 </p>
<p>once_control参数是一个同步结构体，需要在调用pthread_once前初始化。例如： </p>
<pre><code>pthread_once_t once_control = PTHREAD_ONCE_INIT;  
</code></pre><hr>
<h3 id="6-互斥量（Mutex-Variables）"><a href="#6-互斥量（Mutex-Variables）" class="headerlink" title=" 6. 互斥量（Mutex Variables）"></a><a id="6"></a> 6. 互斥量（Mutex Variables）</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title=" 6.1 概述"></a><a id="6.1"></a> 6.1 概述</h4><p>互斥量（Mutex）是“mutual exclusion”的缩写。互斥量是实现线程同步，和保护同时写共享数据的主要方法 </p>
<p>互斥量对共享数据的保护就像一把锁。在Pthreads中，任何时候仅有一个线程可以锁定互斥量，因此，当多个线程尝试去锁定该互斥量时仅有一个会成功。直到锁定互斥量的线程解锁互斥量后，其他线程才可以去锁定互斥量。线程必须轮着访问受保护数据。 </p>
<p>互斥量可以防止“竞争”条件。下面的例子是一个银行事务处理时发生了竞争条件：</p>
<table class="table talbe.stripped"><br>    <thead><br>        <tr><br>            <th> Thread 1 </th><br>            <th> Thread 2 </th><br>            <th> Balance </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Read balance: $1000 </td><br>            <td></td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Read balance: $1000 </td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Deposit $200 </td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td>Deposit $200</td><br>            <td></td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td>Update balance $1000+$200 </td><br>            <td></td><br>            <td>$1200</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Update balance $1000+$200 </td><br>            <td>$1200</td><br>        </tr><br>    </tbody><br></table>

<p>上面的例子，当一个线程使用共享数据资源时，应该用一个互斥量去锁定“Balance”。 </p>
<p>一个拥有互斥量的线程经常用于更新全局变量。确保了多个线程更新同样的变量以安全的方式运行，最终的结果和一个线程处理的结果是相同的。这个更新的变量属于一个“临界区（critical section）”。 </p>
<p>使用互斥量的典型顺序如下： </p>
<ul>
<li>创建和初始一个互斥量 </li>
<li>多个线程尝试去锁定该互斥量 </li>
<li>仅有一个线程可以成功锁定改互斥量 </li>
<li>锁定成功的线程做一些处理 </li>
<li>线程解锁该互斥量 </li>
<li>另外一个线程获得互斥量，重复上述过程 </li>
<li>最后销毁互斥量 </li>
</ul>
<p>当多个线程竞争同一个互斥量时，失败的线程会阻塞在lock调用处。可以用“trylock”替换“lock”，则失败时不会阻塞。 </p>
<p>当保护共享数据时，程序员有责任去确认是否需要使用互斥量。如，若四个线程会更新同样的数据，但仅有一个线程用了互斥量，则数据可能会损坏。 </p>
<hr>
<h4 id="6-2-创建和销毁互斥量"><a href="#6-2-创建和销毁互斥量" class="headerlink" title=" 6.2 创建和销毁互斥量"></a><a id="6.2"></a> 6.2 创建和销毁互斥量</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_mutex_init (mutex,attr)  
pthread_mutex_destroy (mutex)  
pthread_mutexattr_init (attr)  
pthread_mutexattr_destroy (attr)  
</code></pre><p><strong>用法</strong>：</p>
<p>互斥量必须用类型pthread_mutex_t类型声明，在使用前必须初始化，这里有两种方法可以初始化互斥量： </p>
<p>声明时静态地，如：<br>    pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;  </p>
<p>动态地用pthread_mutex_init()函数，这种方法允许设定互斥量的属性对象attr。 </p>
<p>互斥量初始化后是解锁的。 </p>
<p>attr对象用于设置互斥量对象的属性，使用时必须声明为pthread_mutextattr_t类型，默认值可以是NULL。Pthreads标准定义了三种可选的互斥量属性： </p>
<ul>
<li>协议（Protocol）： 指定了协议用于阻止互斥量的优先级改变 </li>
<li>优先级上限（Prioceiling）：指定互斥量的优先级上限 </li>
<li>进程共享（Process-shared）：指定进程共享互斥量 </li>
</ul>
<p>注意所有实现都提供了这三个可先的互斥量属性。 </p>
<p>pthread_mutexattr_init()和pthread_mutexattr_destroy()函数分别用于创建和销毁互斥量属性对象。 </p>
<p>pthread_mutex_destroy()应该用于释放不需要再使用的互斥量对象。 </p>
<hr>
<h4 id="6-3-锁定和解锁互斥量"><a href="#6-3-锁定和解锁互斥量" class="headerlink" title=" 6.3 锁定和解锁互斥量"></a><a id="6.3"></a> 6.3 锁定和解锁互斥量</h4><p><strong>函数</strong>：  </p>
<pre><code>pthread_mutex_lock (mutex)  
pthread_mutex_trylock (mutex)  
pthread_mutex_unlock (mutex)  
</code></pre><p><strong>用法</strong>：</p>
<p>线程用pthread_mutex_lock()函数去锁定指定的mutex变量，若该mutex已经被另外一个线程锁定了，该调用将会阻塞线程直到mutex被解锁。 </p>
<p>pthread_mutex_trylock() will attempt to lock a mutex. However, if the mutex is already locked, the routine will return immediately with a “busy” error code. This routine may be useful in  </p>
<p>pthread_mutex_trylock()</p>
<p>尝试着去锁定一个互斥量，然而，若互斥量已被锁定，程序会立刻返回并返回一个忙错误值。该函数在优先级改变情况下阻止死锁是非常有用的。 </p>
<p>线程可以用pthread_mutex_unlock()解锁自己占用的互斥量。在一个线程完成对保护数据的使用，而其它线程要获得互斥量在保护数据上工作时，可以调用该函数。若有一下情形则会发生错误： </p>
<ul>
<li>互斥量已经被解锁 </li>
<li>互斥量被另一个线程占用 </li>
</ul>
<p>互斥量并没有多么“神奇”的，实际上，它们就是参与的线程的“君子约定”。写代码时要确信正确地锁定，解锁互斥量。下面演示了一种逻辑错误： </p>
<pre><code>·                    Thread 1     Thread 2     Thread 3 
·                    Lock         Lock          
·                    A = 2        A = A+1      A = A*B 
·                    Unlock       Unlock     
</code></pre><p>Q：有多个线程等待同一个锁定的互斥量，当互斥量被解锁后，那个线程会第一个锁定互斥量？ </p>
<p>A：除非线程使用了优先级调度机制，否则，线程会被系统调度器去分配，那个线程会第一个锁定互斥量是随机的。 </p>
<p><strong>例子：使用互斥量</strong></p>
<p>Example Code - Using Mutexes  </p>
<p>例程演示了线程使用互斥量处理一个点积（dot product）计算。主数据通过一个可全局访问的数据结构被所有线程使用，每个线程处理数据的不同部分，主线程等待其他线程完成计算并输出结果。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#include &lt;malloc.h&gt; </div><div class="line"> </div><div class="line">/*    </div><div class="line">The following structure contains the necessary information   </div><div class="line">to allow the function &quot;dotprod&quot; to access its input data and  </div><div class="line">place its output into the structure.   </div><div class="line">*/ </div><div class="line"> </div><div class="line">typedef struct  </div><div class="line"> &#123; </div><div class="line">   double      *a; </div><div class="line">   double      *b; </div><div class="line">   double     sum;  </div><div class="line">   int     veclen;  </div><div class="line"> &#125; DOTDATA; </div><div class="line"> </div><div class="line">/* Define globally accessible variables and a mutex */ </div><div class="line"> </div><div class="line">#define NUMTHRDS 4 </div><div class="line">#define VECLEN 100 </div><div class="line">   DOTDATA dotstr;  </div><div class="line">   pthread_t callThd[NUMTHRDS]; </div><div class="line">   pthread_mutex_t mutexsum; </div><div class="line"> </div><div class="line">/* </div><div class="line">The function dotprod is activated when the thread is created. </div><div class="line">All input to this routine is obtained from a structure  </div><div class="line">of type DOTDATA and all output from this function is written into </div><div class="line">this structure. The benefit of this approach is apparent for the  </div><div class="line">multi-threaded program: when a thread is created we pass a single </div><div class="line">argument to the activated function - typically this argument </div><div class="line">is a thread number. All  the other information required by the  </div><div class="line">function is accessed from the globally accessible structure.  </div><div class="line">*/ </div><div class="line"> </div><div class="line">void *dotprod(void *arg) </div><div class="line">&#123; </div><div class="line"> </div><div class="line">   /* Define and use local variables for convenience */ </div><div class="line"> </div><div class="line">   int i, start, end, offset, len ; </div><div class="line">   double mysum, *x, *y; </div><div class="line">   offset = (int)arg; </div><div class="line">      </div><div class="line">   len = dotstr.veclen; </div><div class="line">   start = offset*len; </div><div class="line">   end   = start + len; </div><div class="line">   x = dotstr.a; </div><div class="line">   y = dotstr.b; </div><div class="line"> </div><div class="line">   /* </div><div class="line">   Perform the dot product and assign result </div><div class="line">   to the appropriate variable in the structure.  </div><div class="line">   */ </div><div class="line"> </div><div class="line">   mysum = 0; </div><div class="line">   for (i=start; i&lt;end ; i++)  </div><div class="line">    &#123; </div><div class="line">      mysum += (x[i] * y[i]); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">   /* </div><div class="line">   Lock a mutex prior to updating the value in the shared </div><div class="line">   structure, and unlock it upon updating. </div><div class="line">   */ </div><div class="line">   pthread_mutex_lock (&amp;mutexsum); </div><div class="line">   dotstr.sum += mysum; </div><div class="line">   pthread_mutex_unlock (&amp;mutexsum); </div><div class="line"> </div><div class="line">   pthread_exit((void*) 0); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">/*  </div><div class="line">The main program creates threads which do all the work and then  </div><div class="line">print out result upon completion. Before creating the threads, </div><div class="line">the input data is created. Since all threads update a shared structure,  </div><div class="line">we need a mutex for mutual exclusion. The main thread needs to wait for </div><div class="line">all threads to complete, it waits for each one of the threads. We specify </div><div class="line">a thread attribute value that allow the main thread to join with the </div><div class="line">threads it creates. Note also that we free up handles when they are </div><div class="line">no longer needed. </div><div class="line">*/ </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   int i; </div><div class="line">   double *a, *b; </div><div class="line">   void *status; </div><div class="line">   pthread_attr_t attr; </div><div class="line"> </div><div class="line">   /* Assign storage and initialize values */ </div><div class="line">   a = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); </div><div class="line">   b = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); </div><div class="line">   </div><div class="line">   for (i=0; i&lt;VECLEN*NUMTHRDS; i++) </div><div class="line">    &#123; </div><div class="line">     a[i]=1.0; </div><div class="line">     b[i]=a[i]; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">   dotstr.veclen = VECLEN;  </div><div class="line">   dotstr.a = a;  </div><div class="line">   dotstr.b = b;  </div><div class="line">   dotstr.sum=0; </div><div class="line"> </div><div class="line">   pthread_mutex_init(&amp;mutexsum, NULL); </div><div class="line">          </div><div class="line">   /* Create threads to perform the dotproduct  */ </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line"> </div><div class="line">        for(i=0; i&lt;NUMTHRDS; i++) </div><div class="line">        &#123; </div><div class="line">        /*  </div><div class="line">        Each thread works on a different set of data. </div><div class="line">        The offset is specified by &apos;i&apos;. The size of </div><div class="line">        the data for each thread is indicated by VECLEN. </div><div class="line">        */ </div><div class="line">        pthread_create( &amp;callThd[i], &amp;attr, dotprod, (void *)i); </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">        pthread_attr_destroy(&amp;attr); </div><div class="line"> </div><div class="line">        /* Wait on the other threads */ </div><div class="line">        for(i=0; i&lt;NUMTHRDS; i++) </div><div class="line">        &#123; </div><div class="line">          pthread_join( callThd[i], &amp;status); </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">   /* After joining, print out the results and cleanup */ </div><div class="line">   printf (&quot;Sum =  %f /n&quot;, dotstr.sum); </div><div class="line">   free (a); </div><div class="line">   free (b); </div><div class="line">   pthread_mutex_destroy(&amp;mutexsum); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="7-条件变量（Condition-Variables）"><a href="#7-条件变量（Condition-Variables）" class="headerlink" title=" 7. 条件变量（Condition Variables）"></a><a id="7"></a> 7. 条件变量（Condition Variables）</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title=" 7.1 概述"></a><a id="7.1"></a> 7.1 概述</h4><p>条件变量提供了另一种同步的方式。互斥量通过控制对数据的访问实现了同步，而条件变量允许根据实际的数据值来实现同步。 </p>
<p>没有条件变量，程序员就必须使用线程去轮询（可能在临界区），查看条件是否满足。这样比较消耗资源，因为线程连续繁忙工作。条件变量是一种可以实现这种轮询的方式。 </p>
<p>条件变量往往和互斥一起使用 </p>
<p>使用条件变量的代表性顺序如下： </p>
<pre><code>主线程（Main Thread）  
o                                声明和初始化需要同步的全局数据/变量（如“count”） 
o                                生命和初始化一个条件变量对象 
o                                声明和初始化一个相关的互斥量 
o                                创建工作线程A和B 

Thread A  
o                                工作，一直到一定的条件满足（如“count”等于一个指定的值） 
o                                锁定相关互斥量并检查全局变量的值 
o                                调用pthread_cond_wait()阻塞等待Thread-B的信号。注意pthread_cond_wait()能够自动地并且原子地解锁相关的互斥量，以至于它可以被Thread-B使用。 
o                                当收到信号，唤醒线程，互斥量被自动，原子地锁定。 
o                                显式解锁互斥量 
o                                继续 
Thread B  
o                                工作 
o                                锁定相关互斥量 
o                                改变Thread-A所等待的全局变量 
o                                检查全局变量的值，若达到需要的条件，像Thread-A发信号。 
o                                解锁互斥量 
o                                继续 

Main Thread  
Join / Continue  
</code></pre><hr>
<h4 id="7-2-创建和销毁条件变量"><a href="#7-2-创建和销毁条件变量" class="headerlink" title=" 7.2 创建和销毁条件变量"></a><a id="7.2"></a> 7.2 创建和销毁条件变量</h4><p><strong>Routines</strong>:  </p>
<pre><code>pthread_cond_init (condition,attr)  
pthread_cond_destroy (condition)  
pthread_condattr_init (attr)  
pthread_condattr_destroy (attr)  
</code></pre><p><strong>Usage</strong>:  </p>
<p>条件变量必须声明为pthread_cond_t类型，必须在使用前初始化。有两种方式可以初始条件变量： </p>
<p>声明时静态地。如：</p>
<pre><code>pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER;  
</code></pre><p>用pthread_cond_init()函数动态地。创建的条件变量ID通过condition参数返回给调用线程。该方式允许设置条件变量对象的属性，attr。 </p>
<p>可选的attr对象用于设定条件变量的属性。仅有一个属性被定义：线程共享（process-shared），可以使条件变量被其它进程中的线程看到。若要使用属性对象，必须定义为pthread_condattr_t类型（可以指定为NULL设为默认）。 </p>
<p>注意所有实现都提供了线程共享属性。 </p>
<p>pthread_condattr_init()和pthread_condattr_destroy()用于创建和销毁条件变量属性对象。 </p>
<p>条件变量不需要再使用时，应用pthread_cond_destroy()释放条件变量。 </p>
<hr>
<h4 id="7-3-在条件变量上等待（Waiting）和发送信号（Signaling）"><a href="#7-3-在条件变量上等待（Waiting）和发送信号（Signaling）" class="headerlink" title=" 7.3 在条件变量上等待（Waiting）和发送信号（Signaling）"></a><a id="7.3"></a> 7.3 在条件变量上等待（Waiting）和发送信号（Signaling）</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_cond_wait (condition,mutex)  
pthread_cond_signal (condition)  
pthread_cond_broadcast (condition)  
</code></pre><p><strong>用法</strong>：</p>
<p>pthread_cond_wait()阻塞调用线程直到指定的条件受信（signaled）。该函数应该在互斥量锁定时调用，当在等待时会自动解锁互斥量。在信号被发送，线程被激活后，互斥量会自动被锁定，当线程结束时，由程序员负责解锁互斥量。 </p>
<p>pthread_cond_signal()函数用于向其他等待在条件变量上的线程发送信号（激活其它线程）。应该在互斥量被锁定后调用。 </p>
<p>若不止一个线程阻塞在条件变量上，则应用pthread_cond_broadcast()向其它所以线程发生信号。 </p>
<p>在调用pthread_cond_wait()前调用pthread_cond_signal()会发生逻辑错误。 </p>
<p>使用这些函数时适当的锁定和解锁相关的互斥量是非常重要的。如： </p>
<ul>
<li>调用pthread_cond_wait()前锁定互斥量失败可能导致线程不会阻塞。 </li>
<li>调用pthread_cond_signal()后解锁互斥量失败可能会不允许相应的pthread_cond_wait()函数结束（保存阻塞）。 </li>
</ul>
<p><strong>例子：使用条件变量 </strong></p>
<p>Example Code - Using Condition Variables  </p>
<p>例子演示了使用Pthreads条件变量的几个函数。主程序创建了三个线程，两个线程工作，根系“count”变量。第三个线程等待count变量值达到指定的值。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line"> </div><div class="line">#define NUM_THREADS  3 </div><div class="line">#define TCOUNT 10 </div><div class="line">#define COUNT_LIMIT 12 </div><div class="line"> </div><div class="line">int     count = 0; </div><div class="line">int     thread_ids[3] = &#123;0,1,2&#125;; </div><div class="line">pthread_mutex_t count_mutex; </div><div class="line">pthread_cond_t count_threshold_cv; </div><div class="line"> </div><div class="line">void *inc_count(void *idp)  </div><div class="line">&#123; </div><div class="line">  int j,i; </div><div class="line">  double result=0.0; </div><div class="line">  int *my_id = idp; </div><div class="line"> </div><div class="line">  for (i=0; i&lt;TCOUNT; i++) &#123; </div><div class="line">    pthread_mutex_lock(&amp;count_mutex); </div><div class="line">    count++; </div><div class="line"> </div><div class="line">    /*  </div><div class="line">    Check the value of count and signal waiting thread when condition is </div><div class="line">    reached.  Note that this occurs while mutex is locked.  </div><div class="line">    */ </div><div class="line">    if (count == COUNT_LIMIT) &#123; </div><div class="line">      pthread_cond_signal(&amp;count_threshold_cv); </div><div class="line">      printf(&quot;inc_count(): thread %d, count = %d  Threshold reached./n&quot;,  </div><div class="line">             *my_id, count); </div><div class="line">      &#125; </div><div class="line">    printf(&quot;inc_count(): thread %d, count = %d, unlocking mutex/n&quot;,  </div><div class="line">           *my_id, count); </div><div class="line">    pthread_mutex_unlock(&amp;count_mutex); </div><div class="line"> </div><div class="line">    /* Do some work so threads can alternate on mutex lock */ </div><div class="line">    for (j=0; j&lt;1000; j++) </div><div class="line">      result = result + (double)random(); </div><div class="line">    &#125; </div><div class="line">  pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">void *watch_count(void *idp)  </div><div class="line">&#123; </div><div class="line">  int *my_id = idp; </div><div class="line"> </div><div class="line">  printf(&quot;Starting watch_count(): thread %d/n&quot;, *my_id); </div><div class="line"> </div><div class="line">  /* </div><div class="line">  Lock mutex and wait for signal.  Note that the pthread_cond_wait  </div><div class="line">  routine will automatically and atomically unlock mutex while it waits.  </div><div class="line">  Also, note that if COUNT_LIMIT is reached before this routine is run by </div><div class="line">  the waiting thread, the loop will be skipped to prevent pthread_cond_wait </div><div class="line">  from never returning.  </div><div class="line">  */ </div><div class="line">  pthread_mutex_lock(&amp;count_mutex); </div><div class="line">  if (count&lt;COUNT_LIMIT) &#123; </div><div class="line">    pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex); </div><div class="line">    printf(&quot;watch_count(): thread %d Condition signal  </div><div class="line">           received./n&quot;, *my_id); </div><div class="line">    &#125; </div><div class="line">  pthread_mutex_unlock(&amp;count_mutex); </div><div class="line">  pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">  int i, rc; </div><div class="line">  pthread_t threads[3]; </div><div class="line">  pthread_attr_t attr; </div><div class="line"> </div><div class="line">  /* Initialize mutex and condition variable objects */ </div><div class="line">  pthread_mutex_init(&amp;count_mutex, NULL); </div><div class="line">  pthread_cond_init (&amp;count_threshold_cv, NULL); </div><div class="line"> </div><div class="line">  /* For portability, explicitly create threads in a joinable state */ </div><div class="line">  pthread_attr_init(&amp;attr); </div><div class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line">  pthread_create(&amp;threads[0], &amp;attr, inc_count, (void *)&amp;thread_ids[0]); </div><div class="line">  pthread_create(&amp;threads[1], &amp;attr, inc_count, (void *)&amp;thread_ids[1]); </div><div class="line">  pthread_create(&amp;threads[2], &amp;attr, watch_count, (void *)&amp;thread_ids[2]); </div><div class="line"> </div><div class="line">  /* Wait for all threads to complete */ </div><div class="line">  for (i=0; i&lt;NUM_THREADS; i++) &#123; </div><div class="line">    pthread_join(threads[i], NULL); </div><div class="line">  &#125; </div><div class="line">  printf (&quot;Main(): Waited on %d  threads. Done./n&quot;, NUM_THREADS); </div><div class="line"> </div><div class="line">  /* Clean up and exit */ </div><div class="line">  pthread_attr_destroy(&amp;attr); </div><div class="line">  pthread_mutex_destroy(&amp;count_mutex); </div><div class="line">  pthread_cond_destroy(&amp;count_threshold_cv); </div><div class="line">  pthread_exit(NULL); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="8-没有覆盖的主题"><a href="#8-没有覆盖的主题" class="headerlink" title=" 8. 没有覆盖的主题"></a><a id="8"></a> 8. 没有覆盖的主题</h3><p>Pthread API的几个特性在该教程中并没有包含。把它们列在下面： </p>
<ul>
<li>线程调度<br><strong> 线程如何调度的实现往往是不同的，在大多数情况下，默认的机制是可以胜任的。 
</strong> Pthreads　API提供了显式设定线程调度策略和优先级的函数，它们可以重载默认机制。 </li>
<li>API不需要实现去支持这些特性 </li>
<li>Keys：线程数据（TSD） </li>
<li>互斥量的Protocol属性和优先级管理 </li>
<li>跨进程的条件变量共享 </li>
<li>取消线程（Thread Cancellation ） </li>
<li>多线程和信号（Threads and Signals）  </li>
</ul>
<hr>
<h3 id="9-Pthread-库API参考"><a href="#9-Pthread-库API参考" class="headerlink" title=" 9. Pthread 库API参考"></a><a id="9"></a> 9. Pthread 库API参考</h3><p><strong>Pthread Functions</strong>:</p>
<ul>
<li><p>Thread Management  </p>
<p>  pthread_create<br>  pthread_exit<br>  pthread_join<br>  pthread_once<br>  pthread_kill<br>  pthread_self<br>  pthread_equal<br>  pthread_yield<br>  pthread_detach   </p>
</li>
<li><p>Thread-Specific Data </p>
<p>  pthread_key_create<br>  pthread_key_delete<br>  pthread_getspecific<br>  pthread_setspecific </p>
</li>
<li><p>Thread Cancellation<br><strong> pthread_cancel 
</strong> pthread_cleanup_pop<br><strong> pthread_cleanup_push 
</strong> pthread_setcancelstate<br><strong> pthread_getcancelstate  
</strong> pthread_testcancel </p>
</li>
<li><p>Thread Scheduling<br><strong> pthread_getschedparam 
</strong> pthread_setschedparam </p>
</li>
<li><p>Signals<br>** pthread_sigmask </p>
</li>
</ul>
<p><strong>Pthread Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management<br><strong> pthread_attr_init 
</strong> pthread_attr_destroy </p>
</li>
<li><p>Detachable or Joinable<br><strong> pthread_attr_setdetachstate 
</strong> pthread_attr_getdetachstate </p>
</li>
<li><p>Specifying Stack Information<br><strong> pthread_attr_getstackaddr 
</strong> pthread_attr_getstacksize<br><strong> pthread_attr_setstackaddr 
</strong> pthread_attr_setstacksize </p>
</li>
<li><p>Thread Scheduling Attributes<br><strong> pthread_attr_getschedparam 
</strong> pthread_attr_setschedparam<br><strong> pthread_attr_getschedpolicy 
</strong> pthread_attr_setschedpolicy<br><strong> pthread_attr_setinheritsched 
</strong> pthread_attr_getinheritsched<br><strong> pthread_attr_setscope 
</strong> pthread_attr_getscope </p>
</li>
</ul>
<p><strong>Mutex Functions</strong>:</p>
<ul>
<li><p>Mutex Management<br><strong> pthread_mutex_init 
</strong> pthread_mutex_destroy<br><strong> pthread_mutex_lock 
</strong> pthread_mutex_unlock<br>** pthread_mutex_trylock </p>
</li>
<li><p>Priority Management<br><strong> pthread_mutex_setprioceiling 
</strong> pthread_mutex_getprioceiling </p>
</li>
</ul>
<p><strong>Mutex Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management<br><strong> pthread_mutexattr_init 
</strong> pthread_mutexattr_destroy </p>
</li>
<li><p>Sharing<br><strong> pthread_mutexattr_getpshared 
</strong> pthread_mutexattr_setpshared </p>
</li>
<li><p>Protocol Attributes<br><strong> pthread_mutexattr_getprotocol 
</strong> pthread_mutexattr_setprotocol </p>
</li>
<li><p>Priority Management<br><strong> pthread_mutexattr_setprioceiling 
</strong> pthread_mutexattr_getprioceiling </p>
</li>
</ul>
<p><strong>Condition Variable Functions</strong>:</p>
<ul>
<li>Basic Management<br><strong> pthread_cond_init 
</strong> pthread_cond_destroy<br><strong> pthread_cond_signal 
</strong> pthread_cond_broadcast<br><strong> pthread_cond_wait 
</strong> pthread_cond_timedwait </li>
</ul>
<p><strong>Condition Variable Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management </p>
<p>  pthread_condattr_init<br>  pthread_condattr_destroy </p>
</li>
<li><p>Sharing </p>
<p>  pthread_condattr_getpshared<br>  pthread_condattr_setpshared </p>
</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title=" 参考资料"></a><a id="10"></a> 参考资料</h3><ul>
<li>Author: Blaise Barney, Livermore Computing.  </li>
<li>“Pthreads Programming”. B. Nichols et al. O’Reilly and Associates.  </li>
<li>“Threads Primer”. B. Lewis and D. Berg. Prentice Hall  </li>
<li>“Programming With POSIX Threads”. D. Butenhof. Addison Wesley </li>
<li>www.awl.com/cseng/titles/0-201-63392-2  </li>
<li>“Programming With Threads”. S. Kleiman et al. Prentice Hall  </li>
</ul>
<p>(完)</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/多线程/" rel="tag">#多线程</a>
          
            <a href="/tags/pthread/" rel="tag">#pthread</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2009/02/04/linux-module-commands/" rel="next" title="内核模块相关命令：lsmod,depmod,modprob...">
                <i class="fa fa-chevron-left"></i> 内核模块相关命令：lsmod,depmod,modprob...
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2009/02/06/initramfs/" rel="prev" title="initramfs 简介，一个新的 initial RAM disks 模型">
                initramfs 简介，一个新的 initial RAM disks 模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2009/02/05/posix-thread-cn/"
     data-title="POSIX多线程程序设计"
     data-content=""
     data-url="http://yoursite.com/2009/02/05/posix-thread-cn/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2009/02/05/posix-thread-cn/"
           data-title="POSIX多线程程序设计" data-url="http://yoursite.com/2009/02/05/posix-thread-cn/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="David++" />
          <p class="site-author-name" itemprop="name">David++</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">92</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/david-pp" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/davidpp" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gamelab" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/future_fighter/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-摘要"><span class="nav-number">2.</span> <span class="nav-text"> 1. 摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-译者序"><span class="nav-number">3.</span> <span class="nav-text"> 2. 译者序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Pthreads概述"><span class="nav-number">4.</span> <span class="nav-text"> 3. Pthreads概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-什么是线程"><span class="nav-number">4.1.</span> <span class="nav-text"> 3.1 什么是线程?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-什么是-Pthreads"><span class="nav-number">4.2.</span> <span class="nav-text"> 3.2 什么是 Pthreads?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-为什么使用-Pthreads"><span class="nav-number">4.3.</span> <span class="nav-text"> 3.3 为什么使用 Pthreads?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-使用线程设计程序"><span class="nav-number">4.4.</span> <span class="nav-text"> 3.4 使用线程设计程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#并行编程"><span class="nav-number">4.4.1.</span> <span class="nav-text">并行编程:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#共享内存模型（Shared-Memory-Model）"><span class="nav-number">4.4.2.</span> <span class="nav-text">共享内存模型（Shared Memory Model）:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程安全（Thread-safeness）"><span class="nav-number">4.4.3.</span> <span class="nav-text">线程安全（Thread-safeness）:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-编译多线程程序"><span class="nav-number">5.</span> <span class="nav-text"> 4. 编译多线程程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-线程管理（Thread-Management）"><span class="nav-number">6.</span> <span class="nav-text"> 5. 线程管理（Thread Management）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-创建和结束线程"><span class="nav-number">6.1.</span> <span class="nav-text"> 5.1 创建和结束线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-向线程传递参数"><span class="nav-number">6.2.</span> <span class="nav-text"> 5.2 向线程传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-连接（Joining）和分离（Detaching）线程"><span class="nav-number">6.3.</span> <span class="nav-text"> 5.3 连接（Joining）和分离（Detaching）线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-栈管理"><span class="nav-number">6.4.</span> <span class="nav-text"> 5.4 栈管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-其他各种函数"><span class="nav-number">6.5.</span> <span class="nav-text"> 5.5 其他各种函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-互斥量（Mutex-Variables）"><span class="nav-number">7.</span> <span class="nav-text"> 6. 互斥量（Mutex Variables）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-概述"><span class="nav-number">7.1.</span> <span class="nav-text"> 6.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-创建和销毁互斥量"><span class="nav-number">7.2.</span> <span class="nav-text"> 6.2 创建和销毁互斥量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-锁定和解锁互斥量"><span class="nav-number">7.3.</span> <span class="nav-text"> 6.3 锁定和解锁互斥量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-条件变量（Condition-Variables）"><span class="nav-number">8.</span> <span class="nav-text"> 7. 条件变量（Condition Variables）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-概述"><span class="nav-number">8.1.</span> <span class="nav-text"> 7.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-创建和销毁条件变量"><span class="nav-number">8.2.</span> <span class="nav-text"> 7.2 创建和销毁条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-在条件变量上等待（Waiting）和发送信号（Signaling）"><span class="nav-number">8.3.</span> <span class="nav-text"> 7.3 在条件变量上等待（Waiting）和发送信号（Signaling）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-没有覆盖的主题"><span class="nav-number">9.</span> <span class="nav-text"> 8. 没有覆盖的主题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Pthread-库API参考"><span class="nav-number">10.</span> <span class="nav-text"> 9. Pthread 库API参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">11.</span> <span class="nav-text"> 参考资料</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David++</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tiny-lab"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>

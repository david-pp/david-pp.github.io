<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="TinyLab" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="TinyLab">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="TinyLab">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TinyLab">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/8/"/>


  <title> TinyLab </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?32177a2b43f11f13565131b8c1239878";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TinyLab</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep eyes on the star and feet on the ground.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/05/posix-thread-cn/" itemprop="url">
                  POSIX多线程程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-05T21:27:00+08:00" content="2009-02-05">
              2009-02-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/05/posix-thread-cn/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/05/posix-thread-cn/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li><a href="#abstract">摘要</a>  </li>
<li><a href="#david">译者序</a></li>
<li><a href="#pthread-intro">Pthreads 概述</a><br> 3.1 <a href="#3.1">什么是线程?</a><br> 3.2 <a href="#3.2">什么是Pthreads?</a><br> 3.3 <a href="#3.3">为什么使用Pthreads?</a><br> 3.4 <a href="#3.4">使用线程设计程序</a>   </li>
<li><a href="#4">Pthreads API编译多线程程序</a>  </li>
<li><a href="#5">线程管理</a><br> 5.1 <a href="#5.1">创建和终止线程</a><br> 5.2 <a href="#5.2">向线程传递参数</a><br> 5.3 <a href="#5.3">连接（Joining）和分离（Detaching）线程</a><br> 5.4 <a href="#5.4">栈管理</a><br> 5.5 <a href="#5.5">其它函数</a>   </li>
<li><a href="#6">互斥量（Mutex Variables）</a><br> 6.1 <a href="#6.1">互斥量概述</a><br> 6.2 <a href="#6.2">创建和销毁互斥量</a><br> 6.3 <a href="#6.3">锁定（Locking）和解锁（Unlocking）互斥量</a>  </li>
<li><a href="#7">条件变量（Condition Variable）</a><br> 7.1 <a href="#7.1">条件变量概述</a><br> 7.2 <a href="#7.2">创建和销毁条件变量</a><br> 7.3 <a href="#7.3">等待（Waiting）和发送信号（Signaling）</a>  </li>
<li><a href="#8">没有覆盖的主题</a></li>
<li><a href="#9">Pthread 库API参考</a>  </li>
<li><a href="#10">参考资料</a></li>
</ol>
<hr>
<h3 id="1-摘要"><a href="#1-摘要" class="headerlink" title=" 1. 摘要"></a><a id="abstract"></a> 1. 摘要</h3><p>在多处理器共享内存的架构中（如：对称多处理系统SMP），线程可以用于实现程序的并行性。历史上硬件销售商实现了各种私有版本的多线程库，使得软件开发者不得不关心它的移植性。对于UNIX系统，IEEE POSIX 1003.1标准定义了一个C语言多线程编程接口。依附于该标准的实现被称为POSIX theads 或 Pthreads。 </p>
<p>该教程介绍了Pthreads的概念、动机和设计思想。内容包含了Pthreads API主要的三大类函数：线程管理（Thread Managment）、互斥量（Mutex Variables）和条件变量（Condition Variables）。向刚开始学习Pthreads的程序员提供了演示例程。 </p>
<p>适于：刚开始学习使用线程实现并行程序设计；对于C并行程序设计有基本了解。不熟悉并行程序设计的可以参考EC3500: Introduction To Parallel Computing。</p>
<hr>
<h3 id="2-译者序"><a href="#2-译者序" class="headerlink" title=" 2. 译者序"></a><a id="david"></a> 2. 译者序</h3><p>三天时间，终于在工作期间，抽空把上一篇POSIX threads programing翻译完了。由于水平有限，翻译质量差强人意，若有不合理或错误之处，请您之处，在此深表感谢！有疑问点此查看原文。在参考部分提及的几本关于Pthreads库的大作及该文章原文和译文可在下面的连接下载：</p>
<ul>
<li>本篇及其英文原文:  <a href="http://download.csdn.net/source/992256" target="_blank" rel="external">http://download.csdn.net/source/992256</a></li>
<li>多线程编程指南:  <a href="http://download.csdn.net/source/992248" target="_blank" rel="external">http://download.csdn.net/source/992248</a></li>
<li>Programing with POSIX thread(强烈推荐): <a href="http://download.csdn.net/source/992239" target="_blank" rel="external">http://download.csdn.net/source/992239</a></li>
<li>Pthread Primer(强烈推荐): <a href="http://download.csdn.net/source/992213" target="_blank" rel="external">http://download.csdn.net/source/992213</a></li>
</ul>
<hr>
<h3 id="3-Pthreads概述"><a href="#3-Pthreads概述" class="headerlink" title=" 3. Pthreads概述"></a><a id="pthread-intro"></a> 3. Pthreads概述</h3><h4 id="3-1-什么是线程"><a href="#3-1-什么是线程" class="headerlink" title=" 3.1 什么是线程?"></a><a id="3.1"></a> 3.1 什么是线程?</h4><p>技术上，线程可以定义为：可以被操作系统调度的独立的指令流。但是这是什么意思呢？ </p>
<p>对于软件开发者，在主程序中运行的“函数过程”可以很好的描述线程的概念。 </p>
<p>进一步，想象下主程序（a.out）包含了许多函数，操作系统可以调度这些函数，使之同时或者（和）独立的执行。这就描述了“多线程”程序。<br>怎样完成的呢？ </p>
<p>在理解线程之前，应先对UNIX进程（process）有所了解。进程被操作系统创建，需要相当多的“额外开销”。进程包含了程序的资源和执行状态信息。如下： </p>
<ul>
<li>进程ID，进程group ID，用户ID和group ID </li>
<li>环境 </li>
<li>工作目录  </li>
<li>程序指令 </li>
<li>寄存器 </li>
<li>栈 </li>
<li>堆 </li>
<li>文件描述符 </li>
<li>信号操作（Signal actions） </li>
<li>共享库 </li>
<li>进程间通信工具（如：消息队列，管道，信号量或共享内存） </li>
</ul>
<p><img src="/images/2009-02-05-process.gif" alt="进程"></p>
<p>线程使用并存在于进程资源中，还可以被操作系统调用并独立地运行，这主要是因为线程仅仅复制必要的资源以使自己得以存在并执行。 </p>
<p>独立的控制流得以实现是因为线程维持着自己的： </p>
<ul>
<li>堆栈指针 </li>
<li>寄存器 </li>
<li>调度属性（如：策略或优先级） </li>
<li>待定的和阻塞的信号集合（Set of pending and blocked signals） </li>
<li>线程专用数据（TSD：Thread Specific Data.） </li>
</ul>
<p>因此，在UNIX环境下线程： </p>
<ul>
<li>存在于进程，使用进程资源 </li>
<li>拥有自己独立的控制流，只要父进程存在并且操作系统支持 </li>
<li>只复制必可以使得独立调度的必要资源 </li>
<li>可以和其他线程独立（或非独立的）地共享进程资源 </li>
<li>当父进程结束时结束，或者相关类似的 </li>
<li>是“轻型的”，因为大部分额外开销已经在进程创建时完成了 </li>
</ul>
<p>因为在同一个进程中的线程共享资源： </p>
<ul>
<li>一个线程对系统资源（如关闭一个文件）的改变对所有其它线程是可以见的 </li>
<li>两个同样值的指针指向相同的数据 </li>
<li>读写同一个内存位置是可能的，因此需要成员显式地使用同步 </li>
</ul>
<hr>
<h4 id="3-2-什么是-Pthreads"><a href="#3-2-什么是-Pthreads" class="headerlink" title=" 3.2 什么是 Pthreads?"></a><a id="3.2"></a> 3.2 什么是 Pthreads?</h4><p>历史上，硬件销售商实现了私有版本的多线程库。这些实现在本质上各自不同，使得程序员难于开发可移植的应用程序。 </p>
<p>为了使用线程所提供的强大优点，需要一个标准的程序接口。对于UNIX系统，IEEE POSIX 1003.1c（1995）标准制订了这一标准接口。依赖于该标准的实现就称为POSIX threads 或者Pthreads。现在多数硬件销售商也提供Pthreads，附加于私有的API。 </p>
<p>Pthreads 被定义为一些C语言类型和函数调用，用pthread.h头（包含）文件和线程库实现。这个库可以是其它库的一部分，如libc。 </p>
<hr>
<h4 id="3-3-为什么使用-Pthreads"><a href="#3-3-为什么使用-Pthreads" class="headerlink" title=" 3.3 为什么使用 Pthreads?"></a><a id="3.3"></a> 3.3 为什么使用 Pthreads?</h4><p>使用Pthreads的主要动机是提高潜在程序的性能。 </p>
<p>当与创建和管理进程的花费相比，线程可以使用操作系统较少的开销，管理线程需要较少的系统资源。 </p>
<p>例如，下表比较了fork()函数和pthread_create()函数所用的时间。计时反应了50,000个进程/线程的创建，使用时间工具实现，单位是秒，没有优化标志。 </p>
<p>备注：不要期待系统和用户时间加起来就是真实时间，因为这些SMP系统有多个CPU同时工作。这些都是近似值。 </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th rowspan="2">平台</th><br>            <th colspan="3">fork()</th><br>            <th colspan="3">pthread_create()</th><br>        </tr><br>        <tr><br>            <th>real</th><br>            <th>user</th><br>            <th>sys</th><br>            <th>real</th><br>            <th>user</th><br>            <th>sys</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>AMD 2.4 GHz Opteron (8cpus/node) </td><br>            <td>41.07</td><br>            <td>60.08</td><br>            <td>9.01</td><br>            <td>0.66</td><br>            <td>0.19</td><br>            <td>0.43</td><br>        </tr><br>        <tr><br>            <td>IBM 1.9 GHz POWER5 p5-575 (8cpus/node) </td><br>            <td>64.24</td><br>            <td>30.78</td><br>            <td>27.68</td><br>            <td>1.75</td><br>            <td>0.69</td><br>            <td>1.10</td><br>        </tr><br>        <tr><br>            <td>IBM 1.5 GHz POWER4 (8cpus/node) </td><br>            <td>104.05</td><br>            <td>48.64</td><br>            <td>47.21</td><br>            <td>2.01</td><br>            <td>1.00</td><br>            <td>1.52</td><br>        </tr><br>        <tr><br>            <td>INTEL 2.4 GHz Xeon (2 cpus/node) </td><br>            <td>54.95</td><br>            <td>1.54</td><br>            <td>20.78</td><br>            <td>1.64</td><br>            <td>0.67</td><br>            <td>0.90</td><br>        </tr><br>        <tr><br>            <td>INTEL 1.4 GHz Itanium2 (4 cpus/node)  </td><br>            <td>54.54</td><br>            <td>1.07</td><br>            <td>22.22</td><br>            <td>2.03</td><br>            <td>1.26</td><br>            <td>0.67</td><br>        </tr><br>    </tbody><br></table>

<p>在同一个进程中的所有线程共享同样的地址空间。较于进程间的通信，在许多情况下线程间的通信效率比较高，且易于使用。 </p>
<p>较于没有使用线程的程序，使用线程的应用程序有潜在的性能增益和实际的优点： </p>
<ul>
<li>CPU使用I/O交叠工作：例如，一个程序可能有一个需要较长时间的I/O操作，当一个线程等待I/O系统调用完成时，CPU可以被其它线程使用。 </li>
<li>优先/实时调度：比较重要的任务可以被调度，替换或者中断较低优先级的任务。 </li>
<li>异步事件处理：频率和持续时间不确定的任务可以交错。例如，web服务器可以同时为前一个请求传输数据和管理新请求。 </li>
</ul>
<p>考虑在SMP架构上使用Pthreads的主要动机是获的最优的性能。特别的，如果一个程序使用MPI在节点通信，使用Pthreads可以使得节点数据传输得到显著提高。 </p>
<p>例如： </p>
<ul>
<li>MPI库经常用共享内存实现节点任务通信，这至少需要一次内存复制操作（进程到进程）。 </li>
<li>Pthreads没有中间的内存复制，因为线程和一个进程共享同样的地址空间。没有数据传输。变成cache-to-CPU或memory-to-CPU的带宽（最坏情况），速度是相当的快。 </li>
<li>比较如下： </li>
</ul>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th>Platform</th><br>            <th>MPI Shared Memory Bandwidth(GB/sec) </th><br>            <th>Pthreads Worst Case Memory-to-CPU Bandwidth (GB/sec) </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>AMD 2.4 GHz Opteron </td><br>            <td>1.2</td><br>            <td>5.3</td><br>        </tr><br>        <tr><br>            <td>IBM 1.9 GHz POWER5 p5-575</td><br>            <td>4.1</td><br>            <td>16</td><br>        </tr><br>        <tr><br>            <td>IBM 1.5 GHz POWER4 </td><br>            <td>2.1</td><br>            <td>4</td><br>        </tr><br>        <tr><br>            <td>Intel 1.4 GHz Xeon </td><br>            <td>0.3</td><br>            <td>4.3</td><br>        </tr><br>        <tr><br>            <td>Intel 1.4 GHz Itanium 2</td><br>            <td>1.8</td><br>            <td>6.4</td><br>        </tr><br>    </tbody><br></table>

<hr>
<h4 id="3-4-使用线程设计程序"><a href="#3-4-使用线程设计程序" class="headerlink" title=" 3.4 使用线程设计程序"></a><a id="3.4"></a> 3.4 使用线程设计程序</h4><h5 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程:"></a>并行编程:</h5><p>在现代多CPU机器上，pthread非常适于并行编程。可以用于并行程序设计的，也可以用于pthread程序设计。 </p>
<p>并行程序要考虑许多，如下： </p>
<ul>
<li>用什么并行程序设计模型？ </li>
<li>问题划分 </li>
<li>加载平衡（Load balancing） </li>
<li>通信 </li>
<li>数据依赖 </li>
<li>同步和竞争条件 </li>
<li>内存问题 </li>
<li>I/O问题 </li>
<li>程序复杂度 </li>
<li>程序员的努力/花费/时间 </li>
<li>…  </li>
</ul>
<p>包含这些主题超出本教程的范围，有兴趣的读者可以快速浏览下“Introduction to Parallel Computing”教程。 </p>
<p>大体上，为了使用Pthreads的优点，必须将任务组织程离散的，独立的，可以并发执行的。例如，如果routine1和routine2可以互换，相互交叉和（或者）重叠，他们就可以线程化。 </p>
<p>拥有下述特性的程序可以使用pthreads： </p>
<ul>
<li>工作可以被多个任务同时执行，或者数据可以同时被多个任务操作。 </li>
<li>阻塞与潜在的长时间I/O等待。 </li>
<li>在某些地方使用很多CPU循环而其他地方没有。 </li>
<li>对异步事件必须响应。 </li>
<li>一些工作比其他的重要（优先级中断）。 </li>
</ul>
<p>Pthreads 也可以用于串行程序，模拟并行执行。很好例子就是经典的web浏览器，对于多数人，运行于单CPU的桌面/膝上机器，许多东西可以同时“显示”出来。 </p>
<p>使用线程编程的几种常见模型： </p>
<ul>
<li><p><strong>管理者/工作者（Manager/worker）</strong>：一个单线程，作为管理器将工作分配给其它线程（工作者），典型的，管理器处理所有输入和分配工作给其它任务。至少两种形式的manager/worker模型比较常用：静态worker池和动态worker池。 </p>
</li>
<li><p><strong>管道（Pipeline）</strong>：任务可以被划分为一系列子操作，每一个被串行处理，但是不同的线程并发处理。汽车装配线可以很好的描述这个模型。 </p>
</li>
<li><p><strong>Peer</strong>: 和manager/worker模型相似，但是主线程在创建了其它线程后，自己也参与工作。 </p>
</li>
</ul>
<h5 id="共享内存模型（Shared-Memory-Model）"><a href="#共享内存模型（Shared-Memory-Model）" class="headerlink" title="共享内存模型（Shared Memory Model）:"></a>共享内存模型（Shared Memory Model）:</h5><p>所有线程可以访问全局，共享内存 </p>
<p>线程也有自己私有的数据 </p>
<p>程序员负责对全局共享数据的同步存取（保护） </p>
<h5 id="线程安全（Thread-safeness）"><a href="#线程安全（Thread-safeness）" class="headerlink" title="线程安全（Thread-safeness）:"></a>线程安全（Thread-safeness）:</h5><p>线程安全：简短的说，指程序可以同时执行多个线程却不会“破坏“共享数据或者产生“竞争”条件的能力。 </p>
<p>例如：假设你的程序创建了几个线程，每一个调用相同的库函数： </p>
<ul>
<li>这个库函数存取/修改了一个全局结构或内存中的位置。 </li>
<li>当每个线程调用这个函数时，可能同时去修改这个全局结构活内存位置。 </li>
<li>如果函数没有使用同步机制去阻止数据破坏，这时，就不是线程安全的了。 </li>
</ul>
<p>如果你不是100%确定外部库函数是线程安全的，自己负责所可能引发的问题。 </p>
<p>建议：小心使用库或者对象，当不能明确确定是否是线程安全的。若有疑虑，假设其不是线程安全的直到得以证明。可以通过不断地使用不确定的函数找出问题所在。 </p>
<hr>
<h3 id="4-编译多线程程序"><a href="#4-编译多线程程序" class="headerlink" title=" 4. 编译多线程程序"></a><a id="4"></a> 4. 编译多线程程序</h3><p>下表列出了一些编译使用了pthreads库程序的命令： </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th>Compiler/Platform</th><br>            <th>Compiler Command</th><br>            <th>Description</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td rowspan="3">IBM AIX</td><br>            <td>xlc_r / cc_r </td><br>            <td>C (ANSI  /  non-ANSI) </td><br>        </tr><br>        <tr><br>            <td>xlC_r </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td>xlf_r -qnosave, xlf90_r -qnosave </td><br>            <td>Fortran - using IBM’s Pthreads API (non-portable) </td><br>        </tr><br>        <tr><br>            <td rowspan="2">INTEL Linux </td><br>            <td>icc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>icpc -pthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">PathScale Linux  </td><br>            <td>pathcc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>pathCC -pthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">PGI Linux </td><br>            <td>pgcc -lpthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>pgCC -lpthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">GNU Linux, AIX </td><br>            <td>gcc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>g++ -pthread </td><br>            <td>C++</td><br>        </tr><br>    </tbody><br></table>

<hr>
<h3 id="5-线程管理（Thread-Management）"><a href="#5-线程管理（Thread-Management）" class="headerlink" title=" 5. 线程管理（Thread Management）"></a><a id="5"></a> 5. 线程管理（Thread Management）</h3><h4 id="5-1-创建和结束线程"><a href="#5-1-创建和结束线程" class="headerlink" title=" 5.1 创建和结束线程"></a><a id="5.1"></a> 5.1 创建和结束线程</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_create (thread,attr,start_routine,arg)  
pthread_exit (status)  
pthread_attr_init (attr)  
pthread_attr_destroy (attr)  
</code></pre><p><strong>创建线程</strong>:  </p>
<p>最初，main函数包含了一个缺省的线程。其它线程则需要程序员显式地创建。 </p>
<p>pthread_create 创建一个新线程并使之运行起来。该函数可以在程序的任何地方调用。 </p>
<p>pthread_create参数： </p>
<pre><code>thread：返回一个不透明的，唯一的新线程标识符。 
attr：不透明的线程属性对象。可以指定一个线程属性对象，或者NULL为缺省值。 
start_routine：线程将会执行一次的C函数。 
arg: 传递给start_routine单个参数，传递时必须转换成指向void的指针类型。没有参数传递时，可设置为NULL。 
</code></pre><p>一个进程可以创建的线程最大数量取决于系统实现。 </p>
<p>一旦创建，线程就称为peers，可以创建其它线程。线程之间没有指定的结构和依赖关系。 </p>
<p>Q：一个线程被创建后，怎么知道操作系统何时调度该线程使之运行？ </p>
<p>A：除非使用了Pthreads的调度机制，否则线程何时何地被执行取决于操作系统的实现。强壮的程序应该不依赖于线程执行的顺序。</p>
<p><strong>线程属性</strong>:</p>
<p>线程被创建时会带有默认的属性。其中的一些属性可以被程序员用线程属性对象来修改。 </p>
<p>pthread_attr_init 和 pthread_attr_destroy用于初始化/销毁先成属性对象。 </p>
<p>其它的一些函数用于查询和设置线程属性对象的指定属性。 </p>
<p>一些属性下面将会讨论。 </p>
<p><strong>结束终止</strong>:  </p>
<p>结束线程的方法有一下几种： </p>
<ul>
<li>线程从主线程（main函数的初始线程）返回。 </li>
<li>线程调用了pthread_exit函数。 </li>
<li>其它线程使用 pthread_cancel函数结束线程。 </li>
<li>调用exec或者exit函数，整个进程结束。 </li>
</ul>
<p>pthread_exit用于显式退出线程。典型地，pthread_exit()函数在线程完成工作时，不在需要时候被调用，退出线程。 </p>
<p>如果main()在其他线程创建前用pthread_exit()退出了，其他线程将会继续执行。否则，他们会随着main的结束而终止。 </p>
<p>程序员可以可选择的指定终止状态，当任何线程连接（join）该线程时，该状态就返回给连接（join）该线程的线程。 </p>
<p>清理：pthread_exit()函数并不会关闭文件，任何在线程中打开的文件将会一直处于打开状态，知道线程结束。 </p>
<p>讨论：对于正常退出，可以免于调用pthread_exit()。当然，除非你想返回一个返回值。然而，在main中，有一个问题，就是当main结束时，其它线程还没有被创建。如果此时没有显式的调用pthread_exit()，当main结束时，进程（和所有线程）都会终止。可以在main中调用pthread_exit()，此时尽管在main中已经没有可执行的代码了，进程和所有线程将保持存活状态，。 </p>
<p><strong>例子: Pthread 创建和终止</strong></p>
<p>该例用pthread_create()创建了5个线程。每一个线程都会打印一条“Hello World”的消息，然后调用pthread_exit()终止线程。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NUM_THREADS     5 </div><div class="line"> </div><div class="line">void *PrintHello(void *threadid) </div><div class="line">&#123; </div><div class="line">   int tid; </div><div class="line">   tid = (int)threadid; </div><div class="line">   printf(&quot;Hello World! It&apos;s me, thread #%d!/n&quot;, tid); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t threads[NUM_THREADS]; </div><div class="line">   int rc, t; </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++)&#123; </div><div class="line">      printf(&quot;In main: creating thread %d/n&quot;, t); </div><div class="line">      rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t); </div><div class="line">      if (rc)&#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create() is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-2-向线程传递参数"><a href="#5-2-向线程传递参数" class="headerlink" title=" 5.2 向线程传递参数"></a><a id="5.2"></a> 5.2 向线程传递参数</h4><p>pthread_create()函数允许程序员想线程的start routine传递一个参数。当多个参数需要被传递时，可以通过定义一个结构体包含所有要传的参数，然后用pthread_create()传递一个指向改结构体的指针，来打破传递参数的个数的限制。<br>所有参数都应该传引用传递并转化成（void*）。 </p>
<pre><code>Q：怎样安全地向一个新创建的线程传递数据？ 
A：确保所传递的数据是线程安全的（不能被其他线程修改）。下面三个例子演示了那个应该和那个不应该。 
</code></pre><p>Example 1 - Thread Argument Passing  </p>
<p>下面的代码片段演示了如何向一个线程传递一个简单的整数。主线程为每一个线程使用一个唯一的数据结构，确保每个线程传递的参数是完整的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int *taskids[NUM_THREADS]; </div><div class="line"> </div><div class="line">for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">&#123; </div><div class="line">   taskids[t] = (int *) malloc(sizeof(int)); </div><div class="line">   *taskids[t] = t; </div><div class="line">   printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) taskids[t]); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example 2 - Thread Argument Passing  </p>
<p>例子展示了用结构体向线程设置/传递参数。每个线程获得一个唯一的结构体实例。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct thread_data&#123; </div><div class="line">   int  thread_id; </div><div class="line">   int  sum; </div><div class="line">   char *message; </div><div class="line">&#125;; </div><div class="line"> </div><div class="line">struct thread_data thread_data_array[NUM_THREADS]; </div><div class="line"> </div><div class="line">void *PrintHello(void *threadarg) </div><div class="line">&#123; </div><div class="line">   struct thread_data *my_data; </div><div class="line">   ... </div><div class="line">   my_data = (struct thread_data *) threadarg; </div><div class="line">   taskid = my_data-&gt;thread_id; </div><div class="line">   sum = my_data-&gt;sum; </div><div class="line">   hello_msg = my_data-&gt;message; </div><div class="line">   ... </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   ... </div><div class="line">   thread_data_array[t].thread_id = t; </div><div class="line">   thread_data_array[t].sum = sum; </div><div class="line">   thread_data_array[t].message = messages[t]; </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) &amp;thread_data_array[t]); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example 3 - Thread Argument Passing (Incorrect)  </p>
<p>例子演示了错误地传递参数。循环会在线程访问传递的参数前改变传递给线程的地址的内容。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int rc, t; </div><div class="line"> </div><div class="line">for(t=0; t&lt;NUM_THREADS; t++)  </div><div class="line">&#123; </div><div class="line">   printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) &amp;t); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-3-连接（Joining）和分离（Detaching）线程"><a href="#5-3-连接（Joining）和分离（Detaching）线程" class="headerlink" title=" 5.3 连接（Joining）和分离（Detaching）线程"></a><a id="5.3"></a> 5.3 连接（Joining）和分离（Detaching）线程</h4><p><strong>函数</strong>:  </p>
<pre><code>pthread_detach (threadid,status)  
pthread_attr_setdetachstate (attr,detachstate)  
pthread_attr_getdetachstate (attr,detachstate)  
pthread_join (threadid,status)  
</code></pre><p><strong>连接</strong>: </p>
<p>“连接”是一种在线程间完成同步的方法。例如： </p>
<p>pthread_join()函数阻赛调用线程知道threadid所指定的线程终止。 </p>
<p>如果在目标线程中调用pthread_exit()，程序员可以在主线程中获得目标线程的终止状态。 </p>
<p>连接线程只能用pthread_join()连接一次。若多次调用就会发生逻辑错误。 </p>
<p>两种同步方法，互斥量（mutexes）和条件变量（condition variables），稍后讨论。 </p>
<p>可连接（Joinable or Not）?  </p>
<p>当一个线程被创建，它有一个属性定义了它是可连接的（joinable）还是分离的（detached）。只有是可连接的线程才能被连接（joined），若果创建的线程是分离的，则不能连接。 </p>
<p>POSIX标准的最终草案指定了线程必须创建成可连接的。然而，并非所有实现都遵循此约定。 </p>
<p>使用pthread_create()的attr参数可以显式的创建可连接或分离的线程，典型四步如下： </p>
<ul>
<li>声明一个pthread_attr_t数据类型的线程属性变量 </li>
<li>用pthread_attr_init()初始化改属性变量 </li>
<li>用pthread_attr_setdetachstate()设置可分离状态属性 </li>
<li>完了后，用pthread_attr_destroy()释放属性所占用的库资源 </li>
</ul>
<p><strong>分离（Detaching）</strong>：</p>
<p>pthread_detach()可以显式用于分离线程，尽管创建时是可连接的。<br>没<br>有与pthread_detach()功能相反的函数 </p>
<p><strong>建议</strong>：</p>
<ul>
<li>若线程需要连接，考虑创建时显式设置为可连接的。因为并非所有创建线程的实现都是将线程创建为可连接的。 </li>
<li>若事先知道线程从不需要连接，考虑创建线程时将其设置为可分离状态。一些系统资源可能需要释放。 </li>
</ul>
<p><strong>例子: Pthread Joining</strong></p>
<p>Example Code - Pthread Joining  </p>
<p>这个例子演示了用Pthread join函数去等待线程终止。因为有些实现并不是默认创建线程是可连接状态，例子中显式地将其创建为可连接的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NUM_THREADS    3 </div><div class="line"> </div><div class="line">void *BusyWork(void *null) </div><div class="line">&#123; </div><div class="line">   int i; </div><div class="line">   double result=0.0; </div><div class="line">   for (i=0; i&lt;1000000; i++) </div><div class="line">   &#123; </div><div class="line">     result = result + (double)random(); </div><div class="line">   &#125; </div><div class="line">   printf(&quot;result = %e/n&quot;,result); </div><div class="line">   pthread_exit((void *) 0); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t thread[NUM_THREADS]; </div><div class="line">   pthread_attr_t attr; </div><div class="line">   int rc, t; </div><div class="line">   void *status; </div><div class="line"> </div><div class="line">   /* Initialize and set thread detached attribute */ </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line"> </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">   &#123; </div><div class="line">      printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">      rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, NULL);  </div><div class="line">      if (rc) </div><div class="line">      &#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create()  </div><div class="line">                is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   /* Free attribute and wait for the other threads */ </div><div class="line">   pthread_attr_destroy(&amp;attr); </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">   &#123; </div><div class="line">      rc = pthread_join(thread[t], &amp;status); </div><div class="line">      if (rc) </div><div class="line">      &#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_join()  </div><div class="line">                is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">      printf(&quot;Completed join with thread %d status= %ld/n&quot;,t, (long)status); </div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-4-栈管理"><a href="#5-4-栈管理" class="headerlink" title=" 5.4 栈管理"></a><a id="5.4"></a> 5.4 栈管理</h4><p><strong>函数</strong>:  </p>
<pre><code>pthread_attr_getstacksize (attr, stacksize)  
pthread_attr_setstacksize (attr, stacksize)  
pthread_attr_getstackaddr (attr, stackaddr)  
pthread_attr_setstackaddr (attr, stackaddr)  
</code></pre><p><strong>防止栈问题</strong>:</p>
<p>POSIX标准并没有指定线程栈的大小，依赖于实现并随实现变化。 </p>
<p>很容易超出默认的栈大小，常见结果：程序终止或者数据损坏。 </p>
<p>安全和可移植的程序应该不依赖于默认的栈限制，但是取而代之的是用pthread_attr_setstacksize分配足够的栈大小。 </p>
<p>pthread_attr_getstackaddr和pthread_attr_setstackaddr函数可以被程序用于将栈设置在指定的内存区域。 </p>
<p>在LC上的一些实际例子:  </p>
<p>默认栈大小经常变化很大，最大值也变化很大，可能会依赖于每个节点的线程数目。 </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th> Node Architecture</th><br>            <th> #CPUS </th><br>            <th> Memory(GB) </th><br>            <th> Default Size (bytes) </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td> AMD Opteron </td><br>            <td> 8 </td><br>            <td> 16 </td><br>            <td> 2,097,152 </td><br>        </tr><br>        <tr><br>            <td> Intel IA64 </td><br>            <td> 4 </td><br>            <td> 8 </td><br>            <td> 33,554,432 </td><br>        </tr><br>        <tr><br>            <td> Intel IA32 </td><br>            <td> 2 </td><br>            <td> 4 </td><br>            <td> 2,097,152 </td><br>        </tr><br>        <tr><br>            <td> IBM Power5 </td><br>            <td> 8 </td><br>            <td> 32 </td><br>            <td> 196,608</td><br>        </tr><br>        <tr><br>            <td> IBM Power4 </td><br>            <td> 8 </td><br>            <td> 16 </td><br>            <td> 196,608</td><br>        </tr><br>        <tr><br>            <td> IBM Power3 </td><br>            <td> 16 </td><br>            <td> 32 </td><br>            <td> 98,304 </td><br>        </tr><br>    </tbody><br></table>


<p><strong>例子: 栈管理</strong></p>
<p>Example Code - Stack Management  </p>
<p>这个例子演示了如何去查询和设定线程栈大小。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NTHREADS 4 </div><div class="line">#define N 1000 </div><div class="line">#define MEGEXTRA 1000000 </div><div class="line">  </div><div class="line">pthread_attr_t attr; </div><div class="line">  </div><div class="line">void *dowork(void *threadid) </div><div class="line">&#123; </div><div class="line">   double A[N][N]; </div><div class="line">   int i,j,tid; </div><div class="line">   size_t mystacksize; </div><div class="line"> </div><div class="line">   tid = (int)threadid; </div><div class="line">   pthread_attr_getstacksize (&amp;attr, &amp;mystacksize); </div><div class="line">   printf(&quot;Thread %d: stack size = %li bytes /n&quot;, tid, mystacksize); </div><div class="line">   for (i=0; i&lt;N; i++) </div><div class="line">     for (j=0; j&lt;N; j++) </div><div class="line">      A[i][j] = ((i*j)/3.452) + (N-i); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line">  </div><div class="line">int main(int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t threads[NTHREADS]; </div><div class="line">   size_t stacksize; </div><div class="line">   int rc, t; </div><div class="line">  </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_getstacksize (&amp;attr, &amp;stacksize); </div><div class="line">   printf(&quot;Default stack size = %li/n&quot;, stacksize); </div><div class="line">   stacksize = sizeof(double)*N*N+MEGEXTRA; </div><div class="line">   printf(&quot;Amount of stack needed per thread = %li/n&quot;,stacksize); </div><div class="line">   pthread_attr_setstacksize (&amp;attr, stacksize); </div><div class="line">   printf(&quot;Creating threads with stack size = %li bytes/n&quot;,stacksize); </div><div class="line">   for(t=0; t&lt;NTHREADS; t++)&#123; </div><div class="line">      rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (void *)t); </div><div class="line">      if (rc)&#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create() is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line">   printf(&quot;Created %d threads./n&quot;, t); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-5-其他各种函数"><a href="#5-5-其他各种函数" class="headerlink" title=" 5.5 其他各种函数"></a><a id="5.5"></a> 5.5 其他各种函数</h4><pre><code>pthread_self ()  
pthread_equal (thread1,thread2)  
</code></pre><p>pthread_self返回调用该函数的线程的唯一，系统分配的线程ID。 </p>
<p>pthread_equal比较两个线程ID,若不同返回0，否则返回非0值。 </p>
<p>注意这两个函数中的线程ID对象是不透明的，不是轻易能检查的。因为线程ID是不透明的对象，所以C语言的==操作符不能用于比较两个线程ID。 </p>
<pre><code>pthread_once (once_control, init_routine)  
</code></pre><p>pthread_once 在一个进程中仅执行一次init_routine。任何线程第一次调用该函数会执行给定的init_routine，不带参数，任何后续调用都没有效果。 </p>
<p>init_routine函数一般是初始化的程序 </p>
<p>once_control参数是一个同步结构体，需要在调用pthread_once前初始化。例如： </p>
<pre><code>pthread_once_t once_control = PTHREAD_ONCE_INIT;  
</code></pre><hr>
<h3 id="6-互斥量（Mutex-Variables）"><a href="#6-互斥量（Mutex-Variables）" class="headerlink" title=" 6. 互斥量（Mutex Variables）"></a><a id="6"></a> 6. 互斥量（Mutex Variables）</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title=" 6.1 概述"></a><a id="6.1"></a> 6.1 概述</h4><p>互斥量（Mutex）是“mutual exclusion”的缩写。互斥量是实现线程同步，和保护同时写共享数据的主要方法 </p>
<p>互斥量对共享数据的保护就像一把锁。在Pthreads中，任何时候仅有一个线程可以锁定互斥量，因此，当多个线程尝试去锁定该互斥量时仅有一个会成功。直到锁定互斥量的线程解锁互斥量后，其他线程才可以去锁定互斥量。线程必须轮着访问受保护数据。 </p>
<p>互斥量可以防止“竞争”条件。下面的例子是一个银行事务处理时发生了竞争条件：</p>
<table class="table talbe.stripped"><br>    <thead><br>        <tr><br>            <th> Thread 1 </th><br>            <th> Thread 2 </th><br>            <th> Balance </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Read balance: $1000 </td><br>            <td></td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Read balance: $1000 </td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Deposit $200 </td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td>Deposit $200</td><br>            <td></td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td>Update balance $1000+$200 </td><br>            <td></td><br>            <td>$1200</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Update balance $1000+$200 </td><br>            <td>$1200</td><br>        </tr><br>    </tbody><br></table>

<p>上面的例子，当一个线程使用共享数据资源时，应该用一个互斥量去锁定“Balance”。 </p>
<p>一个拥有互斥量的线程经常用于更新全局变量。确保了多个线程更新同样的变量以安全的方式运行，最终的结果和一个线程处理的结果是相同的。这个更新的变量属于一个“临界区（critical section）”。 </p>
<p>使用互斥量的典型顺序如下： </p>
<ul>
<li>创建和初始一个互斥量 </li>
<li>多个线程尝试去锁定该互斥量 </li>
<li>仅有一个线程可以成功锁定改互斥量 </li>
<li>锁定成功的线程做一些处理 </li>
<li>线程解锁该互斥量 </li>
<li>另外一个线程获得互斥量，重复上述过程 </li>
<li>最后销毁互斥量 </li>
</ul>
<p>当多个线程竞争同一个互斥量时，失败的线程会阻塞在lock调用处。可以用“trylock”替换“lock”，则失败时不会阻塞。 </p>
<p>当保护共享数据时，程序员有责任去确认是否需要使用互斥量。如，若四个线程会更新同样的数据，但仅有一个线程用了互斥量，则数据可能会损坏。 </p>
<hr>
<h4 id="6-2-创建和销毁互斥量"><a href="#6-2-创建和销毁互斥量" class="headerlink" title=" 6.2 创建和销毁互斥量"></a><a id="6.2"></a> 6.2 创建和销毁互斥量</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_mutex_init (mutex,attr)  
pthread_mutex_destroy (mutex)  
pthread_mutexattr_init (attr)  
pthread_mutexattr_destroy (attr)  
</code></pre><p><strong>用法</strong>：</p>
<p>互斥量必须用类型pthread_mutex_t类型声明，在使用前必须初始化，这里有两种方法可以初始化互斥量： </p>
<p>声明时静态地，如：<br>    pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;  </p>
<p>动态地用pthread_mutex_init()函数，这种方法允许设定互斥量的属性对象attr。 </p>
<p>互斥量初始化后是解锁的。 </p>
<p>attr对象用于设置互斥量对象的属性，使用时必须声明为pthread_mutextattr_t类型，默认值可以是NULL。Pthreads标准定义了三种可选的互斥量属性： </p>
<ul>
<li>协议（Protocol）： 指定了协议用于阻止互斥量的优先级改变 </li>
<li>优先级上限（Prioceiling）：指定互斥量的优先级上限 </li>
<li>进程共享（Process-shared）：指定进程共享互斥量 </li>
</ul>
<p>注意所有实现都提供了这三个可先的互斥量属性。 </p>
<p>pthread_mutexattr_init()和pthread_mutexattr_destroy()函数分别用于创建和销毁互斥量属性对象。 </p>
<p>pthread_mutex_destroy()应该用于释放不需要再使用的互斥量对象。 </p>
<hr>
<h4 id="6-3-锁定和解锁互斥量"><a href="#6-3-锁定和解锁互斥量" class="headerlink" title=" 6.3 锁定和解锁互斥量"></a><a id="6.3"></a> 6.3 锁定和解锁互斥量</h4><p><strong>函数</strong>：  </p>
<pre><code>pthread_mutex_lock (mutex)  
pthread_mutex_trylock (mutex)  
pthread_mutex_unlock (mutex)  
</code></pre><p><strong>用法</strong>：</p>
<p>线程用pthread_mutex_lock()函数去锁定指定的mutex变量，若该mutex已经被另外一个线程锁定了，该调用将会阻塞线程直到mutex被解锁。 </p>
<p>pthread_mutex_trylock() will attempt to lock a mutex. However, if the mutex is already locked, the routine will return immediately with a “busy” error code. This routine may be useful in  </p>
<p>pthread_mutex_trylock()</p>
<p>尝试着去锁定一个互斥量，然而，若互斥量已被锁定，程序会立刻返回并返回一个忙错误值。该函数在优先级改变情况下阻止死锁是非常有用的。 </p>
<p>线程可以用pthread_mutex_unlock()解锁自己占用的互斥量。在一个线程完成对保护数据的使用，而其它线程要获得互斥量在保护数据上工作时，可以调用该函数。若有一下情形则会发生错误： </p>
<ul>
<li>互斥量已经被解锁 </li>
<li>互斥量被另一个线程占用 </li>
</ul>
<p>互斥量并没有多么“神奇”的，实际上，它们就是参与的线程的“君子约定”。写代码时要确信正确地锁定，解锁互斥量。下面演示了一种逻辑错误： </p>
<pre><code>·                    Thread 1     Thread 2     Thread 3 
·                    Lock         Lock          
·                    A = 2        A = A+1      A = A*B 
·                    Unlock       Unlock     
</code></pre><p>Q：有多个线程等待同一个锁定的互斥量，当互斥量被解锁后，那个线程会第一个锁定互斥量？ </p>
<p>A：除非线程使用了优先级调度机制，否则，线程会被系统调度器去分配，那个线程会第一个锁定互斥量是随机的。 </p>
<p><strong>例子：使用互斥量</strong></p>
<p>Example Code - Using Mutexes  </p>
<p>例程演示了线程使用互斥量处理一个点积（dot product）计算。主数据通过一个可全局访问的数据结构被所有线程使用，每个线程处理数据的不同部分，主线程等待其他线程完成计算并输出结果。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#include &lt;malloc.h&gt; </div><div class="line"> </div><div class="line">/*    </div><div class="line">The following structure contains the necessary information   </div><div class="line">to allow the function &quot;dotprod&quot; to access its input data and  </div><div class="line">place its output into the structure.   </div><div class="line">*/ </div><div class="line"> </div><div class="line">typedef struct  </div><div class="line"> &#123; </div><div class="line">   double      *a; </div><div class="line">   double      *b; </div><div class="line">   double     sum;  </div><div class="line">   int     veclen;  </div><div class="line"> &#125; DOTDATA; </div><div class="line"> </div><div class="line">/* Define globally accessible variables and a mutex */ </div><div class="line"> </div><div class="line">#define NUMTHRDS 4 </div><div class="line">#define VECLEN 100 </div><div class="line">   DOTDATA dotstr;  </div><div class="line">   pthread_t callThd[NUMTHRDS]; </div><div class="line">   pthread_mutex_t mutexsum; </div><div class="line"> </div><div class="line">/* </div><div class="line">The function dotprod is activated when the thread is created. </div><div class="line">All input to this routine is obtained from a structure  </div><div class="line">of type DOTDATA and all output from this function is written into </div><div class="line">this structure. The benefit of this approach is apparent for the  </div><div class="line">multi-threaded program: when a thread is created we pass a single </div><div class="line">argument to the activated function - typically this argument </div><div class="line">is a thread number. All  the other information required by the  </div><div class="line">function is accessed from the globally accessible structure.  </div><div class="line">*/ </div><div class="line"> </div><div class="line">void *dotprod(void *arg) </div><div class="line">&#123; </div><div class="line"> </div><div class="line">   /* Define and use local variables for convenience */ </div><div class="line"> </div><div class="line">   int i, start, end, offset, len ; </div><div class="line">   double mysum, *x, *y; </div><div class="line">   offset = (int)arg; </div><div class="line">      </div><div class="line">   len = dotstr.veclen; </div><div class="line">   start = offset*len; </div><div class="line">   end   = start + len; </div><div class="line">   x = dotstr.a; </div><div class="line">   y = dotstr.b; </div><div class="line"> </div><div class="line">   /* </div><div class="line">   Perform the dot product and assign result </div><div class="line">   to the appropriate variable in the structure.  </div><div class="line">   */ </div><div class="line"> </div><div class="line">   mysum = 0; </div><div class="line">   for (i=start; i&lt;end ; i++)  </div><div class="line">    &#123; </div><div class="line">      mysum += (x[i] * y[i]); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">   /* </div><div class="line">   Lock a mutex prior to updating the value in the shared </div><div class="line">   structure, and unlock it upon updating. </div><div class="line">   */ </div><div class="line">   pthread_mutex_lock (&amp;mutexsum); </div><div class="line">   dotstr.sum += mysum; </div><div class="line">   pthread_mutex_unlock (&amp;mutexsum); </div><div class="line"> </div><div class="line">   pthread_exit((void*) 0); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">/*  </div><div class="line">The main program creates threads which do all the work and then  </div><div class="line">print out result upon completion. Before creating the threads, </div><div class="line">the input data is created. Since all threads update a shared structure,  </div><div class="line">we need a mutex for mutual exclusion. The main thread needs to wait for </div><div class="line">all threads to complete, it waits for each one of the threads. We specify </div><div class="line">a thread attribute value that allow the main thread to join with the </div><div class="line">threads it creates. Note also that we free up handles when they are </div><div class="line">no longer needed. </div><div class="line">*/ </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   int i; </div><div class="line">   double *a, *b; </div><div class="line">   void *status; </div><div class="line">   pthread_attr_t attr; </div><div class="line"> </div><div class="line">   /* Assign storage and initialize values */ </div><div class="line">   a = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); </div><div class="line">   b = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); </div><div class="line">   </div><div class="line">   for (i=0; i&lt;VECLEN*NUMTHRDS; i++) </div><div class="line">    &#123; </div><div class="line">     a[i]=1.0; </div><div class="line">     b[i]=a[i]; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">   dotstr.veclen = VECLEN;  </div><div class="line">   dotstr.a = a;  </div><div class="line">   dotstr.b = b;  </div><div class="line">   dotstr.sum=0; </div><div class="line"> </div><div class="line">   pthread_mutex_init(&amp;mutexsum, NULL); </div><div class="line">          </div><div class="line">   /* Create threads to perform the dotproduct  */ </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line"> </div><div class="line">        for(i=0; i&lt;NUMTHRDS; i++) </div><div class="line">        &#123; </div><div class="line">        /*  </div><div class="line">        Each thread works on a different set of data. </div><div class="line">        The offset is specified by &apos;i&apos;. The size of </div><div class="line">        the data for each thread is indicated by VECLEN. </div><div class="line">        */ </div><div class="line">        pthread_create( &amp;callThd[i], &amp;attr, dotprod, (void *)i); </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">        pthread_attr_destroy(&amp;attr); </div><div class="line"> </div><div class="line">        /* Wait on the other threads */ </div><div class="line">        for(i=0; i&lt;NUMTHRDS; i++) </div><div class="line">        &#123; </div><div class="line">          pthread_join( callThd[i], &amp;status); </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">   /* After joining, print out the results and cleanup */ </div><div class="line">   printf (&quot;Sum =  %f /n&quot;, dotstr.sum); </div><div class="line">   free (a); </div><div class="line">   free (b); </div><div class="line">   pthread_mutex_destroy(&amp;mutexsum); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="7-条件变量（Condition-Variables）"><a href="#7-条件变量（Condition-Variables）" class="headerlink" title=" 7. 条件变量（Condition Variables）"></a><a id="7"></a> 7. 条件变量（Condition Variables）</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title=" 7.1 概述"></a><a id="7.1"></a> 7.1 概述</h4><p>条件变量提供了另一种同步的方式。互斥量通过控制对数据的访问实现了同步，而条件变量允许根据实际的数据值来实现同步。 </p>
<p>没有条件变量，程序员就必须使用线程去轮询（可能在临界区），查看条件是否满足。这样比较消耗资源，因为线程连续繁忙工作。条件变量是一种可以实现这种轮询的方式。 </p>
<p>条件变量往往和互斥一起使用 </p>
<p>使用条件变量的代表性顺序如下： </p>
<pre><code>主线程（Main Thread）  
o                                声明和初始化需要同步的全局数据/变量（如“count”） 
o                                生命和初始化一个条件变量对象 
o                                声明和初始化一个相关的互斥量 
o                                创建工作线程A和B 

Thread A  
o                                工作，一直到一定的条件满足（如“count”等于一个指定的值） 
o                                锁定相关互斥量并检查全局变量的值 
o                                调用pthread_cond_wait()阻塞等待Thread-B的信号。注意pthread_cond_wait()能够自动地并且原子地解锁相关的互斥量，以至于它可以被Thread-B使用。 
o                                当收到信号，唤醒线程，互斥量被自动，原子地锁定。 
o                                显式解锁互斥量 
o                                继续 
Thread B  
o                                工作 
o                                锁定相关互斥量 
o                                改变Thread-A所等待的全局变量 
o                                检查全局变量的值，若达到需要的条件，像Thread-A发信号。 
o                                解锁互斥量 
o                                继续 

Main Thread  
Join / Continue  
</code></pre><hr>
<h4 id="7-2-创建和销毁条件变量"><a href="#7-2-创建和销毁条件变量" class="headerlink" title=" 7.2 创建和销毁条件变量"></a><a id="7.2"></a> 7.2 创建和销毁条件变量</h4><p><strong>Routines</strong>:  </p>
<pre><code>pthread_cond_init (condition,attr)  
pthread_cond_destroy (condition)  
pthread_condattr_init (attr)  
pthread_condattr_destroy (attr)  
</code></pre><p><strong>Usage</strong>:  </p>
<p>条件变量必须声明为pthread_cond_t类型，必须在使用前初始化。有两种方式可以初始条件变量： </p>
<p>声明时静态地。如：</p>
<pre><code>pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER;  
</code></pre><p>用pthread_cond_init()函数动态地。创建的条件变量ID通过condition参数返回给调用线程。该方式允许设置条件变量对象的属性，attr。 </p>
<p>可选的attr对象用于设定条件变量的属性。仅有一个属性被定义：线程共享（process-shared），可以使条件变量被其它进程中的线程看到。若要使用属性对象，必须定义为pthread_condattr_t类型（可以指定为NULL设为默认）。 </p>
<p>注意所有实现都提供了线程共享属性。 </p>
<p>pthread_condattr_init()和pthread_condattr_destroy()用于创建和销毁条件变量属性对象。 </p>
<p>条件变量不需要再使用时，应用pthread_cond_destroy()释放条件变量。 </p>
<hr>
<h4 id="7-3-在条件变量上等待（Waiting）和发送信号（Signaling）"><a href="#7-3-在条件变量上等待（Waiting）和发送信号（Signaling）" class="headerlink" title=" 7.3 在条件变量上等待（Waiting）和发送信号（Signaling）"></a><a id="7.3"></a> 7.3 在条件变量上等待（Waiting）和发送信号（Signaling）</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_cond_wait (condition,mutex)  
pthread_cond_signal (condition)  
pthread_cond_broadcast (condition)  
</code></pre><p><strong>用法</strong>：</p>
<p>pthread_cond_wait()阻塞调用线程直到指定的条件受信（signaled）。该函数应该在互斥量锁定时调用，当在等待时会自动解锁互斥量。在信号被发送，线程被激活后，互斥量会自动被锁定，当线程结束时，由程序员负责解锁互斥量。 </p>
<p>pthread_cond_signal()函数用于向其他等待在条件变量上的线程发送信号（激活其它线程）。应该在互斥量被锁定后调用。 </p>
<p>若不止一个线程阻塞在条件变量上，则应用pthread_cond_broadcast()向其它所以线程发生信号。 </p>
<p>在调用pthread_cond_wait()前调用pthread_cond_signal()会发生逻辑错误。 </p>
<p>使用这些函数时适当的锁定和解锁相关的互斥量是非常重要的。如： </p>
<ul>
<li>调用pthread_cond_wait()前锁定互斥量失败可能导致线程不会阻塞。 </li>
<li>调用pthread_cond_signal()后解锁互斥量失败可能会不允许相应的pthread_cond_wait()函数结束（保存阻塞）。 </li>
</ul>
<p><strong>例子：使用条件变量 </strong></p>
<p>Example Code - Using Condition Variables  </p>
<p>例子演示了使用Pthreads条件变量的几个函数。主程序创建了三个线程，两个线程工作，根系“count”变量。第三个线程等待count变量值达到指定的值。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line"> </div><div class="line">#define NUM_THREADS  3 </div><div class="line">#define TCOUNT 10 </div><div class="line">#define COUNT_LIMIT 12 </div><div class="line"> </div><div class="line">int     count = 0; </div><div class="line">int     thread_ids[3] = &#123;0,1,2&#125;; </div><div class="line">pthread_mutex_t count_mutex; </div><div class="line">pthread_cond_t count_threshold_cv; </div><div class="line"> </div><div class="line">void *inc_count(void *idp)  </div><div class="line">&#123; </div><div class="line">  int j,i; </div><div class="line">  double result=0.0; </div><div class="line">  int *my_id = idp; </div><div class="line"> </div><div class="line">  for (i=0; i&lt;TCOUNT; i++) &#123; </div><div class="line">    pthread_mutex_lock(&amp;count_mutex); </div><div class="line">    count++; </div><div class="line"> </div><div class="line">    /*  </div><div class="line">    Check the value of count and signal waiting thread when condition is </div><div class="line">    reached.  Note that this occurs while mutex is locked.  </div><div class="line">    */ </div><div class="line">    if (count == COUNT_LIMIT) &#123; </div><div class="line">      pthread_cond_signal(&amp;count_threshold_cv); </div><div class="line">      printf(&quot;inc_count(): thread %d, count = %d  Threshold reached./n&quot;,  </div><div class="line">             *my_id, count); </div><div class="line">      &#125; </div><div class="line">    printf(&quot;inc_count(): thread %d, count = %d, unlocking mutex/n&quot;,  </div><div class="line">           *my_id, count); </div><div class="line">    pthread_mutex_unlock(&amp;count_mutex); </div><div class="line"> </div><div class="line">    /* Do some work so threads can alternate on mutex lock */ </div><div class="line">    for (j=0; j&lt;1000; j++) </div><div class="line">      result = result + (double)random(); </div><div class="line">    &#125; </div><div class="line">  pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">void *watch_count(void *idp)  </div><div class="line">&#123; </div><div class="line">  int *my_id = idp; </div><div class="line"> </div><div class="line">  printf(&quot;Starting watch_count(): thread %d/n&quot;, *my_id); </div><div class="line"> </div><div class="line">  /* </div><div class="line">  Lock mutex and wait for signal.  Note that the pthread_cond_wait  </div><div class="line">  routine will automatically and atomically unlock mutex while it waits.  </div><div class="line">  Also, note that if COUNT_LIMIT is reached before this routine is run by </div><div class="line">  the waiting thread, the loop will be skipped to prevent pthread_cond_wait </div><div class="line">  from never returning.  </div><div class="line">  */ </div><div class="line">  pthread_mutex_lock(&amp;count_mutex); </div><div class="line">  if (count&lt;COUNT_LIMIT) &#123; </div><div class="line">    pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex); </div><div class="line">    printf(&quot;watch_count(): thread %d Condition signal  </div><div class="line">           received./n&quot;, *my_id); </div><div class="line">    &#125; </div><div class="line">  pthread_mutex_unlock(&amp;count_mutex); </div><div class="line">  pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">  int i, rc; </div><div class="line">  pthread_t threads[3]; </div><div class="line">  pthread_attr_t attr; </div><div class="line"> </div><div class="line">  /* Initialize mutex and condition variable objects */ </div><div class="line">  pthread_mutex_init(&amp;count_mutex, NULL); </div><div class="line">  pthread_cond_init (&amp;count_threshold_cv, NULL); </div><div class="line"> </div><div class="line">  /* For portability, explicitly create threads in a joinable state */ </div><div class="line">  pthread_attr_init(&amp;attr); </div><div class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line">  pthread_create(&amp;threads[0], &amp;attr, inc_count, (void *)&amp;thread_ids[0]); </div><div class="line">  pthread_create(&amp;threads[1], &amp;attr, inc_count, (void *)&amp;thread_ids[1]); </div><div class="line">  pthread_create(&amp;threads[2], &amp;attr, watch_count, (void *)&amp;thread_ids[2]); </div><div class="line"> </div><div class="line">  /* Wait for all threads to complete */ </div><div class="line">  for (i=0; i&lt;NUM_THREADS; i++) &#123; </div><div class="line">    pthread_join(threads[i], NULL); </div><div class="line">  &#125; </div><div class="line">  printf (&quot;Main(): Waited on %d  threads. Done./n&quot;, NUM_THREADS); </div><div class="line"> </div><div class="line">  /* Clean up and exit */ </div><div class="line">  pthread_attr_destroy(&amp;attr); </div><div class="line">  pthread_mutex_destroy(&amp;count_mutex); </div><div class="line">  pthread_cond_destroy(&amp;count_threshold_cv); </div><div class="line">  pthread_exit(NULL); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="8-没有覆盖的主题"><a href="#8-没有覆盖的主题" class="headerlink" title=" 8. 没有覆盖的主题"></a><a id="8"></a> 8. 没有覆盖的主题</h3><p>Pthread API的几个特性在该教程中并没有包含。把它们列在下面： </p>
<ul>
<li>线程调度<br><strong> 线程如何调度的实现往往是不同的，在大多数情况下，默认的机制是可以胜任的。 
</strong> Pthreads　API提供了显式设定线程调度策略和优先级的函数，它们可以重载默认机制。 </li>
<li>API不需要实现去支持这些特性 </li>
<li>Keys：线程数据（TSD） </li>
<li>互斥量的Protocol属性和优先级管理 </li>
<li>跨进程的条件变量共享 </li>
<li>取消线程（Thread Cancellation ） </li>
<li>多线程和信号（Threads and Signals）  </li>
</ul>
<hr>
<h3 id="9-Pthread-库API参考"><a href="#9-Pthread-库API参考" class="headerlink" title=" 9. Pthread 库API参考"></a><a id="9"></a> 9. Pthread 库API参考</h3><p><strong>Pthread Functions</strong>:</p>
<ul>
<li><p>Thread Management  </p>
<p>  pthread_create<br>  pthread_exit<br>  pthread_join<br>  pthread_once<br>  pthread_kill<br>  pthread_self<br>  pthread_equal<br>  pthread_yield<br>  pthread_detach   </p>
</li>
<li><p>Thread-Specific Data </p>
<p>  pthread_key_create<br>  pthread_key_delete<br>  pthread_getspecific<br>  pthread_setspecific </p>
</li>
<li><p>Thread Cancellation<br><strong> pthread_cancel 
</strong> pthread_cleanup_pop<br><strong> pthread_cleanup_push 
</strong> pthread_setcancelstate<br><strong> pthread_getcancelstate  
</strong> pthread_testcancel </p>
</li>
<li><p>Thread Scheduling<br><strong> pthread_getschedparam 
</strong> pthread_setschedparam </p>
</li>
<li><p>Signals<br>** pthread_sigmask </p>
</li>
</ul>
<p><strong>Pthread Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management<br><strong> pthread_attr_init 
</strong> pthread_attr_destroy </p>
</li>
<li><p>Detachable or Joinable<br><strong> pthread_attr_setdetachstate 
</strong> pthread_attr_getdetachstate </p>
</li>
<li><p>Specifying Stack Information<br><strong> pthread_attr_getstackaddr 
</strong> pthread_attr_getstacksize<br><strong> pthread_attr_setstackaddr 
</strong> pthread_attr_setstacksize </p>
</li>
<li><p>Thread Scheduling Attributes<br><strong> pthread_attr_getschedparam 
</strong> pthread_attr_setschedparam<br><strong> pthread_attr_getschedpolicy 
</strong> pthread_attr_setschedpolicy<br><strong> pthread_attr_setinheritsched 
</strong> pthread_attr_getinheritsched<br><strong> pthread_attr_setscope 
</strong> pthread_attr_getscope </p>
</li>
</ul>
<p><strong>Mutex Functions</strong>:</p>
<ul>
<li><p>Mutex Management<br><strong> pthread_mutex_init 
</strong> pthread_mutex_destroy<br><strong> pthread_mutex_lock 
</strong> pthread_mutex_unlock<br>** pthread_mutex_trylock </p>
</li>
<li><p>Priority Management<br><strong> pthread_mutex_setprioceiling 
</strong> pthread_mutex_getprioceiling </p>
</li>
</ul>
<p><strong>Mutex Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management<br><strong> pthread_mutexattr_init 
</strong> pthread_mutexattr_destroy </p>
</li>
<li><p>Sharing<br><strong> pthread_mutexattr_getpshared 
</strong> pthread_mutexattr_setpshared </p>
</li>
<li><p>Protocol Attributes<br><strong> pthread_mutexattr_getprotocol 
</strong> pthread_mutexattr_setprotocol </p>
</li>
<li><p>Priority Management<br><strong> pthread_mutexattr_setprioceiling 
</strong> pthread_mutexattr_getprioceiling </p>
</li>
</ul>
<p><strong>Condition Variable Functions</strong>:</p>
<ul>
<li>Basic Management<br><strong> pthread_cond_init 
</strong> pthread_cond_destroy<br><strong> pthread_cond_signal 
</strong> pthread_cond_broadcast<br><strong> pthread_cond_wait 
</strong> pthread_cond_timedwait </li>
</ul>
<p><strong>Condition Variable Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management </p>
<p>  pthread_condattr_init<br>  pthread_condattr_destroy </p>
</li>
<li><p>Sharing </p>
<p>  pthread_condattr_getpshared<br>  pthread_condattr_setpshared </p>
</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title=" 参考资料"></a><a id="10"></a> 参考资料</h3><ul>
<li>Author: Blaise Barney, Livermore Computing.  </li>
<li>“Pthreads Programming”. B. Nichols et al. O’Reilly and Associates.  </li>
<li>“Threads Primer”. B. Lewis and D. Berg. Prentice Hall  </li>
<li>“Programming With POSIX Threads”. D. Butenhof. Addison Wesley </li>
<li>www.awl.com/cseng/titles/0-201-63392-2  </li>
<li>“Programming With Threads”. S. Kleiman et al. Prentice Hall  </li>
</ul>
<p>(完)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/04/linux-module-commands/" itemprop="url">
                  内核模块相关命令：lsmod,depmod,modprob...
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-04T18:06:00+08:00" content="2009-02-04">
              2009-02-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/04/linux-module-commands/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/04/linux-module-commands/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h3><p><strong>功能</strong>：列出内核已载入模块的状态</p>
<p><strong>用法</strong>：lsmod</p>
<p><strong>描述</strong>：</p>
<p>lsmod 以美观的方式列出/proc/modules的内容。输出为：</p>
<pre><code>Module(模块名)    Size(模块大小)   Used by(被...使用)

eg. ne2k_pci           8928               0
8390                 9472              1 ne2k_pci
</code></pre><p>在/proc/modules中相应的是：</p>
<pre><code>(模块名，模块大小，被...使用，模块地址(猜的，以后确认)) 
ne2k_pci 8928 0 - Live 0x3086400
8390 9472 1 ne2k_pci , Live 0xe086000
</code></pre><h3 id="depmod"><a href="#depmod" class="headerlink" title="depmod"></a>depmod</h3><p><strong>功能</strong>：分析可加载模块的依赖性，生成modules.dep文件和映射文件。</p>
<p><strong>用法</strong>：<br>    depmod [-b basedir] [-e] [-F System.map] [-n] [-v] [version] [-A]<br>    depmod [-e] [-F System.map] [-n] [-v] [version] [filename…]</p>
<p><strong>描述</strong>：</p>
<p>Linux内核模块可以为其它模块提供提供服务(在代码中使用EXPORT_SYMBOL)，这种服务被称作”symbols”。若第二个模块使用了这个symbol，则该模块很明显依赖于第一个模块。这些依赖关系是非常繁杂的。</p>
<p>depmod读取在/lib/modules/version 目录下的所有模块，并检查每个模块导出的symbol和需要的symbol，然后创建一个依赖关系列表。默认地，该列表写入到/lib/moudules/version目录下的modules.dep文件中。若命令中的filename有指定的话，则仅检查这些指定的模块(不是很有用)。</p>
<p>若命令中提供了version参数，则会使用version所指定的目录生成依赖，而不是当前内核的版本(uname -r 返回的)。</p>
<p><strong>选项</strong>：</p>
<pre><code>-b basedir  --basedir basedir  若你的模块并没有正确的在/lib/mdules/version下，可以指定目录生成依赖。
-e  --errsyms  和-F选项一起使用，当一个模块需要的symbol在其它模块里面没有提供时，做出报告。正常情况下，模块没有提供的symbol都在内核中有提供。
-F  --filesyms System.map 提供一个System.map文件(在内核编译时生成的)许-e选项报告出unresolved symbol。
-n  --dry_run  将结果modules.dep和各种映射文件输出到标准输出(stdout)，而不是写到模块目录下。
-A --quick  检查是否有模块比modues.dep中的模块新，若没有，则退出不重新生成文件。
</code></pre><h3 id="modprobe"><a href="#modprobe" class="headerlink" title="modprobe"></a>modprobe</h3><p><strong>功能</strong>：Linux内核添加删除模块</p>
<p><strong>用法</strong>：</p>
<pre><code>modprobe [ -v ] [ -V ] [-C config-file] [ -n ] [ -i ] [ -q ] [ -o modulename] [ modulename ] [ module parameters ... ]
modprobe [ -r ] [ -v ] [ -n ] [ -i ] [ modulename ... ]
modprobe [ -l ] [ -t dirname ] [ wildcard ]
modprobe [ -c ]
</code></pre><p><strong>描述</strong>：</p>
<pre><code>modprobe可智能地添加和删除Linux内核模块(为简便起见，模块名中&apos;_&apos;和&apos;-&apos;是一样的)。modprobe会查看模块目录/lib/modules/&apos;uname -r&apos;里面的所有模块和文件，除了可选的/etc/modprobe.conf配置文件和/etc/modprobe.d目录外。

modprobe需要一个最新的modules.dep文件，可以用depmod来生成。该文件列出了每一个模块需要的其他模块，modprobe使用这个去自动添加或删除模块的依赖。
</code></pre><p><strong>选项</strong>：</p>
<pre><code>-v --verbose  显示程序在干什么，通常在出问题的情况下，modprobe才显示信息。
-C --config  重载(^_^,意思取C++的重载)默认配置文件(/etc/modprobe.conf或/etc/modprobe.d)。
-c --showconfig  输出配置文件并退出
-n --dry-run  可以和-v选项一起使用，调试非常有用
-i --ignore-install --ignore-remove 该选项会使得modprobe忽略配置文件中的，在命令行上输入的install和remove命令。
-q --quiet 一般modprobe删除或插入一个模块时，若没有找到会提示错误。使用该选项，会忽略指定的模块，并不提示任何错误信息。
-r --remove  该选项会导致modprobe去删除，而不是插入一个模块。通常没有没有理由去删除内核模块，除非是一些有bug的模块。你的内核也不一定支持模块的卸载。
-V --verssion 版本信息
-f --force  和同时使用--force-vermagic ，--force-modversion一样。使用该选项是比较危险的。
-l --list 列出所有模块
-a --all 插入所有命令行中的模块
-t --type 强制 -l 显示dirname中的模块
-s --syslog 错误信息写入syslog
</code></pre><h3 id="modinfo"><a href="#modinfo" class="headerlink" title="modinfo"></a>modinfo</h3><p><strong>功能</strong>：显示内核模块的信息</p>
<p><strong>用法</strong>：</p>
<pre><code>modinfo [ -0 ] [ -F field] [modulename | filename ... ]
modinfo -V
modinfo -h
</code></pre><p><strong>描述</strong>：</p>
<p>modinfo列出Linux内核中命令行指定的模块的信息。若模块名不是一个文件名，则会在/lib/modules/version 目录中搜索，就像modprobe一样。</p>
<p>modinfo默认情况下，为了便于阅读，以下面的格式列出模块的每个属性：fieldname : value。</p>
<p><strong>选项</strong>：</p>
<pre><code>-V --version 版本
-F --field 仅在一行上显示field值，这对于脚本较为有用。常用的field有：author, description, licence, param, depends, alias, filename。
-0 --NULL 使用&apos;/0&apos;字符分隔field值，而不是一个新行。对脚本比较有用。
-a -d -l -p -n 这些分别是author, description, license, param ,filename的简短形式。
</code></pre><h3 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h3><p><strong>功能</strong>：向Linux内核中插入一个模块</p>
<p><strong>用法</strong>：insmod [filename] [modue options …]</p>
<p><strong>描述</strong>：</p>
<p>insmod是一个向内核插入模块的小程序：若文件名是一个连字符’-‘，模块从标准输入输入。大多数用户使用modprobe，因为它比较智能化。</p>
<h3 id="rmmod"><a href="#rmmod" class="headerlink" title="rmmod"></a>rmmod</h3><p><strong>功能</strong>：删除内核中的一模块</p>
<p><strong>用法</strong>：rmmod [ -f ] [ -w ] [ -s ] [ -v ] [ modulename ]</p>
<p><strong>描述</strong>：</p>
<p>rmmod是一个可以从内核中删除模块的小程序，大多数用户使用modprobe -r去删除模块。</p>
<p><strong>选项</strong>：</p>
<pre><code>-v --verbose  显示程序正在做些什么，一般只显示执行时的错误信息。
-f --force  该选项是非常危险：除非编译内核时，CONFIG_MODULE_FORCE_UNLOAD被设置该命令才有效果，否则没效果。用该选项可以删除正在被使用的模块，设计为不能删除的模块，或者标记为unsafe的模块。
-w --wait 通常，rmmod拒绝删除正在被使用的模块。使用该选项后，指定的模块会被孤立起来，直到不被使用。
-s  --syslog  将错误信息写入syslog，而不是标准错误(stderr)。
-V  --version 版本信息
</code></pre><p>以上内容是参考man翻译的，若有疑问请用man …查看原始文档，翻译有误之处还望见谅。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/02/diary/" itemprop="url">
                  杂想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-02T21:19:00+08:00" content="2009-02-02">
              2009-02-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/心情日记/" itemprop="url" rel="index">
                    <span itemprop="name">心情日记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/02/diary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/02/diary/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>曾几何时，都不曾写过东西了，记得好像是从上大学开始吧！ 以前文笔自认为还是不错的，现在远远不及以前那么有状态了。也许是人心态变了的缘故吧。以前比较单纯，现在比较浮躁；以前敢于幻想美好的东西，每每想到都会感到自己充满了力量和激情，现在想起那些美好的东西，自己就更加痛苦了，因为那些东西根本就不能实现。现在能做的也只能是在这里无病呻吟了，以缅怀逝去的美好！</p>
<p>昨晚拿起《叔本华散文》随便翻翻，看到里面有一篇关于写作的，提到写作有三种：先想后写，边想边写，不想也写。不想也写的是纯粹的文字垃圾；边想边写的无非也是在模仿甚至是抄袭，只是用文字记下当时大脑中的影像，很难有新东西；先想后写的东西才是有意义的，因为写作的目的是记录下经过系统思考的东西，所以逻辑比较明晰。他说的应该是比较学术的哪一类写作吧！我想我的就属于他说的不想也写，带有点边想边写。不管了，反正是想到哪里写到哪里了。</p>
<p>不过说实话，只要提起笔写东西，大脑里面高中时候的场景挥都挥不去。年少轻狂的年代，任何人和事都不往眼里放，人与人之间的关系也比较简单，生活目的也比较单纯！一切都是那么简单！口里之乎者也，也偶尔可以文绉绉酸一下。没事写写诗，虽然很烂，但至少是自己真实的内心写照，聊以自慰！虽然知识学的不是很深，但还是敢于和朋友一起谈天说地，乾坤宇宙，尘埃微粒无所不及。记得高中一直自己给自己写的一句话，很老套，但是在那个年代一直铭刻在心：追求卓越，雕琢世界。话虽俗套，但对自己来说确意味深长！当时的想法：追求卓越指的是人要不断提高自身以达到比较高的境界，雕琢世界强调的是人的主观能动性，去改造世界，去探求真知，去揭开“上帝的面纱”。合起来的意思也就很明白了。现在想想都觉得惭愧难当，世界没有“雕琢”成，却被世界“雕琢”成现在这样了。毫无激情，简直活着就是做一天和尚撞一天钟一样。重复，重复，无尽的重复着。痛苦，痛苦，无尽的痛苦。…</p>
<p>一直在学知识，但感觉那些始终不是自己的，甚至就是纯粹的记忆过程。面对浩瀚学海，真是有点无所适从了。可能是高中时候养成的学习习惯吧，凡事都要追根问底，非要从最底层理解起。往往追根的时候又会碰到许多新知识，然后又去追根，结果是忙于寻找问题和解决问题的方法，而真正的问题的系统的解决方法到最后也毫无头绪。弄的自己头昏脑胀，迷茫一片。（边想边写吧，一直在回味高中时代，现在却成为给自己找毛病了，那就继续找把，总结下，以后也好慢慢改正）。上面的也不能算是一个毛病，只是方法用错了对象，以后可要注意了。我以前是学物理的，物理的目标也就是从最表面的，最常见的事物入手，探求深层次的，本质的问题所在，属于理论型的，深层理解的越深说明对于物理掌握的越透彻。现在是干软件的，工程型的，快速达到目标，能重用的尽可能重用，不必深层理解系统低层，只要会用系统接口就一切搞定（当然这里的系统低层是比较稳定的，经过时间证明的），而我经常犯傻，有时一个API，非要找到它的实现不可，甚至深入到操作系统庞大的代码中去获取答案。结果大量时间被浪费，还把自己的头弄的比斗大。同时也可以反映出：科学的目标是提出问题和解决问题的方法，工程的目标是实现问题，解决问题（不择手段^_^)；科学的精神是怀疑一切，不惜推翻重来，工程的精神是尽最大可能重用，不发明已有的车轮，甚至懒于改造。可能理解有误，不过说出的是自己的想法。</p>
<p>想想自己的毛病还真不少啊，实在是惭愧啊！朝秦暮楚算一个，大学期间专业是换了又换，从电子信息工程专业到LCD（电子科学与技术），一直和物理相关，但课程内容却完全不同，一个偏向与通信（工程型的），一个偏向与材料物理（理论型的），期间还一心自学理论物理，准备考研。自从大一第二学期接触C语言开始，同时迷上编程，喜欢那种主宰一切的感觉，所以计算机专业的课程也都基本上自学完成。就这样物理与编程一直是大学生活中的全部。碍于世俗，毕业时放弃了物理，选择了进入软件行业。开启了痛苦之旅！生活失去了原动力，不断审视生活的目的，往往毫无结果，更加痛苦！加之各种长大成人的烦恼迎面而来，苦不堪言！既想轰轰烈烈又想平平淡淡，处于一个极度浮躁状态！ 呵呵，算是花心，罪有应得！</p>
<p>毛病就不想了，今天本来就有点不爽，什么都不想干，所以才在这里写。越想越不爽了，毛病以后得改，生活还得继续，以后多总结，自己的想法记录下来。就此打住！继续学习…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/11/19/cstdarg/" itemprop="url">
                  函数参数不确定时用cstdarg(stdarg.h)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-11-19T23:05:00+08:00" content="2008-11-19">
              2008-11-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/11/19/cstdarg/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/11/19/cstdarg/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func( Type para1, Type para2, Type para3, ... )</div><div class="line">&#123;</div><div class="line">      /****** Step 1 ******/</div><div class="line">      va_list ap;</div><div class="line">      va_start( ap, para3 ); //一定要“...”之前的那个参数</div><div class="line">    </div><div class="line">      /****** Step 2 ******/</div><div class="line">      //此时ap指向第一个可变参数</div><div class="line">      //调用va_arg取得里面的值</div><div class="line">    </div><div class="line">      Type xx = va_arg( ap, Type ); </div><div class="line">    </div><div class="line">      //Type一定要相同，如:</div><div class="line">      //char *p = va_arg( ap, char *);</div><div class="line">      //int i = va_arg( ap, int );</div><div class="line">      //如果有多个参数继续调用va_arg</div><div class="line">      /****** Step 3 ******/</div><div class="line">      va_end(ap); //For robust!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">typedef char *    va_list;</div><div class="line">#define va_start _crt_va_start</div><div class="line">#define va_arg _crt_va_arg</div><div class="line">#define va_end _crt_va_end</div><div class="line">#define _crt_va_start(ap,v)    ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )</div><div class="line">#define _crt_va_arg(ap,t)      ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )</div><div class="line">#define _crt_va_end(ap)        ( ap = (va_list)0 ) </div><div class="line">va_list argptr;</div></pre></td></tr></table></figure>
<p>C语言的函数是从右向左压入堆栈的,调用va_start后，按定义的宏运算，_ADDRESSOF得到v所在的地址，然后这个地址加上v的大小，则使ap指向第一个可变参数如图:     </p>
<pre><code>栈底 高地址
| .......     
| 函数返回地址
| .......      
| 函数最后一个参数
| ....                       
| 函数第一个可变参数       &lt;--va_start后ap指向 
| 函数最后一个固定参数
| 函数第一个固定参数 
栈顶 低地址
</code></pre><p>然后，用va_arg()取得类型t的可变参数值, 先是让ap指向下一个参数:</p>
<pre><code>ap += _INTSIZEOF(t)
</code></pre><p>然后在减去_INTSIZEOF(t)，使得表达式结果为ap之前的值，即当前需要得到的参数的地址，强制转换成指向此参数的类型的指针，然后用*取值最后，用va_end(ap)，给ap初始化，保持健壮性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include    &lt;stdio.h&gt;   </div><div class="line">#include    &lt;ctype.h&gt;   </div><div class="line">#include&lt;stdlib.h&gt;   </div><div class="line">#include    &lt;stdarg.h&gt;   </div><div class="line"></div><div class="line">int    average(    int    first,    ...    )      //变参数函数,C++里也有   </div><div class="line">&#123;   </div><div class="line">     int    count=0,i=first,sum=0;   </div><div class="line">     va_list    maker;            //va_list    类型数据可以保存函数的所有参数,做为一个列表一样保存   </div><div class="line">     va_start(maker,first);    //设置列表的起始位置   </div><div class="line">     while(i!=-1)   </div><div class="line">     &#123;   </div><div class="line">     sum+=i;   </div><div class="line">     count++;   </div><div class="line">     i=va_arg(maker,int);//返回maker列表的当前值,并指向列表的下一个位置   </div><div class="line">     &#125;   </div><div class="line">     return    sum/count;   </div><div class="line">      </div><div class="line">&#125;   </div><div class="line"></div><div class="line">void main(void)   </div><div class="line">&#123;   </div><div class="line">		printf(&quot;Average    is:    %d/n&quot;,    average(    2,    3,    4,4,    -1    )    );   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Linux下的stdarg.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#ifndef _STDARG_H</div><div class="line">#define _STDARG_H</div><div class="line"></div><div class="line">typedef char *va_list; /* 定义va_list 是一个字符指针类型*/</div><div class="line"></div><div class="line">/* Amount of space required in an argument list for an arg of type TYPE.</div><div class="line">TYPE may alternatively be an expression whose type is used. */</div><div class="line">/* 下面给出了类型为TYPE 的arg 参数列表所要求的空间容量。</div><div class="line">TYPE 也可以是使用该类型的一个表达式 */</div><div class="line"></div><div class="line">// 下面这句定义了取整后的TYPE 类型的字节长度值。是int 长度(4)的倍数。</div><div class="line">#define __va_rounded_size(TYPE) /</div><div class="line">(((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</div><div class="line"></div><div class="line">// 下面这个函数（用宏实现）使AP 指向传给函数的可变参数表的第一个参数。</div><div class="line">// 在第一次调用va_arg 或va_end 之前，必须首先调用该函数。</div><div class="line">// 17 行上的__builtin_saveregs()是在gcc 的库程序libgcc2.c 中定义的，用于保存寄存器。</div><div class="line">// 它的说明可参见gcc 手册章节“Target Description Macros”中的</div><div class="line">// “Implementing the Varargs Macros”小节。</div><div class="line">#ifndef __sparc__</div><div class="line">#define va_start(AP, LASTARG) /</div><div class="line">(AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))</div><div class="line">#else</div><div class="line">#define va_start(AP, LASTARG) /</div><div class="line">(__builtin_saveregs (), /</div><div class="line">AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))</div><div class="line">#endif</div><div class="line"></div><div class="line">// 下面该宏用于被调用函数完成一次正常返回。va_end 可以修改AP 使其在重新调用</div><div class="line">// va_start 之前不能被使用。va_end 必须在va_arg 读完所有的参数后再被调用。</div><div class="line">void va_end (va_list); /* Defined in gnulib *//* 在gnulib 中定义 */</div><div class="line">#define va_end(AP)</div><div class="line"></div><div class="line">// 下面该宏用于扩展表达式使其与下一个被传递参数具有相同的类型和值。</div><div class="line">// 对于缺省值，va_arg 可以用字符、无符号字符和浮点类型。</div><div class="line">// 在第一次使用va_arg 时，它返回表中的第一个参数，后续的每次调用都将返回表中的</div><div class="line">// 下一个参数。这是通过先访问AP，然后把它增加以指向下一项来实现的。</div><div class="line">// va_arg 使用TYPE 来完成访问和定位下一项，每调用一次va_arg，它就修改AP 以指示</div><div class="line">// 表中的下一参数。</div><div class="line">#define va_arg(AP, TYPE) /</div><div class="line">(AP += __va_rounded_size (TYPE), /</div><div class="line">*((TYPE *) (AP - __va_rounded_size (TYPE))))</div><div class="line"></div><div class="line">#endif /* _STDARG_H */</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/09/26/string-match-algorithm/" itemprop="url">
                  字符串匹配之朴素算法和通配符扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-09-26T21:19:00+08:00" content="2008-09-26">
              2008-09-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/09/26/string-match-algorithm/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/09/26/string-match-algorithm/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p><strong>问题</strong>：给定一个T[1..n],P[1..m] ,T和P中的任意元素属于∑（有限的字符集合），求位移s使得 T[s+1..s+m] = P[1..m].  T 代表 Text(文本串), P代表 Pattern(匹配串)。</p>
<p>有多种算法可以实现,这里只介绍最简单,最容易理解,”最笨的” 朴素匹配算法:</p>
<pre><code>T：t1 t2 ….tn
P：p1 p2..pm
其中（m&lt;=n）
</code></pre><p>最容易想到的就是让P在T上一个字符一个字符的向右滑动，然后比较T的某一段时候和P想匹配，若不匹配，继续向右滑动；否则匹配成功。这样效率比较低，最坏情况下复杂度为theta((n-m+1)*m)。伪代码如下：</p>
<pre><code>n &lt;- length[T]
m &lt;- lengthp[P]
for s=0 to n-m
     if T[s+1…s+m] = P[1…m]
           匹配成功，输出s，若只匹配第一个，则可在此退出循环。
     else
           继续匹配
</code></pre><p>对于有限的字符集下（假设个数为d），若果T和P中的字符都随机出现，则平均比较次数为（n-m+1）*(1-d^-m)/(1-d^-1) &lt;= 2(n-m+1)。呵呵,这样看来这个“笨”的算法还算可以，不算很“笨”。</p>
<p>下面给出一种用回溯方法写的代码：（和strstr函数功能相同）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int index(const char * str1, const char * str2, size_t pos)</div><div class="line">&#123;</div><div class="line">       size_t i = pos;</div><div class="line">       size_t j = 0;</div><div class="line">       while(i &lt; strlen(str1) &amp;&amp; j &lt; strlen(str2))</div><div class="line">       &#123;</div><div class="line">               if(str1[i] ==  str2[j]) // matched then continue</div><div class="line">               &#123;</div><div class="line">                          ++i;</div><div class="line">                          ++j;</div><div class="line">               &#125;</div><div class="line">               else     // unmatched then backtrace</div><div class="line">               &#123;</div><div class="line">                   i = i - j + 1;</div><div class="line">                   j = 0;</div><div class="line">               &#125;</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       if(j &gt;= strlen(str2))  // matched and return the index</div><div class="line">            return i-strlen(str2);</div><div class="line">       else</div><div class="line">            return -1;  // not found</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个例子就一清二楚了。</p>
<pre><code>T =aababcd
P =abc
</code></pre><p>第1次：<br>    a a b a b c d<br>    a</p>
<p>匹配成功,继续下个字符的匹配，第2次：</p>
<pre><code>a a b a b c d
a b
</code></pre><p>匹配失败，回溯，进行第3次：</p>
<pre><code>a a b a b c d
- a
</code></pre><p>匹配成功，继续….</p>
<p>归纳下看：</p>
<p>第m次：</p>
<p>先假设数组开始的下标为0。</p>
<pre><code>T=O O …O O O O O O O
P=      O O O O …
</code></pre><p>与P的第一个字符的下标为0，正在匹配的下标为j，此时与P[j]匹配的T的下标是i。</p>
<p>1）  若P[j]与T[i]匹配，则继续下一个字符的匹配，i++，j++。</p>
<p>2）  若P[j]与T[i]失配,  则T的下标回溯到i-j+1,P重新开始（j=0）。</p>
<p>若数组下标不是以0开始的，而是以一开始的，只需回溯到i=i-j+2，j=1即可。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>加入匹配字符串中有通配符*，？。</p>
<p>可以匹配多个字符，多个连接在一起的<em>可以认为是一个，而?只能通配一个字符。则算法可以改进为：<br>当P[j]是’</em>’时，求T与P[j+1]</p>
<p>匹配的第一个字符所在的下标，T的下标置为此值。然后继续循环。哈哈，语言描述能力不行啊，还是直接看代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line"> *decrip:match the string(&apos;*&apos; and &apos;?&apos; not included) with pattern including *(se</div><div class="line"> *        veral),?(only one)</div><div class="line"> *input:</div><div class="line"> *    T  --  text </div><div class="line"> *    P  --  Pattern</div><div class="line"> *return:</div><div class="line"> *     true for exit ,false for not</div><div class="line"> *     start,end -- the index of the pattern found in the text </div><div class="line"> */</div><div class="line">bool match(const char* T, const char* P, int&amp; start, int&amp; end)</div><div class="line">&#123;</div><div class="line">    size_t i = 0;</div><div class="line">    size_t j =0;</div><div class="line">    size_t n = strlen(T);</div><div class="line">    size_t m = strlen(P);</div><div class="line">    bool bStart = true;</div><div class="line">    while(i &lt; n &amp;&amp; j &lt; m)</div><div class="line">    &#123;</div><div class="line">            if(P[j] == &apos;*&apos;)   // wildcard ,then find the first position matched with next character </div><div class="line">            &#123;</div><div class="line">                    ++j;</div><div class="line">                    while(&apos;*&apos; == P[j]) // &quot;***..*&quot; &lt;=&gt; &quot;*&quot;</div><div class="line">                               ++j;</div><div class="line">                    while(T[i] != P[j])</div><div class="line">                               ++i;</div><div class="line">                    if(i &gt;= n) // finished, no matter matched or not</div><div class="line">                         break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if(T[i] == P[j] || &apos;?&apos; == P[j])</div><div class="line">            &#123;</div><div class="line">                    if(bStart) // new loop start</div><div class="line">                    &#123;</div><div class="line">                              start = i;</div><div class="line">                              bStart = false;</div><div class="line">                    &#125;</div><div class="line">                    ++i;</div><div class="line">                    ++j;</div><div class="line">                    </div><div class="line">                    if(j == m) // match finish</div><div class="line">                         end = i-1;</div><div class="line">            &#125;</div><div class="line">            else  // unmatched ,then backtrace(start a new loop)</div><div class="line">            &#123;</div><div class="line">                static size_t ipp = 0;</div><div class="line">                ++ipp;</div><div class="line">                i = ipp;</div><div class="line">                j = 0;</div><div class="line">                bStart = true;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if(j &gt;= m)  // succeeded to find the pattern</div><div class="line">    &#123;</div><div class="line">         if( &apos;*&apos; == P[0])   // postfix</div><div class="line">             start = 0;</div><div class="line">         if( &apos;*&apos; == P[m-1]) // prefix</div><div class="line">             end = n-1;</div><div class="line">         return true;</div><div class="line">    &#125;</div><div class="line">    else  </div><div class="line">        return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol>
<li>以上内容，朴素算法伪代码参考《算法导论》。</li>
<li>回溯程序是看了一位网上哥们的伪代码写的。</li>
<li>通配符扩展是参考1），2），自己分析写的。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/06/11/main-windows-handle/" itemprop="url">
                  已知进程句柄，如何知道此进程的主窗口句柄
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-06-11T13:06:00+08:00" content="2008-06-11">
              2008-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/06/11/main-windows-handle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/06/11/main-windows-handle/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>已知进程句柄，如何知道此进程的主窗口句柄,在此说明两种方法:</p>
<ol>
<li>调用FindWindow(),前提是必须知道该进程中窗口类名和窗口名,返回后的句柄可以通过IsWindow()函数来验证是否是有效的窗口句柄.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">HWND hWnd = ::FindWindow(szClassName, szWndName);  </div><div class="line">if(::IsWindow(hWnd))  </div><div class="line">&#123;  </div><div class="line">      //  处理该窗口  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.先枚举全部窗口,再枚举回调函数中调用GetWindowThreadProcessID()得到窗口得进程ID,再与以前得到得ID比较.如果不一致,不处理,若一致,循环调用GetParent()一直到返回NULL, 最后得hwnd即为顶层窗口句柄</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">BOOL   CALLBACK   EnumWindowsProc(HWND   hwnd,       LPARAM   lParam   )     </div><div class="line"> &#123;     </div><div class="line">     unsigned   long   id;     </div><div class="line">      HWND   thwnd;     </div><div class="line">     </div><div class="line">      id=GetWindowThreadProcessId(hwnd,NULL);     </div><div class="line">      if   (id==lParam)     </div><div class="line">     &#123;     </div><div class="line">            while((thwnd=GetParent(hwnd))!=NULL)     </div><div class="line">                  hwnd=thwnd;     </div><div class="line">            CString   x;     </div><div class="line">            x.Format(&quot;HWND   =   %x&quot;,hwnd);     </div><div class="line">            MessageBox(NULL,x,NULL,MB_OK);     </div><div class="line">            return   false;       </div><div class="line">      &#125;     </div><div class="line">      return   true;     </div><div class="line"> &#125;     </div><div class="line">       </div><div class="line">     </div><div class="line"> void   CMt2Dlg::OnButton1()       </div><div class="line"> &#123;     </div><div class="line"> //   TODO:   Add   your   control   notification   handler   code   here     </div><div class="line">   STARTUPINFO   StartInfo;     </div><div class="line">   PROCESS_INFORMATION     ProceInfo;     </div><div class="line">   ZeroMemory(&amp;StartInfo,sizeof(StartInfo));     </div><div class="line">   StartInfo.cb=sizeof(StartInfo);     </div><div class="line">     </div><div class="line">   CreateProcess(NULL,   //lpApplicationName:   PChar     </div><div class="line">         &quot;calc.exe&quot;,   //lpCommandLine:   PChar     </div><div class="line">         NULL,   //lpProcessAttributes:   PSecurityAttributes     </div><div class="line">         NULL,   //lpThreadAttributes:   PSecurityAttributes     </div><div class="line">         true,   //bInheritHandles:   BOOL     </div><div class="line">         CREATE_NEW_CONSOLE,     </div><div class="line">         NULL,     </div><div class="line">        NULL,     </div><div class="line">         &amp;StartInfo,     </div><div class="line">         &amp;ProceInfo);     </div><div class="line">     </div><div class="line">   Sleep(100);     //这是必须的,因为   CreateProcess   不能马上Active   windows     </div><div class="line">   EnumWindows(EnumWindowsProc,ProceInfo.dwThreadId);     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/06/06/chart-class/" itemprop="url">
                  一个用于显示数值曲线的类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-06-06T02:50:00+08:00" content="2008-06-06">
              2008-06-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/06/06/chart-class/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/06/06/chart-class/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做一个课题，要显示几条数值曲线。不过不想借助其它控件，或其它公司提供的开发包，如MATCOM，用这些的话就太简单不过了。下面是一个自己设计的一个类，用API堆的，这样既可以在基于SDK应用开发应用，又可以在MFC框架中应用。下面几个图是测试时截的。在此声明一下，我是一新手，难免设计的不合理甚至错误百出，敬请见谅！点此下载源代码和示例代码(<a href="http://download.csdn.net/detail/future_fighter/485567)。" target="_blank" rel="external">http://download.csdn.net/detail/future_fighter/485567)。</a></p>
<p><img src="/images/2008-06-06-1.JPG" alt="显示多条曲线"></p>
<p>图1  显示多条曲线</p>
<p><img src="/images/2008-06-06-2.JPG" alt="显示坐标提示"></p>
<p>图2 显示坐标提示</p>
<p><img src="/images/2008-06-06-3.JPG" alt="坐标系显示范围缩放"></p>
<p>图3 坐标系显示范围缩放</p>
<p>类名为CChart，其基类为CChartBase。CChartBase主要用于显示，设置坐标系的一些属性，比如x，y轴可以显示的范围、坐标系边框颜色、背景颜色等；而CChart则用于显示坐标系和多条曲线，曲线颜色、线宽、等凡是可见的属性都可以设定。用法如下：</p>
<p>1． 将DispChart.h和DispChart.cpp包含至用使用该类的Project中，若为基于MFC项目，则在DispChart.cpp中添加#include ”stdafx.h”。</p>
<p>2． 定义一个该类的变量，CChart chart(hWnd); hWnd是该坐标所在窗口的句柄。</p>
<p>3． （可选）设置相应的属性。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">chart.SetGridColor(RGB(255,0,0));    // 设置网格颜色  </div><div class="line">chart.SetGriddx(10);                 // 设置网格x轴间隔  </div><div class="line">chart.SetClrLabel(RGB(0,0,255));     // 标尺颜色  </div><div class="line">chart.SetXLabel(&quot;t/min&quot;);            // 轴标文字  </div><div class="line">chart.SetYLabel(&quot;V/v&quot;);  </div><div class="line">chart.SetRulerXFormat(&quot;%.2f&quot;);       // x轴标尺显示精度  </div><div class="line">chart.SetGriddy( 0.01);  </div><div class="line">chart.SetXRange( 0, 100);            // x轴可以显示的范围  </div><div class="line">chart.SetYRange( -5, 5);</div></pre></td></tr></table></figure>
<p>4． 添加曲线数据连接，曲线数据必须是vector<double>型的。如：</double></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   std::vector&lt;double&gt; data[3];</div><div class="line">   int length = 1000;</div><div class="line">   double amp = 5;</div><div class="line">   for(int i=0;i&lt;length;i++)</div><div class="line">   &#123;</div><div class="line">    double t = (20 * 3.1415926 / length) * i;</div><div class="line">    double y1 = amp*sin(t);</div><div class="line">    double y2 = (amp/2)*cos(t);</div><div class="line">    data[0].push_back(t);</div><div class="line">    data[1].push_back(y1);</div><div class="line">    data[2].push_back(y2);</div><div class="line">   &#125;</div><div class="line">   chart.AddMCurves(data,3);</div><div class="line">   chart.SetCurveColor(0,RGB(0,0,0));</div><div class="line">```   </div><div class="line"></div><div class="line"> </div><div class="line">5． 在WM_PAINT消息或其它地方绘制曲线。先设置显示在那个位置，然后绘制。</div></pre></td></tr></table></figure>
<p>case WM_PAINT:<br>        hdc = BeginPaint(hWnd, &amp;ps);<br>        // TODO: 在此添加任意绘图代码..<br>        RECT rect;<br>        GetClientRect(hWnd,&amp;rect);  </p>
<pre><code>chart.SetChartDC(hdc);  

chart.SetChartAndWindowPosition(rect);  

 chart.ShowCurves();  

EndPaint(hWnd, &amp;ps);  
break;  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">6． （可选）若要动态缩放、平移、左键点击显示坐标提示窗口、右键框选缩放，则只需在相应的消息处理处添加相关操作即可。注意：由于我是用该类绘制周期性的曲线的，所以平移和缩放只是x轴的；若要同时平移或缩放，在CChart::OnMouseWheel函数中将ScaleX改变为ScaleCenter即可以完成x，y轴同时缩放，在CChart::OnMouseMove函数中修改Move的第二参数为-(y - m_ptLeftButtonDown.y) * GetYPerPix()即可以完成x，y轴同时移动。</div></pre></td></tr></table></figure>
<p>if( m_ptLeftButtonDown.x != -1)<br>{<br> Move( -(x - m_ptLeftButtonDown.x) <em> GetXPerPix() , -(y - m_ptLeftButtonDown.y) </em> GetYPerPix());</p>
<p> m_ptLeftButtonDown.x = x;<br> m_ptLeftButtonDown.y = y;</p>
<p>// 绘制曲线和坐标系<br> ShowCurves();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">示例代码：</div></pre></td></tr></table></figure></p>
<p>case WM_LBUTTONDOWN:  </p>
<pre><code>    chart.OnLeftButtonDown(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_LBUTTONUP:  
    chart.OnLeftButtonUp(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_RBUTTONDOWN:  
    chart.OnRightButtonDown(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_RBUTTONUP:  
    chart.OnRightButtonUp(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_MOUSEMOVE:  
    chart.OnMouseMove(LOWORD(lParam), HIWORD(lParam));  
    break;  
case 0x020A/*WM_MOUSEWHEEL*/:  
    {  
        POINT pt = { LOWORD(lParam), HIWORD(lParam) };  
        ScreenToClient( hWnd,&amp;pt );  
        chart.OnMouseWheel(wParam, pt.x, pt.y);  
    }  
    break;  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>#ifndef _DISPCHART_H  </p>
<p>#define _DISPCHART_H  </p>
<p>#include <windows.h></windows.h>  </p>
<p>#include <vector></vector>  </p>
<p>#include <string></string>  </p>
<p>// 图表基类:用于绘制坐标系和曲线<br>class CChartBase<br>{<br>protected:<br>    HDC       m_hChartDC;       // 图表绘制的DC<br>    RECT      m_rtWindow;       // 坐标窗口,其中包含图表显示区和坐标标尺,轴标等<br>    RECT      m_rtChart;        // 图标显示区(依赖域m_rtWindow)  </p>
<pre><code>// 坐标显示边界  
double    m_xStart;         // 实数域内x轴起点  
double    m_xEnd;           //         x轴终点  
double    m_yStart;         //         y轴起点  
double    m_yEnd;           //         y轴终点  

// 显示图表区  
COLORREF  m_clrChartBg;     // 显示区背景色  
COLORREF  m_clrChartBorder; //       边框色  

// 网格  
bool      m_bGridOn;        // 控制网格是否显示  
double    m_dxGrid;         // 网格单元宽  
double    m_dyGrid;         // 网格单元高  
COLORREF  m_clrGrid;        // 网格线颜色  

// 坐标轴,轴标,标尺  
char      m_xLabel[20];  
char      m_yLabel[20];  
bool      m_bxLabelOn;   
bool      m_byLabelOn;  

bool      m_bxRulerOn;  
bool      m_byRulerOn;  
char      m_szRulerXFormat[128];  
char      m_szRulerYFormat[128];  

COLORREF  m_clrLabel;      // 轴标文字和刻度文字颜色  

// 文字字体  
LOGFONT     m_logFont;  

// 曲线数据  
</code></pre><p>public:  </p>
<pre><code>// 辅助函数  
void SetChartDC(HDC hdc);  
HDC  GetChartDC() const ;  
void SetChartWindowPosition(RECT rect);  
void SetChartWindowPosition(int left, int top, int right, int bottom);  
RECT GetChartWindowPosition() const;  
void SetChartPosition(RECT rect);  
void SetChartPosition(int left, int top, int right, int bottom);  

RECT GetChartPosition() const;  
int  GetChartWidth()const  { return m_rtChart.right - m_rtChart.left ; };  
int  GetChartHeight()const { return m_rtChart.bottom - m_rtChart.top ; };  
int  GetChartWindowWidth() const { return m_rtWindow.right - m_rtWindow.left; };  
int  GetChartWindowHeight() const{ return m_rtWindow.bottom - m_rtWindow.top; };  

// 坐标显示边界  
double SetXStart(double xStart);  
double SetXEnd(double xEnd);  
void   SetXRange(double xStart,double xEnd);  
double SetYStart(double yStart);  
double SetYEnd(double yEnd);  
void   SetYRange(double yStart,double yEnd);  
double GetXStart()const;  
double GetXEnd()const;  
double GetYStart()const;  
double GetYEnd()const;  

// 显示图表区  
void      SetClrChartBg(COLORREF clr);  
COLORREF  GetClrChartGb()const;  
void      SetClrChartBorder(COLORREF clr);  
COLORREF  GetClrChartBorder()const;  

// 网格  
double   SetGriddx(double dxGrid);              // 设置网格宽度,返回前一个值  
double   SetGriddy(double dyGrid);              // 设置网格高度,返回前一个值  
void     SetGridxy(double dxGrid,double dyGrid);  
COLORREF SetGridColor(COLORREF color);          // 设置网格颜色,返回前一个值  
void SetGridOn();                               // 设置网格为显示状态  
void SetGridOff();                              // 设置网格为关闭状态  

double   GetGriddx()const;  
double   GetGriddy()const;  
COLORREF GetGridColor()const;  
bool     GetGridStatus()const;  

// 坐标轴,轴标,标尺  
void    SetXLabel(const char* xLabel);  
void    SetYLabel(const char* yLabel);  
void    SetXLabelOn();  
void    SetXLabelOff();  
BOOL    GetXLabelStatus()const;  
void    SetYLabelOn();  
void    SetYLabelOff();  
BOOL    GetYLabelStatus()const;  

void    SetXRulerOn();  
void    SetXRulerOff();  
BOOL    GetXRulerStatus()const;  
void    SetYRulerOn();  
void    SetYRulerOff();  
BOOL    GetYRulerStatus()const;  

void    SetRulerXFormat(const char str[]) { strcpy(m_szRulerXFormat, str);};  
void    SetRulerYFormat(const char str[]) { strcpy(m_szRulerXFormat, str);};  

void     SetClrLabel(COLORREF clr);  
COLORREF GetClrLabel()const;  

// 字体  
void    SetLogFont(LOGFONT logFont);  
LOGFONT GetLogFont()const;  


// 每一个象素所代表的实数值  
double GetYPerPix() const;  
double GetXPerPix() const;  
</code></pre><p>protected:<br>    int  ShowChartBg();<br>    int  ShowGrid();<br>    int  ShowRuler();<br>    int  ShowLabel();  </p>
<p>public:<br>    CChartBase();<br>    ~CChartBase();  </p>
<pre><code>int ShowAt(int left, int top, int right, int bottom); // 在rect中显示该图标窗口,外部最好用该函数  
int ShowAt(RECT rect);  
int Show();                                           // 通过设置各种参数显示  

// 坐标转换 r--real  s--screen 2--to  
int rx2sx(double rx);    
int ry2sy(double ry);  
double sx2rx(int sx);  
double sy2ry(int sy);  

// 坐标变换  
void Move(double drx, double dry);                   // 坐标系平移  
void ScaleCenter(double times);                      // 坐标以坐标框的中心放缩  
                                                     // times&gt;1时,显示范围扩大,起到缩小的作用  
                                                     // times&lt;1时,显示范围缩小,起到放大的作用  
void ScaleX(double times);                           // X轴范围缩放（以x轴中心）  
void ScaleY(double times);                           // Y轴范围缩放（以y轴中心）  
</code></pre><p>};  </p>
<p>class CChart:public CChartBase<br>{<br>private:<br>    HWND       m_hWnd;           // 图表所在的窗口，该窗口可以处理消息（用于实现坐标变换等）<br>    HDC        m_memDCWindow;    // 存储整个绘图窗用的内存句柄<br>    HBITMAP    m_bmpInDCWindow;<br>    HDC        m_memDCChart;     // 存储chart的内存设备句柄<br>    HBITMAP    m_bmpInDCChart;   // 图表所对应的位图句柄  </p>
<pre><code>// 曲线数据  
</code></pre><p>public:  </p>
<pre><code>std::vector  
</code></pre><p>``` </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/05/24/bitmap-open-save/" itemprop="url">
                  位图文件的打开和保存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-05-24T15:12:00+08:00" content="2008-05-24">
              2008-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/05/24/bitmap-open-save/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/05/24/bitmap-open-save/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面是两个函数， SaveBmp函数用于设备相关位图(DIB)保存为bmp格式的文件。DrawBitmapFile则用于将bmp格式的文件打开并显示在指定的设备环境上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BOOL SaveBmp(HBITMAP hBitmap, const char *FileName)</div><div class="line">&#123;</div><div class="line">     HDC     hDC;       </div><div class="line">     //当前分辨率下每象素所占字节数       </div><div class="line">     int     iBits;       </div><div class="line">     //位图中每象素所占字节数       </div><div class="line">     WORD    wBitCount;       </div><div class="line">    //定义调色板大小，位图中像素字节大小，位图文件大小，写入文件字节数   </div><div class="line">     DWORD   dwPaletteSize=0,dwBmBitsSize=0, dwDIBSize=0, dwWritten=0;           </div><div class="line">     //位图属性结构           </div><div class="line">     BITMAP  Bitmap;               </div><div class="line">     //位图文件头结构       </div><div class="line">     BITMAPFILEHEADER   bmfHdr;               </div><div class="line">     //位图信息头结构           </div><div class="line">     BITMAPINFOHEADER   bi;               </div><div class="line">     //指向位图信息头结构               </div><div class="line">     LPBITMAPINFOHEADER lpbi;               </div><div class="line">     //定义文件，分配内存句柄，调色板句柄           </div><div class="line">     HANDLE  fh,hDib,hPal,hOldPal=NULL;           </div><div class="line">                              </div><div class="line">     //计算位图文件每个像素所占字节数           </div><div class="line">     hDC=::CreateDC(&quot;DISPLAY&quot;,NULL, NULL, NULL);  </div><div class="line">     iBits=::GetDeviceCaps(hDC,BITSPIXEL)* ::GetDeviceCaps(hDC,PLANES);  </div><div class="line">     ::DeleteDC(hDC);  </div><div class="line"></div><div class="line">      if(iBits &lt;= 1)         </div><div class="line">          wBitCount = 1;  </div><div class="line">      else if(iBits &lt;= 4)</div><div class="line">          wBitCount = 4;           </div><div class="line">      else if(iBits &lt;= 8)</div><div class="line">          wBitCount =  8;           </div><div class="line">      else                                                                                                                      wBitCount = 24;           </div><div class="line">                              </div><div class="line">      ::GetObject(hBitmap,sizeof(Bitmap),(LPSTR)&amp;Bitmap);       </div><div class="line">     bi.biSize = sizeof(BITMAPINFOHEADER);       </div><div class="line">     bi.biWidth = Bitmap.bmWidth;       </div><div class="line">     bi.biHeight = Bitmap.bmHeight;       </div><div class="line">     bi.biPlanes = 1;       </div><div class="line">     bi.biBitCount = wBitCount;       </div><div class="line">     bi.biCompression = BI_RGB;       </div><div class="line">     bi.biSizeImage = 0;       </div><div class="line">     bi.biXPelsPerMeter = 0;       </div><div class="line">     bi.biYPelsPerMeter = 0;       </div><div class="line">     bi.biClrImportant = 0;       </div><div class="line">     bi.biClrUsed = 0;       </div><div class="line">                              </div><div class="line">     dwBmBitsSize = ((Bitmap.bmWidth * wBitCount + 31) / 32) * 4 * Bitmap.bmHeight;       </div><div class="line">                              </div><div class="line">     //为位图内容分配内存           </div><div class="line">     hDib = ::GlobalAlloc(GHND,dwBmBitsSize + dwPaletteSize + sizeof(BITMAPINFOHEADER));           </div><div class="line">     lpbi =(LPBITMAPINFOHEADER)::GlobalLock(hDib);           </div><div class="line">     *lpbi = bi;           </div><div class="line">      </div><div class="line">     //     处理调色板               </div><div class="line">     hPal = GetStockObject(DEFAULT_PALETTE);           </div><div class="line">     if(hPal)           </div><div class="line">     &#123;           </div><div class="line">         hDC = ::GetDC(NULL);           </div><div class="line">         hOldPal = ::SelectPalette(hDC,(HPALETTE)hPal,FALSE);           </div><div class="line">         RealizePalette(hDC);           </div><div class="line">     &#125;       </div><div class="line">      </div><div class="line">     //     获取该调色板下新的像素值           </div><div class="line">     GetDIBits(hDC,hBitmap,0,(UINT)Bitmap.bmHeight,(LPSTR)lpbi + sizeof(BITMAPINFOHEADER) +dwPaletteSize,</div><div class="line">               (BITMAPINFO*)lpbi,DIB_RGB_COLORS);           </div><div class="line">                              </div><div class="line">     //恢复调色板               </div><div class="line">     if (hOldPal)           </div><div class="line">     &#123;           </div><div class="line">         ::SelectPalette(hDC,     (HPALETTE)hOldPal,     TRUE);           </div><div class="line">         RealizePalette(hDC);           </div><div class="line">         ::ReleaseDC(NULL,hDC);           </div><div class="line">     &#125;           </div><div class="line">      </div><div class="line">     //创建位图文件               </div><div class="line">     fh = CreateFile(FileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,</div><div class="line">                     FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,NULL);           </div><div class="line">                              </div><div class="line">     if(fh == INVALID_HANDLE_VALUE)        </div><div class="line">         return     FALSE;           </div><div class="line">                              </div><div class="line">     //     设置位图文件头           </div><div class="line">     bmfHdr.bfType = 0x4D42;     //     &quot;BM&quot;           </div><div class="line">     dwDIBSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + dwPaletteSize + dwBmBitsSize;               </div><div class="line">     bmfHdr.bfSize = dwDIBSize;           </div><div class="line">     bmfHdr.bfReserved1 = 0;           </div><div class="line">     bmfHdr.bfReserved2 = 0;           </div><div class="line">     bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER) + dwPaletteSize;           </div><div class="line">     //     写入位图文件头           </div><div class="line">     WriteFile(fh,(LPSTR)&amp;bmfHdr,sizeof(BITMAPFILEHEADER),&amp;dwWritten,NULL);           </div><div class="line">     //     写入位图文件其余内容           </div><div class="line">     WriteFile(fh,(LPSTR)lpbi,dwDIBSize,&amp;dwWritten,NULL);           </div><div class="line">     //清除               </div><div class="line">     GlobalUnlock(hDib);           </div><div class="line">     GlobalFree(hDib);           </div><div class="line">     CloseHandle(fh);   </div><div class="line"></div><div class="line">     return     TRUE;       </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">BOOL DrawBitmapFile(HDC hdc, int left, int top, char *szFilename)</div><div class="line">&#123;</div><div class="line">    // 打开要映射的位图文件</div><div class="line">    HANDLE   hFile = CreateFile( szFilename, GENERIC_READ, FILE_SHARE_READ,</div><div class="line">        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL , NULL ) ;</div><div class="line">    if( hFile == INVALID_HANDLE_VALUE )</div><div class="line">        return FALSE ;</div><div class="line"></div><div class="line">    // 创建内存映象对象</div><div class="line">    HANDLE   hMap = CreateFileMapping( hFile , NULL, PAGE_READONLY, NULL, NULL, NULL ) ;</div><div class="line"></div><div class="line">    // 映射整个位图文件到内存，返回内存的首地址</div><div class="line">    LPVOID   lpBase = MapViewOfFile( hMap , FILE_MAP_READ, 0, 0, 0 ) ;</div><div class="line"></div><div class="line">    // 获取BMP文件信息</div><div class="line">    BITMAPFILEHEADER     *pFileHeader ;</div><div class="line">    BITMAPINFO           *pInfoHeader ;</div><div class="line"></div><div class="line">    // 获取位图象素</div><div class="line">    pFileHeader  =  (BITMAPFILEHEADER *) lpBase ;</div><div class="line">    if( pFileHeader-&gt;bfType != MAKEWORD( &apos;B&apos; , &apos;M&apos; ) )</div><div class="line">    &#123;</div><div class="line">        UnmapViewOfFile( lpBase ) ;</div><div class="line">        CloseHandle( hMap ) ;</div><div class="line">        CloseHandle( hFile ) ;</div><div class="line">        return FALSE ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BYTE *pBits = (BYTE *)lpBase + pFileHeader-&gt;bfOffBits ;</div><div class="line"></div><div class="line">    // 获取文件大小</div><div class="line">    pInfoHeader  =  (BITMAPINFO *)( (BYTE *)lpBase + sizeof(BITMAPFILEHEADER) ) ;</div><div class="line">    LONG  width  =  pInfoHeader-&gt;bmiHeader.biHeight ;</div><div class="line">    LONG  height =  pInfoHeader-&gt;bmiHeader.biWidth  ;</div><div class="line"></div><div class="line">    // 显示位图文件至hdc指定的设备</div><div class="line">    HDC        hMemDC   = CreateCompatibleDC( hdc ) ;</div><div class="line">    HBITMAP    hBitmap  = CreateCompatibleBitmap( hdc, width, height ) ;</div><div class="line">    SelectObject( hMemDC, hBitmap ) ;</div><div class="line"></div><div class="line">    // 把图象数据放到建立的内存设备中</div><div class="line">    int nRet = SetDIBitsToDevice( hMemDC, 0, 0, width, height, </div><div class="line">        0, 0, 0, height , pBits, pInfoHeader, DIB_RGB_COLORS ) ;</div><div class="line"></div><div class="line">    // 绘制图象到hdc中</div><div class="line">    BitBlt( hdc, left, top, width, height, hMemDC , 0 , 0, SRCCOPY ) ;</div><div class="line"></div><div class="line">    DeleteObject( hBitmap ) ;</div><div class="line">    UnmapViewOfFile( lpBase ) ;</div><div class="line">    DeleteDC ( hMemDC ) ;</div><div class="line">    CloseHandle( hMap ) ;</div><div class="line">    CloseHandle( hFile ) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/05/24/mem-file/" itemprop="url">
                  内存映射文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-05-24T15:02:00+08:00" content="2008-05-24">
              2008-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/05/24/mem-file/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/05/24/mem-file/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与虚拟内存一样，内存映射文件可以用来保留一个地址空间的区域，并将物理存储器提交给该区域。它们之间的差别是，物理存储器来自一个已经位于磁盘上的文件，而不是系统的页文件。一旦该文件被映射，就可以访问它，就像整个文件已经加载内存一样。</p>
<p><img src="/images/2008-05-24.bmp" alt="内存映射文件"></p>
<p>内存映射文件可以用于3个不同的目的：</p>
<ul>
<li>系统使用内存映射文件，以便加载和执行. e x e和D L L文件。这可以大大节省页文件空间和应用程序启动运行所需的时间。</li>
<li>可以使用内存映射文件来访问磁盘上的数据文件。这使你可以不必对文件执行I / O操作，并且可以不必对文件内容进行缓存。</li>
<li>可以使用内存映射文件，使同一台计算机上运行的多个进程能够相互之间共享数据。Wi n d o w s确实提供了其他一些方法，以便在进程之间进行数据通信，但是这些方法都是使用内存映射文件来实现的，这使得内存映射文件成为单个计算机上的多个进程互相进行通信的最有效的方法。</li>
</ul>
<h3 id="一．内存映射文件的函数包括"><a href="#一．内存映射文件的函数包括" class="headerlink" title="一．内存映射文件的函数包括"></a>一．内存映射文件的函数包括</h3><p>CreateFileMapping , OpenFileMapping, MapViewOfFile, UnmapViewOfFile 和 FlushViewOfFile。</p>
<p>用法如下：</p>
<p>1．</p>
<p>  HANDLE CreateFileMapping(<br>    HANDLE                  hFile,              // 一个文件句柄<br>    LPSECURITY_ATTRIBUTE  lpAttributes,         // 定义内存映射文件对象是否可以被承<br>    DWORD                   flProtect,           // 该内存映射文件的保护类型<br>    DWORD                   dwMaximumSizeHigh,// 内存映射文件的长度<br>    DWORD                   dwMaximumSizeLow, //<br>    LPCTSTR                  lpName             // 内存映射文件的名字<br>  )</p>
<p>  <strong>hFile</strong> 指定要映射的文件的句柄，如果这是一个已经打开的文件的句柄（CreateFile函数的返回值），那么将建立这个文件的内存映射文件，如果这个参数为1，则建立共享内存。<br>  <strong>lpAttribute</strong>  安全属性，一般设为NULL<br>  <strong>flProtect</strong>    指定映射文件的保护类型，它的取值可以是PAGE_READONLY（内存页面只读） 或 PAGE_READWRITE（内存页面可读写）。<br>  <strong>dwMaximumSizeHigh</strong> 和 dwMaximumSizeLow参数组合指定了一个64位的内存映射文件的长度。一种简单的方法是将这两个参数全部设置为0，那么内存映射文件的大小将与磁盘文件大小一致。</p>
<p>2．</p>
<p>  HANDLE OpenFileMapping(<br>      DWORD               dwDesiredAccess,    // 指定保护类型<br>      BOOL                  bIsInheritHandle,     // 返回的句柄是否可以被继承<br>      LPCSTR                lpName             // 创建对象时使用的名字<br>  ）</p>
<p>如果创建的是共享内存，其他进程不能再使用CreateFileMapping函数去创建同名的内存映射文件对象，而要使用OpenFileMapping函数打开已创建好的对象。</p>
<p>  <strong>dwDesiredAcess</strong>   指定保护类型有FILE_MAP_WRITE 或FILE_MAP_READ</p>
<p>3．</p>
<p>  LPVOID  MapViewOfFile(<br>      HANDLE  hFileMappingObject,    // 前两个函数返回的内存映射文件的句柄<br>      DWORD  dwDesiredAcess,      // 保护类型FILE_MAP_READ ,FILE_MAP_WRITE<br>      DWORD  dwFileOffsetHight,     // 从文件的那个地址开始映射<br>      DWORD  dwFileOffsetLow,<br>      SIZE_T   dwNumberOfBytesToMap // 要映射的字节数，为0则映射整个文件<br>  ）</p>
<p>4．</p>
<p>  BOOL  UnmapViewOfFile( LPCVOID  lpBaseAddress )</p>
<p>当不再使用内存映射文件时，可以通过UmmapViewOfFile函数撤销映射并使用CloseHandle函数关闭内存映射文件的句柄。</p>
<p>5．</p>
<p>  BOOL  FlushViewOfFile(<br>       LPCVOID   lpBaseAddress,  // 开始的地址<br>       SIZE_T     dwNumberOfBytesToFlush // 数据块的大小<br>  ）</p>
<p>如果修改了映射视图中的内存，系统会在试图撤销映射或文件映射对象被删除时自动将数据写到磁盘上，但程序也可以根据需要将视图中的数据立即写到磁盘上。</p>
<h3 id="二．使用步骤"><a href="#二．使用步骤" class="headerlink" title="二．使用步骤"></a>二．使用步骤</h3><p>1．  使用CreateFileMapping创建一个内存映射文件内核对象，告诉操作系统内存映射文件需要的物理内存大小，这个步骤决定了内存映射文件的用途――究竟是为磁盘上的文件建立内存映射还是为多个进程共享数据建立共享内存。或者使用OpenFileMapping打开映射文件内核对象。</p>
<p>2．  映射文件映射对象的全部或一部分到进程的地址空间，可以认为该操作是为文件中的内容分配线型地址空间，并将线型地址和文件内容对应起来，完成该操作的函数是MapViewOfFile。</p>
<h3 id="三．使用内存映射文件读文件的具体过程可以这样："><a href="#三．使用内存映射文件读文件的具体过程可以这样：" class="headerlink" title="三．使用内存映射文件读文件的具体过程可以这样："></a>三．使用内存映射文件读文件的具体过程可以这样：</h3><p>（1）调用CreateFile函数打开想要映射的文件，得到文件句柄hFile。</p>
<p>（2）调用CreateFileMapping函数，并传入文件句柄hFile，为该文件创建一个内存映射内核对象，得到内存映射文件的句柄hMap。</p>
<p>（3）调用MapViewOfFile函数映射整个文件或一部分到进程的虚拟地址空间。该函数返回文件映射到内存后的起始地址。使用指向这个地址的指针就可以读取文件的内容了。</p>
<p>（4）调用UnmapViewOfFile函数来解除文件映射。</p>
<p>（5）调用CloseHandle函数关闭文件对象，必须传入内存映射文件句柄hMap</p>
<p>（6）调用CloseHandle函数关闭文件对象，必须传入文件句柄hFile。</p>
<h3 id="四．进程间共享内存："><a href="#四．进程间共享内存：" class="headerlink" title="四．进程间共享内存："></a>四．进程间共享内存：</h3><p>共享内存主要是通过映射机制实现的。Windows下进程的地址空间是相互隔离的，但在物理上却是重叠的。所谓的重叠是指同一块内存区域可能被多个进程同时使用。当调用CreateFileMapping创建命名的内存映射文件对象时，Windows即在物理内存中申请了一块指定大小的内存区域，返回文件映射对象的新句柄hMap。为了能够访问这块区域必须调MapViewOfiFile函数，促使Windows将此内存空间映射到进程的地址空间中。当在其他进程中访问这块区域时，则必须使用OpenFileMapping函数来取得对象句柄hMap，并调用MapViewOfFile函数得到此内存空间的一个映射。这样一来，系统就把同一块内存区域映射到了不同进程的地址空间中，从而达到共享内存的目的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/04/27/LMS-matlab/" itemprop="url">
                  LMS算法MatLab实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-04-27T06:00:00+08:00" content="2008-04-27">
              2008-04-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/课程设计/" itemprop="url" rel="index">
                    <span itemprop="name">课程设计</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/04/27/LMS-matlab/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/04/27/LMS-matlab/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LMS自适应滤波器是使滤波器的输出信号与期望响应之间的误差的均方值为最小，因此称为最小均方（LMS）自适应滤波器。其原理及推导见<a href="http://download.csdn.net/source/432206。" target="_blank" rel="external">http://download.csdn.net/source/432206。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">       </div><div class="line">function [yn,W,en]=LMS(xn,dn,M,mu,itr)</div><div class="line">% LMS(Least Mean Squre)算法</div><div class="line">% 输入参数:</div><div class="line">%     xn   输入的信号序列      (列向量)</div><div class="line">%     dn   所期望的响应序列    (列向量)</div><div class="line">%     M    滤波器的阶数        (标量)</div><div class="line">%     mu   收敛因子(步长)      (标量)     要求大于0,小于xn的相关矩阵最大特征值的倒数    </div><div class="line">%     itr  迭代次数            (标量)     默认为xn的长度,M&lt;itr&lt;length(xn)</div><div class="line">% 输出参数:</div><div class="line">%     W    滤波器的权值矩阵     (矩阵)</div><div class="line">%          大小为M x itr,</div><div class="line">%     en   误差序列(itr x 1)    (列向量)  </div><div class="line">%     yn   实际输出序列             (列向量)</div><div class="line"></div><div class="line">% 参数个数必须为4个或5个</div><div class="line">if nargin == 4                 % 4个时递归迭代的次数为xn的长度 </div><div class="line">    itr = length(xn);</div><div class="line">elseif nargin == 5             % 5个时满足M&lt;itr&lt;length(xn)</div><div class="line">    if itr&gt;length(xn) | itr&lt;M</div><div class="line">        error(&apos;迭代次数过大或过小!&apos;);</div><div class="line">    end</div><div class="line">else</div><div class="line">    error(&apos;请检查输入参数的个数!&apos;);</div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">% 初始化参数</div><div class="line">en = zeros(itr,1);             % 误差序列,en(k)表示第k次迭代时预期输出与实际输入的误差</div><div class="line">W  = zeros(M,itr);             % 每一行代表一个加权参量,每一列代表-次迭代,初始为0</div><div class="line"></div><div class="line">% 迭代计算</div><div class="line">for k = M:itr                  % 第k次迭代</div><div class="line">    x = xn(k:-1:k-M+1);        % 滤波器M个抽头的输入</div><div class="line">    y = W(:,k-1).&apos; * x;        % 滤波器的输出</div><div class="line">    en(k) = dn(k) - y ;        % 第k次迭代的误差</div><div class="line">    </div><div class="line">    % 滤波器权值计算的迭代式</div><div class="line">    W(:,k) = W(:,k-1) + 2*mu*en(k)*x;</div><div class="line">end</div><div class="line"></div><div class="line">% 求最优时滤波器的输出序列</div><div class="line">yn = inf * ones(size(xn));</div><div class="line">for k = M:length(xn)</div><div class="line">    x = xn(k:-1:k-M+1);</div><div class="line">    yn(k) = W(:,end).&apos;* x;</div><div class="line">end</div><div class="line">    </div><div class="line">        LMS函数的一个实例：</div><div class="line">%function main()</div><div class="line">close  all</div><div class="line"></div><div class="line">% 周期信号的产生 </div><div class="line">t=0:99;</div><div class="line">xs=10*sin(0.5*t);</div><div class="line">figure;</div><div class="line">subplot(2,1,1);</div><div class="line">plot(t,xs);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">title(&apos;it&#123;输入周期性信号&#125;&apos;);</div><div class="line"></div><div class="line">% 噪声信号的产生</div><div class="line">randn(&apos;state&apos;,sum(100*clock));</div><div class="line">xn=randn(1,100);</div><div class="line">subplot(2,1,2);</div><div class="line">plot(t,xn);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;随机噪声信号&#125;&apos;);</div><div class="line"></div><div class="line">% 信号滤波</div><div class="line">xn = xs+xn;</div><div class="line">xn = xn.&apos; ;   % 输入信号序列</div><div class="line">dn = xs.&apos; ;   % 预期结果序列</div><div class="line">M  = 20   ;   % 滤波器的阶数</div><div class="line"></div><div class="line">rho_max = max(eig(xn*xn.&apos;));   % 输入信号相关矩阵的最大特征值</div><div class="line">mu = rand()*(1/rho_max)   ;    % 收敛因子 0 &lt; mu &lt; 1/rho</div><div class="line"></div><div class="line">[yn,W,en] = LMS(xn,dn,M,mu);</div><div class="line"></div><div class="line">% 绘制滤波器输入信号</div><div class="line">figure;</div><div class="line">subplot(2,1,1);</div><div class="line">plot(t,xn);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;滤波器输入信号&#125;&apos;);</div><div class="line"></div><div class="line">% 绘制自适应滤波器输出信号</div><div class="line">subplot(2,1,2);</div><div class="line">plot(t,yn);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;自适应滤波器输出信号&#125;&apos;);</div><div class="line"></div><div class="line">% 绘制自适应滤波器输出信号,预期输出信号和两者的误差</div><div class="line">figure </div><div class="line">plot(t,yn,&apos;b&apos;,t,dn,&apos;g&apos;,t,dn-yn,&apos;r&apos;);grid;</div><div class="line">legend(&apos;自适应滤波器输出&apos;,&apos;预期输出&apos;,&apos;误差&apos;);</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;自适应滤波器&#125;&apos;);</div></pre></td></tr></table></figure>
<p>运行后的结果如下：</p>
<p><img src="/images/2008-04-27-1.bmp" alt="LMS"><br><img src="/images/2008-04-27-2.bmp" alt="LMS"><br><img src="/images/2008-04-27-3.bmp" alt="LMS"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="David++" />
          <p class="site-author-name" itemprop="name">David++</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">92</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/david-pp" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/davidpp" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gamelab" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/future_fighter/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David++</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tiny-lab"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>

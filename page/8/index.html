<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="TinyLab" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="TinyLab">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="TinyLab">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TinyLab">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/8/"/>


  <title> TinyLab </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?32177a2b43f11f13565131b8c1239878";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TinyLab</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep eyes on the star and feet on the ground.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/04/linux-module-commands/" itemprop="url">
                  内核模块相关命令：lsmod,depmod,modprob...
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-04T19:06:00+09:00" content="2009-02-04">
              2009-02-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/04/linux-module-commands/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/04/linux-module-commands/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h3><p><strong>功能</strong>：列出内核已载入模块的状态</p>
<p><strong>用法</strong>：lsmod</p>
<p><strong>描述</strong>：</p>
<p>lsmod 以美观的方式列出/proc/modules的内容。输出为：</p>
<pre><code>Module(模块名)    Size(模块大小)   Used by(被...使用)

eg. ne2k_pci           8928               0
8390                 9472              1 ne2k_pci
</code></pre><p>在/proc/modules中相应的是：</p>
<pre><code>(模块名，模块大小，被...使用，模块地址(猜的，以后确认)) 
ne2k_pci 8928 0 - Live 0x3086400
8390 9472 1 ne2k_pci , Live 0xe086000
</code></pre><h3 id="depmod"><a href="#depmod" class="headerlink" title="depmod"></a>depmod</h3><p><strong>功能</strong>：分析可加载模块的依赖性，生成modules.dep文件和映射文件。</p>
<p><strong>用法</strong>：<br>    depmod [-b basedir] [-e] [-F System.map] [-n] [-v] [version] [-A]<br>    depmod [-e] [-F System.map] [-n] [-v] [version] [filename…]</p>
<p><strong>描述</strong>：</p>
<p>Linux内核模块可以为其它模块提供提供服务(在代码中使用EXPORT_SYMBOL)，这种服务被称作”symbols”。若第二个模块使用了这个symbol，则该模块很明显依赖于第一个模块。这些依赖关系是非常繁杂的。</p>
<p>depmod读取在/lib/modules/version 目录下的所有模块，并检查每个模块导出的symbol和需要的symbol，然后创建一个依赖关系列表。默认地，该列表写入到/lib/moudules/version目录下的modules.dep文件中。若命令中的filename有指定的话，则仅检查这些指定的模块(不是很有用)。</p>
<p>若命令中提供了version参数，则会使用version所指定的目录生成依赖，而不是当前内核的版本(uname -r 返回的)。</p>
<p><strong>选项</strong>：</p>
<pre><code>-b basedir  --basedir basedir  若你的模块并没有正确的在/lib/mdules/version下，可以指定目录生成依赖。
-e  --errsyms  和-F选项一起使用，当一个模块需要的symbol在其它模块里面没有提供时，做出报告。正常情况下，模块没有提供的symbol都在内核中有提供。
-F  --filesyms System.map 提供一个System.map文件(在内核编译时生成的)许-e选项报告出unresolved symbol。
-n  --dry_run  将结果modules.dep和各种映射文件输出到标准输出(stdout)，而不是写到模块目录下。
-A --quick  检查是否有模块比modues.dep中的模块新，若没有，则退出不重新生成文件。
</code></pre><h3 id="modprobe"><a href="#modprobe" class="headerlink" title="modprobe"></a>modprobe</h3><p><strong>功能</strong>：Linux内核添加删除模块</p>
<p><strong>用法</strong>：</p>
<pre><code>modprobe [ -v ] [ -V ] [-C config-file] [ -n ] [ -i ] [ -q ] [ -o modulename] [ modulename ] [ module parameters ... ]
modprobe [ -r ] [ -v ] [ -n ] [ -i ] [ modulename ... ]
modprobe [ -l ] [ -t dirname ] [ wildcard ]
modprobe [ -c ]
</code></pre><p><strong>描述</strong>：</p>
<pre><code>modprobe可智能地添加和删除Linux内核模块(为简便起见，模块名中&apos;_&apos;和&apos;-&apos;是一样的)。modprobe会查看模块目录/lib/modules/&apos;uname -r&apos;里面的所有模块和文件，除了可选的/etc/modprobe.conf配置文件和/etc/modprobe.d目录外。

modprobe需要一个最新的modules.dep文件，可以用depmod来生成。该文件列出了每一个模块需要的其他模块，modprobe使用这个去自动添加或删除模块的依赖。
</code></pre><p><strong>选项</strong>：</p>
<pre><code>-v --verbose  显示程序在干什么，通常在出问题的情况下，modprobe才显示信息。
-C --config  重载(^_^,意思取C++的重载)默认配置文件(/etc/modprobe.conf或/etc/modprobe.d)。
-c --showconfig  输出配置文件并退出
-n --dry-run  可以和-v选项一起使用，调试非常有用
-i --ignore-install --ignore-remove 该选项会使得modprobe忽略配置文件中的，在命令行上输入的install和remove命令。
-q --quiet 一般modprobe删除或插入一个模块时，若没有找到会提示错误。使用该选项，会忽略指定的模块，并不提示任何错误信息。
-r --remove  该选项会导致modprobe去删除，而不是插入一个模块。通常没有没有理由去删除内核模块，除非是一些有bug的模块。你的内核也不一定支持模块的卸载。
-V --verssion 版本信息
-f --force  和同时使用--force-vermagic ，--force-modversion一样。使用该选项是比较危险的。
-l --list 列出所有模块
-a --all 插入所有命令行中的模块
-t --type 强制 -l 显示dirname中的模块
-s --syslog 错误信息写入syslog
</code></pre><h3 id="modinfo"><a href="#modinfo" class="headerlink" title="modinfo"></a>modinfo</h3><p><strong>功能</strong>：显示内核模块的信息</p>
<p><strong>用法</strong>：</p>
<pre><code>modinfo [ -0 ] [ -F field] [modulename | filename ... ]
modinfo -V
modinfo -h
</code></pre><p><strong>描述</strong>：</p>
<p>modinfo列出Linux内核中命令行指定的模块的信息。若模块名不是一个文件名，则会在/lib/modules/version 目录中搜索，就像modprobe一样。</p>
<p>modinfo默认情况下，为了便于阅读，以下面的格式列出模块的每个属性：fieldname : value。</p>
<p><strong>选项</strong>：</p>
<pre><code>-V --version 版本
-F --field 仅在一行上显示field值，这对于脚本较为有用。常用的field有：author, description, licence, param, depends, alias, filename。
-0 --NULL 使用&apos;/0&apos;字符分隔field值，而不是一个新行。对脚本比较有用。
-a -d -l -p -n 这些分别是author, description, license, param ,filename的简短形式。
</code></pre><h3 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h3><p><strong>功能</strong>：向Linux内核中插入一个模块</p>
<p><strong>用法</strong>：insmod [filename] [modue options …]</p>
<p><strong>描述</strong>：</p>
<p>insmod是一个向内核插入模块的小程序：若文件名是一个连字符’-‘，模块从标准输入输入。大多数用户使用modprobe，因为它比较智能化。</p>
<h3 id="rmmod"><a href="#rmmod" class="headerlink" title="rmmod"></a>rmmod</h3><p><strong>功能</strong>：删除内核中的一模块</p>
<p><strong>用法</strong>：rmmod [ -f ] [ -w ] [ -s ] [ -v ] [ modulename ]</p>
<p><strong>描述</strong>：</p>
<p>rmmod是一个可以从内核中删除模块的小程序，大多数用户使用modprobe -r去删除模块。</p>
<p><strong>选项</strong>：</p>
<pre><code>-v --verbose  显示程序正在做些什么，一般只显示执行时的错误信息。
-f --force  该选项是非常危险：除非编译内核时，CONFIG_MODULE_FORCE_UNLOAD被设置该命令才有效果，否则没效果。用该选项可以删除正在被使用的模块，设计为不能删除的模块，或者标记为unsafe的模块。
-w --wait 通常，rmmod拒绝删除正在被使用的模块。使用该选项后，指定的模块会被孤立起来，直到不被使用。
-s  --syslog  将错误信息写入syslog，而不是标准错误(stderr)。
-V  --version 版本信息
</code></pre><p>以上内容是参考man翻译的，若有疑问请用man …查看原始文档，翻译有误之处还望见谅。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/02/diary/" itemprop="url">
                  杂想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-02T22:19:00+09:00" content="2009-02-02">
              2009-02-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/心情日记/" itemprop="url" rel="index">
                    <span itemprop="name">心情日记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/02/diary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/02/diary/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>曾几何时，都不曾写过东西了，记得好像是从上大学开始吧！ 以前文笔自认为还是不错的，现在远远不及以前那么有状态了。也许是人心态变了的缘故吧。以前比较单纯，现在比较浮躁；以前敢于幻想美好的东西，每每想到都会感到自己充满了力量和激情，现在想起那些美好的东西，自己就更加痛苦了，因为那些东西根本就不能实现。现在能做的也只能是在这里无病呻吟了，以缅怀逝去的美好！</p>
<p>昨晚拿起《叔本华散文》随便翻翻，看到里面有一篇关于写作的，提到写作有三种：先想后写，边想边写，不想也写。不想也写的是纯粹的文字垃圾；边想边写的无非也是在模仿甚至是抄袭，只是用文字记下当时大脑中的影像，很难有新东西；先想后写的东西才是有意义的，因为写作的目的是记录下经过系统思考的东西，所以逻辑比较明晰。他说的应该是比较学术的哪一类写作吧！我想我的就属于他说的不想也写，带有点边想边写。不管了，反正是想到哪里写到哪里了。</p>
<p>不过说实话，只要提起笔写东西，大脑里面高中时候的场景挥都挥不去。年少轻狂的年代，任何人和事都不往眼里放，人与人之间的关系也比较简单，生活目的也比较单纯！一切都是那么简单！口里之乎者也，也偶尔可以文绉绉酸一下。没事写写诗，虽然很烂，但至少是自己真实的内心写照，聊以自慰！虽然知识学的不是很深，但还是敢于和朋友一起谈天说地，乾坤宇宙，尘埃微粒无所不及。记得高中一直自己给自己写的一句话，很老套，但是在那个年代一直铭刻在心：追求卓越，雕琢世界。话虽俗套，但对自己来说确意味深长！当时的想法：追求卓越指的是人要不断提高自身以达到比较高的境界，雕琢世界强调的是人的主观能动性，去改造世界，去探求真知，去揭开“上帝的面纱”。合起来的意思也就很明白了。现在想想都觉得惭愧难当，世界没有“雕琢”成，却被世界“雕琢”成现在这样了。毫无激情，简直活着就是做一天和尚撞一天钟一样。重复，重复，无尽的重复着。痛苦，痛苦，无尽的痛苦。…</p>
<p>一直在学知识，但感觉那些始终不是自己的，甚至就是纯粹的记忆过程。面对浩瀚学海，真是有点无所适从了。可能是高中时候养成的学习习惯吧，凡事都要追根问底，非要从最底层理解起。往往追根的时候又会碰到许多新知识，然后又去追根，结果是忙于寻找问题和解决问题的方法，而真正的问题的系统的解决方法到最后也毫无头绪。弄的自己头昏脑胀，迷茫一片。（边想边写吧，一直在回味高中时代，现在却成为给自己找毛病了，那就继续找把，总结下，以后也好慢慢改正）。上面的也不能算是一个毛病，只是方法用错了对象，以后可要注意了。我以前是学物理的，物理的目标也就是从最表面的，最常见的事物入手，探求深层次的，本质的问题所在，属于理论型的，深层理解的越深说明对于物理掌握的越透彻。现在是干软件的，工程型的，快速达到目标，能重用的尽可能重用，不必深层理解系统低层，只要会用系统接口就一切搞定（当然这里的系统低层是比较稳定的，经过时间证明的），而我经常犯傻，有时一个API，非要找到它的实现不可，甚至深入到操作系统庞大的代码中去获取答案。结果大量时间被浪费，还把自己的头弄的比斗大。同时也可以反映出：科学的目标是提出问题和解决问题的方法，工程的目标是实现问题，解决问题（不择手段^_^)；科学的精神是怀疑一切，不惜推翻重来，工程的精神是尽最大可能重用，不发明已有的车轮，甚至懒于改造。可能理解有误，不过说出的是自己的想法。</p>
<p>想想自己的毛病还真不少啊，实在是惭愧啊！朝秦暮楚算一个，大学期间专业是换了又换，从电子信息工程专业到LCD（电子科学与技术），一直和物理相关，但课程内容却完全不同，一个偏向与通信（工程型的），一个偏向与材料物理（理论型的），期间还一心自学理论物理，准备考研。自从大一第二学期接触C语言开始，同时迷上编程，喜欢那种主宰一切的感觉，所以计算机专业的课程也都基本上自学完成。就这样物理与编程一直是大学生活中的全部。碍于世俗，毕业时放弃了物理，选择了进入软件行业。开启了痛苦之旅！生活失去了原动力，不断审视生活的目的，往往毫无结果，更加痛苦！加之各种长大成人的烦恼迎面而来，苦不堪言！既想轰轰烈烈又想平平淡淡，处于一个极度浮躁状态！ 呵呵，算是花心，罪有应得！</p>
<p>毛病就不想了，今天本来就有点不爽，什么都不想干，所以才在这里写。越想越不爽了，毛病以后得改，生活还得继续，以后多总结，自己的想法记录下来。就此打住！继续学习…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/11/20/cstdarg/" itemprop="url">
                  函数参数不确定时用cstdarg(stdarg.h)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-11-20T00:05:00+09:00" content="2008-11-20">
              2008-11-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/11/20/cstdarg/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/11/20/cstdarg/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func( Type para1, Type para2, Type para3, ... )</div><div class="line">&#123;</div><div class="line">      /****** Step 1 ******/</div><div class="line">      va_list ap;</div><div class="line">      va_start( ap, para3 ); //一定要“...”之前的那个参数</div><div class="line">    </div><div class="line">      /****** Step 2 ******/</div><div class="line">      //此时ap指向第一个可变参数</div><div class="line">      //调用va_arg取得里面的值</div><div class="line">    </div><div class="line">      Type xx = va_arg( ap, Type ); </div><div class="line">    </div><div class="line">      //Type一定要相同，如:</div><div class="line">      //char *p = va_arg( ap, char *);</div><div class="line">      //int i = va_arg( ap, int );</div><div class="line">      //如果有多个参数继续调用va_arg</div><div class="line">      /****** Step 3 ******/</div><div class="line">      va_end(ap); //For robust!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">typedef char *    va_list;</div><div class="line">#define va_start _crt_va_start</div><div class="line">#define va_arg _crt_va_arg</div><div class="line">#define va_end _crt_va_end</div><div class="line">#define _crt_va_start(ap,v)    ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )</div><div class="line">#define _crt_va_arg(ap,t)      ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )</div><div class="line">#define _crt_va_end(ap)        ( ap = (va_list)0 ) </div><div class="line">va_list argptr;</div></pre></td></tr></table></figure>
<p>C语言的函数是从右向左压入堆栈的,调用va_start后，按定义的宏运算，_ADDRESSOF得到v所在的地址，然后这个地址加上v的大小，则使ap指向第一个可变参数如图:     </p>
<pre><code>栈底 高地址
| .......     
| 函数返回地址
| .......      
| 函数最后一个参数
| ....                       
| 函数第一个可变参数       &lt;--va_start后ap指向 
| 函数最后一个固定参数
| 函数第一个固定参数 
栈顶 低地址
</code></pre><p>然后，用va_arg()取得类型t的可变参数值, 先是让ap指向下一个参数:</p>
<pre><code>ap += _INTSIZEOF(t)
</code></pre><p>然后在减去_INTSIZEOF(t)，使得表达式结果为ap之前的值，即当前需要得到的参数的地址，强制转换成指向此参数的类型的指针，然后用*取值最后，用va_end(ap)，给ap初始化，保持健壮性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include    &lt;stdio.h&gt;   </div><div class="line">#include    &lt;ctype.h&gt;   </div><div class="line">#include&lt;stdlib.h&gt;   </div><div class="line">#include    &lt;stdarg.h&gt;   </div><div class="line"></div><div class="line">int    average(    int    first,    ...    )      //变参数函数,C++里也有   </div><div class="line">&#123;   </div><div class="line">     int    count=0,i=first,sum=0;   </div><div class="line">     va_list    maker;            //va_list    类型数据可以保存函数的所有参数,做为一个列表一样保存   </div><div class="line">     va_start(maker,first);    //设置列表的起始位置   </div><div class="line">     while(i!=-1)   </div><div class="line">     &#123;   </div><div class="line">     sum+=i;   </div><div class="line">     count++;   </div><div class="line">     i=va_arg(maker,int);//返回maker列表的当前值,并指向列表的下一个位置   </div><div class="line">     &#125;   </div><div class="line">     return    sum/count;   </div><div class="line">      </div><div class="line">&#125;   </div><div class="line"></div><div class="line">void main(void)   </div><div class="line">&#123;   </div><div class="line">		printf(&quot;Average    is:    %d/n&quot;,    average(    2,    3,    4,4,    -1    )    );   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Linux下的stdarg.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#ifndef _STDARG_H</div><div class="line">#define _STDARG_H</div><div class="line"></div><div class="line">typedef char *va_list; /* 定义va_list 是一个字符指针类型*/</div><div class="line"></div><div class="line">/* Amount of space required in an argument list for an arg of type TYPE.</div><div class="line">TYPE may alternatively be an expression whose type is used. */</div><div class="line">/* 下面给出了类型为TYPE 的arg 参数列表所要求的空间容量。</div><div class="line">TYPE 也可以是使用该类型的一个表达式 */</div><div class="line"></div><div class="line">// 下面这句定义了取整后的TYPE 类型的字节长度值。是int 长度(4)的倍数。</div><div class="line">#define __va_rounded_size(TYPE) /</div><div class="line">(((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</div><div class="line"></div><div class="line">// 下面这个函数（用宏实现）使AP 指向传给函数的可变参数表的第一个参数。</div><div class="line">// 在第一次调用va_arg 或va_end 之前，必须首先调用该函数。</div><div class="line">// 17 行上的__builtin_saveregs()是在gcc 的库程序libgcc2.c 中定义的，用于保存寄存器。</div><div class="line">// 它的说明可参见gcc 手册章节“Target Description Macros”中的</div><div class="line">// “Implementing the Varargs Macros”小节。</div><div class="line">#ifndef __sparc__</div><div class="line">#define va_start(AP, LASTARG) /</div><div class="line">(AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))</div><div class="line">#else</div><div class="line">#define va_start(AP, LASTARG) /</div><div class="line">(__builtin_saveregs (), /</div><div class="line">AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))</div><div class="line">#endif</div><div class="line"></div><div class="line">// 下面该宏用于被调用函数完成一次正常返回。va_end 可以修改AP 使其在重新调用</div><div class="line">// va_start 之前不能被使用。va_end 必须在va_arg 读完所有的参数后再被调用。</div><div class="line">void va_end (va_list); /* Defined in gnulib *//* 在gnulib 中定义 */</div><div class="line">#define va_end(AP)</div><div class="line"></div><div class="line">// 下面该宏用于扩展表达式使其与下一个被传递参数具有相同的类型和值。</div><div class="line">// 对于缺省值，va_arg 可以用字符、无符号字符和浮点类型。</div><div class="line">// 在第一次使用va_arg 时，它返回表中的第一个参数，后续的每次调用都将返回表中的</div><div class="line">// 下一个参数。这是通过先访问AP，然后把它增加以指向下一项来实现的。</div><div class="line">// va_arg 使用TYPE 来完成访问和定位下一项，每调用一次va_arg，它就修改AP 以指示</div><div class="line">// 表中的下一参数。</div><div class="line">#define va_arg(AP, TYPE) /</div><div class="line">(AP += __va_rounded_size (TYPE), /</div><div class="line">*((TYPE *) (AP - __va_rounded_size (TYPE))))</div><div class="line"></div><div class="line">#endif /* _STDARG_H */</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/09/26/string-match-algorithm/" itemprop="url">
                  字符串匹配之朴素算法和通配符扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-09-26T22:19:00+09:00" content="2008-09-26">
              2008-09-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/09/26/string-match-algorithm/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/09/26/string-match-algorithm/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p><strong>问题</strong>：给定一个T[1..n],P[1..m] ,T和P中的任意元素属于∑（有限的字符集合），求位移s使得 T[s+1..s+m] = P[1..m].  T 代表 Text(文本串), P代表 Pattern(匹配串)。</p>
<p>有多种算法可以实现,这里只介绍最简单,最容易理解,”最笨的” 朴素匹配算法:</p>
<pre><code>T：t1 t2 ….tn
P：p1 p2..pm
其中（m&lt;=n）
</code></pre><p>最容易想到的就是让P在T上一个字符一个字符的向右滑动，然后比较T的某一段时候和P想匹配，若不匹配，继续向右滑动；否则匹配成功。这样效率比较低，最坏情况下复杂度为theta((n-m+1)*m)。伪代码如下：</p>
<pre><code>n &lt;- length[T]
m &lt;- lengthp[P]
for s=0 to n-m
     if T[s+1…s+m] = P[1…m]
           匹配成功，输出s，若只匹配第一个，则可在此退出循环。
     else
           继续匹配
</code></pre><p>对于有限的字符集下（假设个数为d），若果T和P中的字符都随机出现，则平均比较次数为（n-m+1）*(1-d^-m)/(1-d^-1) &lt;= 2(n-m+1)。呵呵,这样看来这个“笨”的算法还算可以，不算很“笨”。</p>
<p>下面给出一种用回溯方法写的代码：（和strstr函数功能相同）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int index(const char * str1, const char * str2, size_t pos)</div><div class="line">&#123;</div><div class="line">       size_t i = pos;</div><div class="line">       size_t j = 0;</div><div class="line">       while(i &lt; strlen(str1) &amp;&amp; j &lt; strlen(str2))</div><div class="line">       &#123;</div><div class="line">               if(str1[i] ==  str2[j]) // matched then continue</div><div class="line">               &#123;</div><div class="line">                          ++i;</div><div class="line">                          ++j;</div><div class="line">               &#125;</div><div class="line">               else     // unmatched then backtrace</div><div class="line">               &#123;</div><div class="line">                   i = i - j + 1;</div><div class="line">                   j = 0;</div><div class="line">               &#125;</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       if(j &gt;= strlen(str2))  // matched and return the index</div><div class="line">            return i-strlen(str2);</div><div class="line">       else</div><div class="line">            return -1;  // not found</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个例子就一清二楚了。</p>
<pre><code>T =aababcd
P =abc
</code></pre><p>第1次：<br>    a a b a b c d<br>    a</p>
<p>匹配成功,继续下个字符的匹配，第2次：</p>
<pre><code>a a b a b c d
a b
</code></pre><p>匹配失败，回溯，进行第3次：</p>
<pre><code>a a b a b c d
- a
</code></pre><p>匹配成功，继续….</p>
<p>归纳下看：</p>
<p>第m次：</p>
<p>先假设数组开始的下标为0。</p>
<pre><code>T=O O …O O O O O O O
P=      O O O O …
</code></pre><p>与P的第一个字符的下标为0，正在匹配的下标为j，此时与P[j]匹配的T的下标是i。</p>
<p>1）  若P[j]与T[i]匹配，则继续下一个字符的匹配，i++，j++。</p>
<p>2）  若P[j]与T[i]失配,  则T的下标回溯到i-j+1,P重新开始（j=0）。</p>
<p>若数组下标不是以0开始的，而是以一开始的，只需回溯到i=i-j+2，j=1即可。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>加入匹配字符串中有通配符*，？。</p>
<p>可以匹配多个字符，多个连接在一起的<em>可以认为是一个，而?只能通配一个字符。则算法可以改进为：<br>当P[j]是’</em>’时，求T与P[j+1]</p>
<p>匹配的第一个字符所在的下标，T的下标置为此值。然后继续循环。哈哈，语言描述能力不行啊，还是直接看代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line"> *decrip:match the string(&apos;*&apos; and &apos;?&apos; not included) with pattern including *(se</div><div class="line"> *        veral),?(only one)</div><div class="line"> *input:</div><div class="line"> *    T  --  text </div><div class="line"> *    P  --  Pattern</div><div class="line"> *return:</div><div class="line"> *     true for exit ,false for not</div><div class="line"> *     start,end -- the index of the pattern found in the text </div><div class="line"> */</div><div class="line">bool match(const char* T, const char* P, int&amp; start, int&amp; end)</div><div class="line">&#123;</div><div class="line">    size_t i = 0;</div><div class="line">    size_t j =0;</div><div class="line">    size_t n = strlen(T);</div><div class="line">    size_t m = strlen(P);</div><div class="line">    bool bStart = true;</div><div class="line">    while(i &lt; n &amp;&amp; j &lt; m)</div><div class="line">    &#123;</div><div class="line">            if(P[j] == &apos;*&apos;)   // wildcard ,then find the first position matched with next character </div><div class="line">            &#123;</div><div class="line">                    ++j;</div><div class="line">                    while(&apos;*&apos; == P[j]) // &quot;***..*&quot; &lt;=&gt; &quot;*&quot;</div><div class="line">                               ++j;</div><div class="line">                    while(T[i] != P[j])</div><div class="line">                               ++i;</div><div class="line">                    if(i &gt;= n) // finished, no matter matched or not</div><div class="line">                         break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if(T[i] == P[j] || &apos;?&apos; == P[j])</div><div class="line">            &#123;</div><div class="line">                    if(bStart) // new loop start</div><div class="line">                    &#123;</div><div class="line">                              start = i;</div><div class="line">                              bStart = false;</div><div class="line">                    &#125;</div><div class="line">                    ++i;</div><div class="line">                    ++j;</div><div class="line">                    </div><div class="line">                    if(j == m) // match finish</div><div class="line">                         end = i-1;</div><div class="line">            &#125;</div><div class="line">            else  // unmatched ,then backtrace(start a new loop)</div><div class="line">            &#123;</div><div class="line">                static size_t ipp = 0;</div><div class="line">                ++ipp;</div><div class="line">                i = ipp;</div><div class="line">                j = 0;</div><div class="line">                bStart = true;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if(j &gt;= m)  // succeeded to find the pattern</div><div class="line">    &#123;</div><div class="line">         if( &apos;*&apos; == P[0])   // postfix</div><div class="line">             start = 0;</div><div class="line">         if( &apos;*&apos; == P[m-1]) // prefix</div><div class="line">             end = n-1;</div><div class="line">         return true;</div><div class="line">    &#125;</div><div class="line">    else  </div><div class="line">        return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol>
<li>以上内容，朴素算法伪代码参考《算法导论》。</li>
<li>回溯程序是看了一位网上哥们的伪代码写的。</li>
<li>通配符扩展是参考1），2），自己分析写的。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/06/11/main-windows-handle/" itemprop="url">
                  已知进程句柄，如何知道此进程的主窗口句柄
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-06-11T14:06:00+09:00" content="2008-06-11">
              2008-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/06/11/main-windows-handle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/06/11/main-windows-handle/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>已知进程句柄，如何知道此进程的主窗口句柄,在此说明两种方法:</p>
<ol>
<li>调用FindWindow(),前提是必须知道该进程中窗口类名和窗口名,返回后的句柄可以通过IsWindow()函数来验证是否是有效的窗口句柄.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">HWND hWnd = ::FindWindow(szClassName, szWndName);  </div><div class="line">if(::IsWindow(hWnd))  </div><div class="line">&#123;  </div><div class="line">      //  处理该窗口  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.先枚举全部窗口,再枚举回调函数中调用GetWindowThreadProcessID()得到窗口得进程ID,再与以前得到得ID比较.如果不一致,不处理,若一致,循环调用GetParent()一直到返回NULL, 最后得hwnd即为顶层窗口句柄</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">BOOL   CALLBACK   EnumWindowsProc(HWND   hwnd,       LPARAM   lParam   )     </div><div class="line"> &#123;     </div><div class="line">     unsigned   long   id;     </div><div class="line">      HWND   thwnd;     </div><div class="line">     </div><div class="line">      id=GetWindowThreadProcessId(hwnd,NULL);     </div><div class="line">      if   (id==lParam)     </div><div class="line">     &#123;     </div><div class="line">            while((thwnd=GetParent(hwnd))!=NULL)     </div><div class="line">                  hwnd=thwnd;     </div><div class="line">            CString   x;     </div><div class="line">            x.Format(&quot;HWND   =   %x&quot;,hwnd);     </div><div class="line">            MessageBox(NULL,x,NULL,MB_OK);     </div><div class="line">            return   false;       </div><div class="line">      &#125;     </div><div class="line">      return   true;     </div><div class="line"> &#125;     </div><div class="line">       </div><div class="line">     </div><div class="line"> void   CMt2Dlg::OnButton1()       </div><div class="line"> &#123;     </div><div class="line"> //   TODO:   Add   your   control   notification   handler   code   here     </div><div class="line">   STARTUPINFO   StartInfo;     </div><div class="line">   PROCESS_INFORMATION     ProceInfo;     </div><div class="line">   ZeroMemory(&amp;StartInfo,sizeof(StartInfo));     </div><div class="line">   StartInfo.cb=sizeof(StartInfo);     </div><div class="line">     </div><div class="line">   CreateProcess(NULL,   //lpApplicationName:   PChar     </div><div class="line">         &quot;calc.exe&quot;,   //lpCommandLine:   PChar     </div><div class="line">         NULL,   //lpProcessAttributes:   PSecurityAttributes     </div><div class="line">         NULL,   //lpThreadAttributes:   PSecurityAttributes     </div><div class="line">         true,   //bInheritHandles:   BOOL     </div><div class="line">         CREATE_NEW_CONSOLE,     </div><div class="line">         NULL,     </div><div class="line">        NULL,     </div><div class="line">         &amp;StartInfo,     </div><div class="line">         &amp;ProceInfo);     </div><div class="line">     </div><div class="line">   Sleep(100);     //这是必须的,因为   CreateProcess   不能马上Active   windows     </div><div class="line">   EnumWindows(EnumWindowsProc,ProceInfo.dwThreadId);     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/06/06/chart-class/" itemprop="url">
                  一个用于显示数值曲线的类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-06-06T03:50:00+09:00" content="2008-06-06">
              2008-06-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/06/06/chart-class/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/06/06/chart-class/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做一个课题，要显示几条数值曲线。不过不想借助其它控件，或其它公司提供的开发包，如MATCOM，用这些的话就太简单不过了。下面是一个自己设计的一个类，用API堆的，这样既可以在基于SDK应用开发应用，又可以在MFC框架中应用。下面几个图是测试时截的。在此声明一下，我是一新手，难免设计的不合理甚至错误百出，敬请见谅！点此下载源代码和示例代码(<a href="http://download.csdn.net/detail/future_fighter/485567)。" target="_blank" rel="external">http://download.csdn.net/detail/future_fighter/485567)。</a></p>
<p><img src="/images/2008-06-06-1.JPG" alt="显示多条曲线"></p>
<p>图1  显示多条曲线</p>
<p><img src="/images/2008-06-06-2.JPG" alt="显示坐标提示"></p>
<p>图2 显示坐标提示</p>
<p><img src="/images/2008-06-06-3.JPG" alt="坐标系显示范围缩放"></p>
<p>图3 坐标系显示范围缩放</p>
<p>类名为CChart，其基类为CChartBase。CChartBase主要用于显示，设置坐标系的一些属性，比如x，y轴可以显示的范围、坐标系边框颜色、背景颜色等；而CChart则用于显示坐标系和多条曲线，曲线颜色、线宽、等凡是可见的属性都可以设定。用法如下：</p>
<p>1． 将DispChart.h和DispChart.cpp包含至用使用该类的Project中，若为基于MFC项目，则在DispChart.cpp中添加#include ”stdafx.h”。</p>
<p>2． 定义一个该类的变量，CChart chart(hWnd); hWnd是该坐标所在窗口的句柄。</p>
<p>3． （可选）设置相应的属性。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">chart.SetGridColor(RGB(255,0,0));    // 设置网格颜色  </div><div class="line">chart.SetGriddx(10);                 // 设置网格x轴间隔  </div><div class="line">chart.SetClrLabel(RGB(0,0,255));     // 标尺颜色  </div><div class="line">chart.SetXLabel(&quot;t/min&quot;);            // 轴标文字  </div><div class="line">chart.SetYLabel(&quot;V/v&quot;);  </div><div class="line">chart.SetRulerXFormat(&quot;%.2f&quot;);       // x轴标尺显示精度  </div><div class="line">chart.SetGriddy( 0.01);  </div><div class="line">chart.SetXRange( 0, 100);            // x轴可以显示的范围  </div><div class="line">chart.SetYRange( -5, 5);</div></pre></td></tr></table></figure>
<p>4． 添加曲线数据连接，曲线数据必须是vector<double>型的。如：</double></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   std::vector&lt;double&gt; data[3];</div><div class="line">   int length = 1000;</div><div class="line">   double amp = 5;</div><div class="line">   for(int i=0;i&lt;length;i++)</div><div class="line">   &#123;</div><div class="line">    double t = (20 * 3.1415926 / length) * i;</div><div class="line">    double y1 = amp*sin(t);</div><div class="line">    double y2 = (amp/2)*cos(t);</div><div class="line">    data[0].push_back(t);</div><div class="line">    data[1].push_back(y1);</div><div class="line">    data[2].push_back(y2);</div><div class="line">   &#125;</div><div class="line">   chart.AddMCurves(data,3);</div><div class="line">   chart.SetCurveColor(0,RGB(0,0,0));</div><div class="line">```   </div><div class="line"></div><div class="line"> </div><div class="line">5． 在WM_PAINT消息或其它地方绘制曲线。先设置显示在那个位置，然后绘制。</div></pre></td></tr></table></figure>
<p>case WM_PAINT:<br>        hdc = BeginPaint(hWnd, &amp;ps);<br>        // TODO: 在此添加任意绘图代码..<br>        RECT rect;<br>        GetClientRect(hWnd,&amp;rect);  </p>
<pre><code>chart.SetChartDC(hdc);  

chart.SetChartAndWindowPosition(rect);  

 chart.ShowCurves();  

EndPaint(hWnd, &amp;ps);  
break;  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">6． （可选）若要动态缩放、平移、左键点击显示坐标提示窗口、右键框选缩放，则只需在相应的消息处理处添加相关操作即可。注意：由于我是用该类绘制周期性的曲线的，所以平移和缩放只是x轴的；若要同时平移或缩放，在CChart::OnMouseWheel函数中将ScaleX改变为ScaleCenter即可以完成x，y轴同时缩放，在CChart::OnMouseMove函数中修改Move的第二参数为-(y - m_ptLeftButtonDown.y) * GetYPerPix()即可以完成x，y轴同时移动。</div></pre></td></tr></table></figure>
<p>if( m_ptLeftButtonDown.x != -1)<br>{<br> Move( -(x - m_ptLeftButtonDown.x) <em> GetXPerPix() , -(y - m_ptLeftButtonDown.y) </em> GetYPerPix());</p>
<p> m_ptLeftButtonDown.x = x;<br> m_ptLeftButtonDown.y = y;</p>
<p>// 绘制曲线和坐标系<br> ShowCurves();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">示例代码：</div></pre></td></tr></table></figure></p>
<p>case WM_LBUTTONDOWN:  </p>
<pre><code>    chart.OnLeftButtonDown(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_LBUTTONUP:  
    chart.OnLeftButtonUp(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_RBUTTONDOWN:  
    chart.OnRightButtonDown(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_RBUTTONUP:  
    chart.OnRightButtonUp(LOWORD(lParam), HIWORD(lParam));  
    break;  
case WM_MOUSEMOVE:  
    chart.OnMouseMove(LOWORD(lParam), HIWORD(lParam));  
    break;  
case 0x020A/*WM_MOUSEWHEEL*/:  
    {  
        POINT pt = { LOWORD(lParam), HIWORD(lParam) };  
        ScreenToClient( hWnd,&amp;pt );  
        chart.OnMouseWheel(wParam, pt.x, pt.y);  
    }  
    break;  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>#ifndef _DISPCHART_H  </p>
<p>#define _DISPCHART_H  </p>
<p>#include <windows.h></windows.h>  </p>
<p>#include <vector></vector>  </p>
<p>#include <string></string>  </p>
<p>// 图表基类:用于绘制坐标系和曲线<br>class CChartBase<br>{<br>protected:<br>    HDC       m_hChartDC;       // 图表绘制的DC<br>    RECT      m_rtWindow;       // 坐标窗口,其中包含图表显示区和坐标标尺,轴标等<br>    RECT      m_rtChart;        // 图标显示区(依赖域m_rtWindow)  </p>
<pre><code>// 坐标显示边界  
double    m_xStart;         // 实数域内x轴起点  
double    m_xEnd;           //         x轴终点  
double    m_yStart;         //         y轴起点  
double    m_yEnd;           //         y轴终点  

// 显示图表区  
COLORREF  m_clrChartBg;     // 显示区背景色  
COLORREF  m_clrChartBorder; //       边框色  

// 网格  
bool      m_bGridOn;        // 控制网格是否显示  
double    m_dxGrid;         // 网格单元宽  
double    m_dyGrid;         // 网格单元高  
COLORREF  m_clrGrid;        // 网格线颜色  

// 坐标轴,轴标,标尺  
char      m_xLabel[20];  
char      m_yLabel[20];  
bool      m_bxLabelOn;   
bool      m_byLabelOn;  

bool      m_bxRulerOn;  
bool      m_byRulerOn;  
char      m_szRulerXFormat[128];  
char      m_szRulerYFormat[128];  

COLORREF  m_clrLabel;      // 轴标文字和刻度文字颜色  

// 文字字体  
LOGFONT     m_logFont;  

// 曲线数据  
</code></pre><p>public:  </p>
<pre><code>// 辅助函数  
void SetChartDC(HDC hdc);  
HDC  GetChartDC() const ;  
void SetChartWindowPosition(RECT rect);  
void SetChartWindowPosition(int left, int top, int right, int bottom);  
RECT GetChartWindowPosition() const;  
void SetChartPosition(RECT rect);  
void SetChartPosition(int left, int top, int right, int bottom);  

RECT GetChartPosition() const;  
int  GetChartWidth()const  { return m_rtChart.right - m_rtChart.left ; };  
int  GetChartHeight()const { return m_rtChart.bottom - m_rtChart.top ; };  
int  GetChartWindowWidth() const { return m_rtWindow.right - m_rtWindow.left; };  
int  GetChartWindowHeight() const{ return m_rtWindow.bottom - m_rtWindow.top; };  

// 坐标显示边界  
double SetXStart(double xStart);  
double SetXEnd(double xEnd);  
void   SetXRange(double xStart,double xEnd);  
double SetYStart(double yStart);  
double SetYEnd(double yEnd);  
void   SetYRange(double yStart,double yEnd);  
double GetXStart()const;  
double GetXEnd()const;  
double GetYStart()const;  
double GetYEnd()const;  

// 显示图表区  
void      SetClrChartBg(COLORREF clr);  
COLORREF  GetClrChartGb()const;  
void      SetClrChartBorder(COLORREF clr);  
COLORREF  GetClrChartBorder()const;  

// 网格  
double   SetGriddx(double dxGrid);              // 设置网格宽度,返回前一个值  
double   SetGriddy(double dyGrid);              // 设置网格高度,返回前一个值  
void     SetGridxy(double dxGrid,double dyGrid);  
COLORREF SetGridColor(COLORREF color);          // 设置网格颜色,返回前一个值  
void SetGridOn();                               // 设置网格为显示状态  
void SetGridOff();                              // 设置网格为关闭状态  

double   GetGriddx()const;  
double   GetGriddy()const;  
COLORREF GetGridColor()const;  
bool     GetGridStatus()const;  

// 坐标轴,轴标,标尺  
void    SetXLabel(const char* xLabel);  
void    SetYLabel(const char* yLabel);  
void    SetXLabelOn();  
void    SetXLabelOff();  
BOOL    GetXLabelStatus()const;  
void    SetYLabelOn();  
void    SetYLabelOff();  
BOOL    GetYLabelStatus()const;  

void    SetXRulerOn();  
void    SetXRulerOff();  
BOOL    GetXRulerStatus()const;  
void    SetYRulerOn();  
void    SetYRulerOff();  
BOOL    GetYRulerStatus()const;  

void    SetRulerXFormat(const char str[]) { strcpy(m_szRulerXFormat, str);};  
void    SetRulerYFormat(const char str[]) { strcpy(m_szRulerXFormat, str);};  

void     SetClrLabel(COLORREF clr);  
COLORREF GetClrLabel()const;  

// 字体  
void    SetLogFont(LOGFONT logFont);  
LOGFONT GetLogFont()const;  


// 每一个象素所代表的实数值  
double GetYPerPix() const;  
double GetXPerPix() const;  
</code></pre><p>protected:<br>    int  ShowChartBg();<br>    int  ShowGrid();<br>    int  ShowRuler();<br>    int  ShowLabel();  </p>
<p>public:<br>    CChartBase();<br>    ~CChartBase();  </p>
<pre><code>int ShowAt(int left, int top, int right, int bottom); // 在rect中显示该图标窗口,外部最好用该函数  
int ShowAt(RECT rect);  
int Show();                                           // 通过设置各种参数显示  

// 坐标转换 r--real  s--screen 2--to  
int rx2sx(double rx);    
int ry2sy(double ry);  
double sx2rx(int sx);  
double sy2ry(int sy);  

// 坐标变换  
void Move(double drx, double dry);                   // 坐标系平移  
void ScaleCenter(double times);                      // 坐标以坐标框的中心放缩  
                                                     // times&gt;1时,显示范围扩大,起到缩小的作用  
                                                     // times&lt;1时,显示范围缩小,起到放大的作用  
void ScaleX(double times);                           // X轴范围缩放（以x轴中心）  
void ScaleY(double times);                           // Y轴范围缩放（以y轴中心）  
</code></pre><p>};  </p>
<p>class CChart:public CChartBase<br>{<br>private:<br>    HWND       m_hWnd;           // 图表所在的窗口，该窗口可以处理消息（用于实现坐标变换等）<br>    HDC        m_memDCWindow;    // 存储整个绘图窗用的内存句柄<br>    HBITMAP    m_bmpInDCWindow;<br>    HDC        m_memDCChart;     // 存储chart的内存设备句柄<br>    HBITMAP    m_bmpInDCChart;   // 图表所对应的位图句柄  </p>
<pre><code>// 曲线数据  
</code></pre><p>public:  </p>
<pre><code>std::vector  
</code></pre><p>``` </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/05/24/bitmap-open-save/" itemprop="url">
                  位图文件的打开和保存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-05-24T16:12:00+09:00" content="2008-05-24">
              2008-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/05/24/bitmap-open-save/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/05/24/bitmap-open-save/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面是两个函数， SaveBmp函数用于设备相关位图(DIB)保存为bmp格式的文件。DrawBitmapFile则用于将bmp格式的文件打开并显示在指定的设备环境上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BOOL SaveBmp(HBITMAP hBitmap, const char *FileName)</div><div class="line">&#123;</div><div class="line">     HDC     hDC;       </div><div class="line">     //当前分辨率下每象素所占字节数       </div><div class="line">     int     iBits;       </div><div class="line">     //位图中每象素所占字节数       </div><div class="line">     WORD    wBitCount;       </div><div class="line">    //定义调色板大小，位图中像素字节大小，位图文件大小，写入文件字节数   </div><div class="line">     DWORD   dwPaletteSize=0,dwBmBitsSize=0, dwDIBSize=0, dwWritten=0;           </div><div class="line">     //位图属性结构           </div><div class="line">     BITMAP  Bitmap;               </div><div class="line">     //位图文件头结构       </div><div class="line">     BITMAPFILEHEADER   bmfHdr;               </div><div class="line">     //位图信息头结构           </div><div class="line">     BITMAPINFOHEADER   bi;               </div><div class="line">     //指向位图信息头结构               </div><div class="line">     LPBITMAPINFOHEADER lpbi;               </div><div class="line">     //定义文件，分配内存句柄，调色板句柄           </div><div class="line">     HANDLE  fh,hDib,hPal,hOldPal=NULL;           </div><div class="line">                              </div><div class="line">     //计算位图文件每个像素所占字节数           </div><div class="line">     hDC=::CreateDC(&quot;DISPLAY&quot;,NULL, NULL, NULL);  </div><div class="line">     iBits=::GetDeviceCaps(hDC,BITSPIXEL)* ::GetDeviceCaps(hDC,PLANES);  </div><div class="line">     ::DeleteDC(hDC);  </div><div class="line"></div><div class="line">      if(iBits &lt;= 1)         </div><div class="line">          wBitCount = 1;  </div><div class="line">      else if(iBits &lt;= 4)</div><div class="line">          wBitCount = 4;           </div><div class="line">      else if(iBits &lt;= 8)</div><div class="line">          wBitCount =  8;           </div><div class="line">      else                                                                                                                      wBitCount = 24;           </div><div class="line">                              </div><div class="line">      ::GetObject(hBitmap,sizeof(Bitmap),(LPSTR)&amp;Bitmap);       </div><div class="line">     bi.biSize = sizeof(BITMAPINFOHEADER);       </div><div class="line">     bi.biWidth = Bitmap.bmWidth;       </div><div class="line">     bi.biHeight = Bitmap.bmHeight;       </div><div class="line">     bi.biPlanes = 1;       </div><div class="line">     bi.biBitCount = wBitCount;       </div><div class="line">     bi.biCompression = BI_RGB;       </div><div class="line">     bi.biSizeImage = 0;       </div><div class="line">     bi.biXPelsPerMeter = 0;       </div><div class="line">     bi.biYPelsPerMeter = 0;       </div><div class="line">     bi.biClrImportant = 0;       </div><div class="line">     bi.biClrUsed = 0;       </div><div class="line">                              </div><div class="line">     dwBmBitsSize = ((Bitmap.bmWidth * wBitCount + 31) / 32) * 4 * Bitmap.bmHeight;       </div><div class="line">                              </div><div class="line">     //为位图内容分配内存           </div><div class="line">     hDib = ::GlobalAlloc(GHND,dwBmBitsSize + dwPaletteSize + sizeof(BITMAPINFOHEADER));           </div><div class="line">     lpbi =(LPBITMAPINFOHEADER)::GlobalLock(hDib);           </div><div class="line">     *lpbi = bi;           </div><div class="line">      </div><div class="line">     //     处理调色板               </div><div class="line">     hPal = GetStockObject(DEFAULT_PALETTE);           </div><div class="line">     if(hPal)           </div><div class="line">     &#123;           </div><div class="line">         hDC = ::GetDC(NULL);           </div><div class="line">         hOldPal = ::SelectPalette(hDC,(HPALETTE)hPal,FALSE);           </div><div class="line">         RealizePalette(hDC);           </div><div class="line">     &#125;       </div><div class="line">      </div><div class="line">     //     获取该调色板下新的像素值           </div><div class="line">     GetDIBits(hDC,hBitmap,0,(UINT)Bitmap.bmHeight,(LPSTR)lpbi + sizeof(BITMAPINFOHEADER) +dwPaletteSize,</div><div class="line">               (BITMAPINFO*)lpbi,DIB_RGB_COLORS);           </div><div class="line">                              </div><div class="line">     //恢复调色板               </div><div class="line">     if (hOldPal)           </div><div class="line">     &#123;           </div><div class="line">         ::SelectPalette(hDC,     (HPALETTE)hOldPal,     TRUE);           </div><div class="line">         RealizePalette(hDC);           </div><div class="line">         ::ReleaseDC(NULL,hDC);           </div><div class="line">     &#125;           </div><div class="line">      </div><div class="line">     //创建位图文件               </div><div class="line">     fh = CreateFile(FileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,</div><div class="line">                     FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,NULL);           </div><div class="line">                              </div><div class="line">     if(fh == INVALID_HANDLE_VALUE)        </div><div class="line">         return     FALSE;           </div><div class="line">                              </div><div class="line">     //     设置位图文件头           </div><div class="line">     bmfHdr.bfType = 0x4D42;     //     &quot;BM&quot;           </div><div class="line">     dwDIBSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + dwPaletteSize + dwBmBitsSize;               </div><div class="line">     bmfHdr.bfSize = dwDIBSize;           </div><div class="line">     bmfHdr.bfReserved1 = 0;           </div><div class="line">     bmfHdr.bfReserved2 = 0;           </div><div class="line">     bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER) + dwPaletteSize;           </div><div class="line">     //     写入位图文件头           </div><div class="line">     WriteFile(fh,(LPSTR)&amp;bmfHdr,sizeof(BITMAPFILEHEADER),&amp;dwWritten,NULL);           </div><div class="line">     //     写入位图文件其余内容           </div><div class="line">     WriteFile(fh,(LPSTR)lpbi,dwDIBSize,&amp;dwWritten,NULL);           </div><div class="line">     //清除               </div><div class="line">     GlobalUnlock(hDib);           </div><div class="line">     GlobalFree(hDib);           </div><div class="line">     CloseHandle(fh);   </div><div class="line"></div><div class="line">     return     TRUE;       </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">BOOL DrawBitmapFile(HDC hdc, int left, int top, char *szFilename)</div><div class="line">&#123;</div><div class="line">    // 打开要映射的位图文件</div><div class="line">    HANDLE   hFile = CreateFile( szFilename, GENERIC_READ, FILE_SHARE_READ,</div><div class="line">        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL , NULL ) ;</div><div class="line">    if( hFile == INVALID_HANDLE_VALUE )</div><div class="line">        return FALSE ;</div><div class="line"></div><div class="line">    // 创建内存映象对象</div><div class="line">    HANDLE   hMap = CreateFileMapping( hFile , NULL, PAGE_READONLY, NULL, NULL, NULL ) ;</div><div class="line"></div><div class="line">    // 映射整个位图文件到内存，返回内存的首地址</div><div class="line">    LPVOID   lpBase = MapViewOfFile( hMap , FILE_MAP_READ, 0, 0, 0 ) ;</div><div class="line"></div><div class="line">    // 获取BMP文件信息</div><div class="line">    BITMAPFILEHEADER     *pFileHeader ;</div><div class="line">    BITMAPINFO           *pInfoHeader ;</div><div class="line"></div><div class="line">    // 获取位图象素</div><div class="line">    pFileHeader  =  (BITMAPFILEHEADER *) lpBase ;</div><div class="line">    if( pFileHeader-&gt;bfType != MAKEWORD( &apos;B&apos; , &apos;M&apos; ) )</div><div class="line">    &#123;</div><div class="line">        UnmapViewOfFile( lpBase ) ;</div><div class="line">        CloseHandle( hMap ) ;</div><div class="line">        CloseHandle( hFile ) ;</div><div class="line">        return FALSE ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BYTE *pBits = (BYTE *)lpBase + pFileHeader-&gt;bfOffBits ;</div><div class="line"></div><div class="line">    // 获取文件大小</div><div class="line">    pInfoHeader  =  (BITMAPINFO *)( (BYTE *)lpBase + sizeof(BITMAPFILEHEADER) ) ;</div><div class="line">    LONG  width  =  pInfoHeader-&gt;bmiHeader.biHeight ;</div><div class="line">    LONG  height =  pInfoHeader-&gt;bmiHeader.biWidth  ;</div><div class="line"></div><div class="line">    // 显示位图文件至hdc指定的设备</div><div class="line">    HDC        hMemDC   = CreateCompatibleDC( hdc ) ;</div><div class="line">    HBITMAP    hBitmap  = CreateCompatibleBitmap( hdc, width, height ) ;</div><div class="line">    SelectObject( hMemDC, hBitmap ) ;</div><div class="line"></div><div class="line">    // 把图象数据放到建立的内存设备中</div><div class="line">    int nRet = SetDIBitsToDevice( hMemDC, 0, 0, width, height, </div><div class="line">        0, 0, 0, height , pBits, pInfoHeader, DIB_RGB_COLORS ) ;</div><div class="line"></div><div class="line">    // 绘制图象到hdc中</div><div class="line">    BitBlt( hdc, left, top, width, height, hMemDC , 0 , 0, SRCCOPY ) ;</div><div class="line"></div><div class="line">    DeleteObject( hBitmap ) ;</div><div class="line">    UnmapViewOfFile( lpBase ) ;</div><div class="line">    DeleteDC ( hMemDC ) ;</div><div class="line">    CloseHandle( hMap ) ;</div><div class="line">    CloseHandle( hFile ) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/05/24/mem-file/" itemprop="url">
                  内存映射文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-05-24T16:02:00+09:00" content="2008-05-24">
              2008-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/05/24/mem-file/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/05/24/mem-file/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与虚拟内存一样，内存映射文件可以用来保留一个地址空间的区域，并将物理存储器提交给该区域。它们之间的差别是，物理存储器来自一个已经位于磁盘上的文件，而不是系统的页文件。一旦该文件被映射，就可以访问它，就像整个文件已经加载内存一样。</p>
<p><img src="/images/2008-05-24.bmp" alt="内存映射文件"></p>
<p>内存映射文件可以用于3个不同的目的：</p>
<ul>
<li>系统使用内存映射文件，以便加载和执行. e x e和D L L文件。这可以大大节省页文件空间和应用程序启动运行所需的时间。</li>
<li>可以使用内存映射文件来访问磁盘上的数据文件。这使你可以不必对文件执行I / O操作，并且可以不必对文件内容进行缓存。</li>
<li>可以使用内存映射文件，使同一台计算机上运行的多个进程能够相互之间共享数据。Wi n d o w s确实提供了其他一些方法，以便在进程之间进行数据通信，但是这些方法都是使用内存映射文件来实现的，这使得内存映射文件成为单个计算机上的多个进程互相进行通信的最有效的方法。</li>
</ul>
<h3 id="一．内存映射文件的函数包括"><a href="#一．内存映射文件的函数包括" class="headerlink" title="一．内存映射文件的函数包括"></a>一．内存映射文件的函数包括</h3><p>CreateFileMapping , OpenFileMapping, MapViewOfFile, UnmapViewOfFile 和 FlushViewOfFile。</p>
<p>用法如下：</p>
<p>1．</p>
<p>  HANDLE CreateFileMapping(<br>    HANDLE                  hFile,              // 一个文件句柄<br>    LPSECURITY_ATTRIBUTE  lpAttributes,         // 定义内存映射文件对象是否可以被承<br>    DWORD                   flProtect,           // 该内存映射文件的保护类型<br>    DWORD                   dwMaximumSizeHigh,// 内存映射文件的长度<br>    DWORD                   dwMaximumSizeLow, //<br>    LPCTSTR                  lpName             // 内存映射文件的名字<br>  )</p>
<p>  <strong>hFile</strong> 指定要映射的文件的句柄，如果这是一个已经打开的文件的句柄（CreateFile函数的返回值），那么将建立这个文件的内存映射文件，如果这个参数为1，则建立共享内存。<br>  <strong>lpAttribute</strong>  安全属性，一般设为NULL<br>  <strong>flProtect</strong>    指定映射文件的保护类型，它的取值可以是PAGE_READONLY（内存页面只读） 或 PAGE_READWRITE（内存页面可读写）。<br>  <strong>dwMaximumSizeHigh</strong> 和 dwMaximumSizeLow参数组合指定了一个64位的内存映射文件的长度。一种简单的方法是将这两个参数全部设置为0，那么内存映射文件的大小将与磁盘文件大小一致。</p>
<p>2．</p>
<p>  HANDLE OpenFileMapping(<br>      DWORD               dwDesiredAccess,    // 指定保护类型<br>      BOOL                  bIsInheritHandle,     // 返回的句柄是否可以被继承<br>      LPCSTR                lpName             // 创建对象时使用的名字<br>  ）</p>
<p>如果创建的是共享内存，其他进程不能再使用CreateFileMapping函数去创建同名的内存映射文件对象，而要使用OpenFileMapping函数打开已创建好的对象。</p>
<p>  <strong>dwDesiredAcess</strong>   指定保护类型有FILE_MAP_WRITE 或FILE_MAP_READ</p>
<p>3．</p>
<p>  LPVOID  MapViewOfFile(<br>      HANDLE  hFileMappingObject,    // 前两个函数返回的内存映射文件的句柄<br>      DWORD  dwDesiredAcess,      // 保护类型FILE_MAP_READ ,FILE_MAP_WRITE<br>      DWORD  dwFileOffsetHight,     // 从文件的那个地址开始映射<br>      DWORD  dwFileOffsetLow,<br>      SIZE_T   dwNumberOfBytesToMap // 要映射的字节数，为0则映射整个文件<br>  ）</p>
<p>4．</p>
<p>  BOOL  UnmapViewOfFile( LPCVOID  lpBaseAddress )</p>
<p>当不再使用内存映射文件时，可以通过UmmapViewOfFile函数撤销映射并使用CloseHandle函数关闭内存映射文件的句柄。</p>
<p>5．</p>
<p>  BOOL  FlushViewOfFile(<br>       LPCVOID   lpBaseAddress,  // 开始的地址<br>       SIZE_T     dwNumberOfBytesToFlush // 数据块的大小<br>  ）</p>
<p>如果修改了映射视图中的内存，系统会在试图撤销映射或文件映射对象被删除时自动将数据写到磁盘上，但程序也可以根据需要将视图中的数据立即写到磁盘上。</p>
<h3 id="二．使用步骤"><a href="#二．使用步骤" class="headerlink" title="二．使用步骤"></a>二．使用步骤</h3><p>1．  使用CreateFileMapping创建一个内存映射文件内核对象，告诉操作系统内存映射文件需要的物理内存大小，这个步骤决定了内存映射文件的用途――究竟是为磁盘上的文件建立内存映射还是为多个进程共享数据建立共享内存。或者使用OpenFileMapping打开映射文件内核对象。</p>
<p>2．  映射文件映射对象的全部或一部分到进程的地址空间，可以认为该操作是为文件中的内容分配线型地址空间，并将线型地址和文件内容对应起来，完成该操作的函数是MapViewOfFile。</p>
<h3 id="三．使用内存映射文件读文件的具体过程可以这样："><a href="#三．使用内存映射文件读文件的具体过程可以这样：" class="headerlink" title="三．使用内存映射文件读文件的具体过程可以这样："></a>三．使用内存映射文件读文件的具体过程可以这样：</h3><p>（1）调用CreateFile函数打开想要映射的文件，得到文件句柄hFile。</p>
<p>（2）调用CreateFileMapping函数，并传入文件句柄hFile，为该文件创建一个内存映射内核对象，得到内存映射文件的句柄hMap。</p>
<p>（3）调用MapViewOfFile函数映射整个文件或一部分到进程的虚拟地址空间。该函数返回文件映射到内存后的起始地址。使用指向这个地址的指针就可以读取文件的内容了。</p>
<p>（4）调用UnmapViewOfFile函数来解除文件映射。</p>
<p>（5）调用CloseHandle函数关闭文件对象，必须传入内存映射文件句柄hMap</p>
<p>（6）调用CloseHandle函数关闭文件对象，必须传入文件句柄hFile。</p>
<h3 id="四．进程间共享内存："><a href="#四．进程间共享内存：" class="headerlink" title="四．进程间共享内存："></a>四．进程间共享内存：</h3><p>共享内存主要是通过映射机制实现的。Windows下进程的地址空间是相互隔离的，但在物理上却是重叠的。所谓的重叠是指同一块内存区域可能被多个进程同时使用。当调用CreateFileMapping创建命名的内存映射文件对象时，Windows即在物理内存中申请了一块指定大小的内存区域，返回文件映射对象的新句柄hMap。为了能够访问这块区域必须调MapViewOfiFile函数，促使Windows将此内存空间映射到进程的地址空间中。当在其他进程中访问这块区域时，则必须使用OpenFileMapping函数来取得对象句柄hMap，并调用MapViewOfFile函数得到此内存空间的一个映射。这样一来，系统就把同一块内存区域映射到了不同进程的地址空间中，从而达到共享内存的目的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/04/27/LMS-matlab/" itemprop="url">
                  LMS算法MatLab实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-04-27T07:00:00+09:00" content="2008-04-27">
              2008-04-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/课程设计/" itemprop="url" rel="index">
                    <span itemprop="name">课程设计</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/04/27/LMS-matlab/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/04/27/LMS-matlab/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LMS自适应滤波器是使滤波器的输出信号与期望响应之间的误差的均方值为最小，因此称为最小均方（LMS）自适应滤波器。其原理及推导见<a href="http://download.csdn.net/source/432206。" target="_blank" rel="external">http://download.csdn.net/source/432206。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">       </div><div class="line">function [yn,W,en]=LMS(xn,dn,M,mu,itr)</div><div class="line">% LMS(Least Mean Squre)算法</div><div class="line">% 输入参数:</div><div class="line">%     xn   输入的信号序列      (列向量)</div><div class="line">%     dn   所期望的响应序列    (列向量)</div><div class="line">%     M    滤波器的阶数        (标量)</div><div class="line">%     mu   收敛因子(步长)      (标量)     要求大于0,小于xn的相关矩阵最大特征值的倒数    </div><div class="line">%     itr  迭代次数            (标量)     默认为xn的长度,M&lt;itr&lt;length(xn)</div><div class="line">% 输出参数:</div><div class="line">%     W    滤波器的权值矩阵     (矩阵)</div><div class="line">%          大小为M x itr,</div><div class="line">%     en   误差序列(itr x 1)    (列向量)  </div><div class="line">%     yn   实际输出序列             (列向量)</div><div class="line"></div><div class="line">% 参数个数必须为4个或5个</div><div class="line">if nargin == 4                 % 4个时递归迭代的次数为xn的长度 </div><div class="line">    itr = length(xn);</div><div class="line">elseif nargin == 5             % 5个时满足M&lt;itr&lt;length(xn)</div><div class="line">    if itr&gt;length(xn) | itr&lt;M</div><div class="line">        error(&apos;迭代次数过大或过小!&apos;);</div><div class="line">    end</div><div class="line">else</div><div class="line">    error(&apos;请检查输入参数的个数!&apos;);</div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">% 初始化参数</div><div class="line">en = zeros(itr,1);             % 误差序列,en(k)表示第k次迭代时预期输出与实际输入的误差</div><div class="line">W  = zeros(M,itr);             % 每一行代表一个加权参量,每一列代表-次迭代,初始为0</div><div class="line"></div><div class="line">% 迭代计算</div><div class="line">for k = M:itr                  % 第k次迭代</div><div class="line">    x = xn(k:-1:k-M+1);        % 滤波器M个抽头的输入</div><div class="line">    y = W(:,k-1).&apos; * x;        % 滤波器的输出</div><div class="line">    en(k) = dn(k) - y ;        % 第k次迭代的误差</div><div class="line">    </div><div class="line">    % 滤波器权值计算的迭代式</div><div class="line">    W(:,k) = W(:,k-1) + 2*mu*en(k)*x;</div><div class="line">end</div><div class="line"></div><div class="line">% 求最优时滤波器的输出序列</div><div class="line">yn = inf * ones(size(xn));</div><div class="line">for k = M:length(xn)</div><div class="line">    x = xn(k:-1:k-M+1);</div><div class="line">    yn(k) = W(:,end).&apos;* x;</div><div class="line">end</div><div class="line">    </div><div class="line">        LMS函数的一个实例：</div><div class="line">%function main()</div><div class="line">close  all</div><div class="line"></div><div class="line">% 周期信号的产生 </div><div class="line">t=0:99;</div><div class="line">xs=10*sin(0.5*t);</div><div class="line">figure;</div><div class="line">subplot(2,1,1);</div><div class="line">plot(t,xs);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">title(&apos;it&#123;输入周期性信号&#125;&apos;);</div><div class="line"></div><div class="line">% 噪声信号的产生</div><div class="line">randn(&apos;state&apos;,sum(100*clock));</div><div class="line">xn=randn(1,100);</div><div class="line">subplot(2,1,2);</div><div class="line">plot(t,xn);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;随机噪声信号&#125;&apos;);</div><div class="line"></div><div class="line">% 信号滤波</div><div class="line">xn = xs+xn;</div><div class="line">xn = xn.&apos; ;   % 输入信号序列</div><div class="line">dn = xs.&apos; ;   % 预期结果序列</div><div class="line">M  = 20   ;   % 滤波器的阶数</div><div class="line"></div><div class="line">rho_max = max(eig(xn*xn.&apos;));   % 输入信号相关矩阵的最大特征值</div><div class="line">mu = rand()*(1/rho_max)   ;    % 收敛因子 0 &lt; mu &lt; 1/rho</div><div class="line"></div><div class="line">[yn,W,en] = LMS(xn,dn,M,mu);</div><div class="line"></div><div class="line">% 绘制滤波器输入信号</div><div class="line">figure;</div><div class="line">subplot(2,1,1);</div><div class="line">plot(t,xn);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;滤波器输入信号&#125;&apos;);</div><div class="line"></div><div class="line">% 绘制自适应滤波器输出信号</div><div class="line">subplot(2,1,2);</div><div class="line">plot(t,yn);grid;</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;自适应滤波器输出信号&#125;&apos;);</div><div class="line"></div><div class="line">% 绘制自适应滤波器输出信号,预期输出信号和两者的误差</div><div class="line">figure </div><div class="line">plot(t,yn,&apos;b&apos;,t,dn,&apos;g&apos;,t,dn-yn,&apos;r&apos;);grid;</div><div class="line">legend(&apos;自适应滤波器输出&apos;,&apos;预期输出&apos;,&apos;误差&apos;);</div><div class="line">ylabel(&apos;幅值&apos;);</div><div class="line">xlabel(&apos;时间&apos;);</div><div class="line">title(&apos;it&#123;自适应滤波器&#125;&apos;);</div></pre></td></tr></table></figure>
<p>运行后的结果如下：</p>
<p><img src="/images/2008-04-27-1.bmp" alt="LMS"><br><img src="/images/2008-04-27-2.bmp" alt="LMS"><br><img src="/images/2008-04-27-3.bmp" alt="LMS"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2008/04/27/LMS/" itemprop="url">
                  什么是滤波器？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2008-04-27T06:42:00+09:00" content="2008-04-27">
              2008-04-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/课程设计/" itemprop="url" rel="index">
                    <span itemprop="name">课程设计</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2008/04/27/LMS/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2008/04/27/LMS/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>帮同学编个LMS（Least Mean Squre）自适应滤波器算法，有许多基本概念都不知道，所以就上网搜了搜，长长见识。</p>
<p>滤波器是一种用来消除干扰杂讯的器件，将输入或输出经过过滤而得到纯净的交流电。您可以通过基本的滤波器积木块——二阶通用滤波器传递函数，推导出最通用的滤波器类型：低通、带通、高通、陷波和椭圆型滤波器。</p>
<p>传递函数的参数——f0、d、hHP、hBP 和hLP，可用来构造所有类型的滤波器。转降频率f0为s项开始占支配作用时的频率。设计者将低于此值的频率看作是低频，而将高于此值的频率看作是高频，并将在此值附近的频率看作是带内频率。阻尼d用于测量滤波器如何从低频率转变至高频率，它是滤波器趋向振荡的一个指标。实际阻尼值从0至2变化（表1）。高通系数hHP是对那些高于转降频率的频率起支配作用的分子的系数。带通系数hBP是对那些在转降频率附近的频率起支配作用的分子的系数。低通系数hLP是对那些低于转降频率的频率起支配作用的分子的系数。设计者只需这5个参数即可定义一个滤波器。</p>
<h3 id="滤波器的过去、现在与未来"><a href="#滤波器的过去、现在与未来" class="headerlink" title="滤波器的过去、现在与未来"></a>滤波器的过去、现在与未来</h3><p>凡是有能力进行信号处理的装置都可以称为滤波器。在近代电信装备和各类控制系统中，滤波器应用极为广泛；在所有的电子部件中，使用最多，技术最复杂要算滤波器了。滤波器的优劣直接决定产品的优劣，所以，对滤波器的研究和生产历来为各国所重视。</p>
<h3 id="滤波器的发展过程"><a href="#滤波器的发展过程" class="headerlink" title="滤波器的发展过程"></a>滤波器的发展过程</h3><p>1917年美国和德国科学家分别发明了LC滤波器，次年导致了美国第一个多路复用系统的出现。50年代无源滤波器日趋成熟。自60年代起由于计算机技术、集成工艺和材料工业的发展，滤波器发展上了一个新台阶，并且朝着低功耗、高精度、小体积、多功能、稳定可靠和价廉方向努力，其中小体积、多功能、高精度、稳定可靠成为70年代以后的主攻方向，导致RC有源滤波器 、数字滤波器、开关电容滤波器和电荷转移器等各种滤波器的飞速发展。到70年代后期，上述几种滤波器的单片集成被研制出来并得到应用。80年代致力于各类新型滤波器性能提高的研究并逐渐扩大应用范围。90年代至今在主要致力于把各类滤波器应用于各类产品的开发和研制。当然，对滤波器本身的研究仍在不断进行。</p>
<p>我国广泛使用滤波器是50年代后的事，当时主要用于话路滤波和报路滤波。经过半个世纪的发展，我国滤波器在研制、生产应用等方面已有一定进步，但由于缺少专门研制机构，集成工艺和材料工业跟不上来，使许多新型滤波器的研制应用与国际水平有一段距离。</p>
<h3 id="滤波器分类"><a href="#滤波器分类" class="headerlink" title="滤波器分类"></a>滤波器分类</h3><h4 id="按处理信号类型分类"><a href="#按处理信号类型分类" class="headerlink" title="按处理信号类型分类"></a>按处理信号类型分类</h4><p>滤波器可分为模拟滤波器和离散滤波器两大类。其中模拟滤波器又可分为有源、无源、异类三个分类；离散滤波器又可分为数字、取样模拟、混合三个分类。当然，每个分类又可继续分下去，总之，它们的分类可以形成一个树形结构。</p>
<p><strong>按选择物理量分类</strong></p>
<p>滤波器可分为频率选择、幅度选择、时间选择（例如PCM制中的话路信号）和信息选择（例如匹配滤波器）等四类滤波器。</p>
<p><strong>按频率通带范围分类</strong></p>
<p>滤波器可分为低通、高通、带通、带阻、全通五个类别，而梳形滤波器属于带通和带阻滤波器，因为它有周期性的通带和阻带。</p>
<p>滤波器种类繁多，下面着重介绍近年来发展很快的几种滤波器。</p>
<p><strong>有源滤波器</strong></p>
<p>有源滤波器由下列一些有源元件组成：运算放大器、负电阻、负电容、负电感、频率变阻器（FDNR）、广义阻抗变换器（GIC）、负阻抗变换器（NIC）、正阻抗变换器（PIC）、负阻抗倒置器（NII）、正阻抗倒置器（PII）、四种受控源，另外，还有病态元件极子和零子。</p>
<p>1965年单片集成运算放大器问世后，为有源滤波器开辟了广阔的前景，到70年代初期，有源滤波器发展最为注目，1978年单片RC有源滤波器问世，为滤波器集成迈进了可喜的一步。由于运放的增益和相移均为频率的函数，这就限制了RC有源滤波器的频率范围，一般工作频率为20KHz左右，经过补偿后，工作频率也限制在100KHz以内。1974年产生了有源滤波器，使工作频率可达GB/4（GB为运放增益与带宽之积）。由于R(电阻)的存在，给集成工艺造成困难，于是又出现了有源C(电容)滤波器：就是说，滤波器由C和运放组成。这样容易集成，更重要是提高了滤波器的精度，因为有源C滤波器的性能只取决于电容之比，与电容绝对值无关。但它有一个主要问题：由于各支路元件均为电容，所以运放没有直流反馈通道，使稳定性成为难题。1982年由Geiger、Allen和Ngo提出用连续的开关电阻（SR）去替代有源RC滤波器中的电阻R，就构成了SRC滤波器，它仍属于模拟滤波器。但由于采用预置电路和复杂的相位时钟，这种滤波器发展前途不大。</p>
<p>总之，以RC有源滤波器为原型的各类变种有源滤波器去掉了电感器，体积小，Q值可达1000，克服了RLC无源滤波器体积大、Q值小的缺点。但它仍有许多课题有待进一步研究：理想运放与实际特性的偏差；由于有源滤波器混合集成工艺的不断改进，单片集成有待进一步研究；应用线性变换方法探索最少有源元件的滤波器需要继续探索；元件的绝对值容差的存在，影响滤波器精度和性能等问题仍未解决；由于R存在，占芯片面积大、电阻误差大(20~30%)、线性度差等缺点，大规模集成仍然有困难。</p>
<p><strong>开关电容滤波器（SCF）</strong></p>
<p>80年代技术改造一个重大课题是实现各种电子系统全面大规模集成（LSI），使用最多的滤波器成为”拦路虎”，RC有源滤波器不能实现LSI，无源滤波器和机械滤波器更不用说。人们只能另辟新径。50年代有人提出SCF的概念，由于当时集成工艺不过关，并没有引起人们的重视，直到72年，美国一个叫Fried的科学家用开关和电容模拟电阻R，说SCF的性能只取决于电容之比，与电容绝对值无关，这样才引起人们的重视。1979年一些发达国家单片SCF已成为商品（属于高度保密技术），现在SC技术已趋成熟。SCF并用MOS工艺加以实现公认为80年代网络理论与集成工艺的一大突破。当前MOS电容值一般为几PF~100PF之内，它具有（10~100） 10-6/V的电压系数与（10~100） 10-6/℃的温度系数，这两个系数几乎接近理想的境界。SCF具有下列一些优点：可以大规模集成；精度高；功能多，几乎所有电子部件和功能均可以由SC技术来实现；比数字滤波器简单，因为不需要A/D，D/A转换；功能小，可以做到。</p>
<p>SCF的应用情况：以声频范围应用为主体，工作频率在100KHz之内；在信号处理方面的应用有：程控SCF、模拟信号处理、振动分析、自适应性滤波器、音乐综合、共振谱、语言综合器、音调选择、语声编码、声频分析、均衡器、解调器、锁相电路、离散傅氏变换……。总之，SCF在仪表测量、医疗仪器、数据或信息处理等许多领域都有广泛的应用前景。</p>
<p>在我国，1978年，有的导师和在校研究生开始进行这项研究工作，真正引起人们重视是80年以后。83年清华大学已制成单片SCF，成都工程学院与工厂联合，也研制成单片SCF。现在关键是MOS工艺实现SCF及推广应用问题，由于用户还不了解它，SCF的应用还没有普及。</p>
<p>SCF还有许多课题有待研究：1、由于运放和控制MOS开关的采样频率所限制，SCF只能在音频范围内应用。近年虽然出现无运放的SC电路，但由于采样频率的限制，工作频率最高只在1MHZ之内。2、非零的MOS开关的沟道电阻以及非理想的运放特性，均可使SCF造成误差。3、开关电容本身的寄生电容将使SCF的频响发生畸变。4、MOS开关与MOS运放的热噪声将使SCF的动态范围受到限制。5、最终要以MOS工艺来实现的SCF，由于它是时变网络，想用分立元件精确模拟是不可能的，因此，设计完善的CAD技术是解决这一问题的唯一手段。此外，在灵敏度分析、噪声分析等方面均有许多课题有待研究。</p>
<h3 id="几种新型数字滤波器（DF）"><a href="#几种新型数字滤波器（DF）" class="headerlink" title="几种新型数字滤波器（DF）"></a>几种新型数字滤波器（DF）</h3><p>大家对DF并不陌生，这里不作系统综述，但对一些新型DF做一些介绍：</p>
<p>1.自适应DF</p>
<p>最优控制、自适应控制和自学习控制都涉及到多参数、多变量的复杂控制系统，都属于现代控制理论研究的课题。自适应DF具有很强的自学习、自跟踪功能。它在雷达和声纳的波束形成、缓变噪声干扰的抑制、噪声信号的处理、通信信道的自适应均衡、远距离电话的回声抵消等领域获得了广泛的应用，促进了现代控制理论的发展。</p>
<p>自适应DF有如下一些简单算法：W-LMS算法；M-LMS算法；TDO算法；差值LMS算法和C-LMS算法。</p>
<p>2.复数DF</p>
<p>在输入信号为窄带信号处理系统中，常采用复数DF技术。为了降低采样率而保存信号所包含的全部信息，可利用正交双路检波法，取出窄带信号的复包络，然后通过A/D变换，将复包络转化为复数序列进行处理，这个信号处理系统即为复数DF。它具有许多功能。MTI雷达中抑制具有卜勒频移的杂波干扰；数字通信网与模拟通信网之间多路TDM/FDM信号变换复接等等。</p>
<p>3.多维DF<br>在图象处理、地震、石油勘探的数据处理中都用到多维DF（常用是二维DF），多维DF的设计，往往将一维DF优化设计直接推广到多维DF中去。对于模糊和随机噪声干扰的二维图象的处理，多维DF也能发挥很好的作用。</p>
<p>此外，还有波DF，它便于实现大规模集成；便于无源和有源滤波网络的数字模拟。</p>
<p>对于DF有待研究的课题有：系数灵敏度；舍入噪声和极限环；多维逆归滤波器的稳定性；各种硬件和软件实现DF的研究等等。</p>
<h3 id="其它新型滤波器"><a href="#其它新型滤波器" class="headerlink" title="其它新型滤波器"></a>其它新型滤波器</h3><p>介绍几种已得到广泛应用的新型滤波器：</p>
<p>1.电控编程CCD横向滤波器（FPCCDTF）</p>
<p>电荷耦合器（CCD）固定加权的横向滤波器（TF）在信号处理中，其性能和造价均可与数字滤波器和各种信号处理部件媲美。这种滤波器主要用于自适应滤波；P-N序列和Chirp波形的匹配滤波；通用化的频域滤波器以及作相关、褶积运算；语音信号和相位均衡；相阵系统的波束合成和电视信号的重影消除等。</p>
<p>2.晶体滤波器</p>
<p>它是适应单边带技术而发展起来的。在70年代，集成晶体滤波器的产生，使它发展产生一个飞跃，近十年来，对晶体滤波器致力于下面一些研究：实现最佳设计，除具有优良的选择外，还具有良好的时域响应；寻求新型材料；扩展工作频率；改造工艺，使其向集成化发展。它广泛应用于多路复用系统中作为载波滤波器，在收发信中、单边带通信机中作为选频滤波器，在频谱分析仪和声纳装置中作为中频滤波器。</p>
<p>3.声表面波滤波器</p>
<p>它是理想的超高频器件。它的幅频特性和相位特性可以分别控制，以达到要求，体积小，长时间稳定性好和工艺简单。通常应用于：电视广播发射机中作为残留边带滤波器；彩色电视接收机中调谐系统的表面梳形滤波器，此外，在国防卫星通信系统中已广泛采用。声表面波滤波器是电子学和声学相结合的产物，而且可以集成。所以，它在所有无源滤波器中最有发展前途。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="David++" />
          <p class="site-author-name" itemprop="name">David++</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">91</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/david-pp" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/davidpp" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gamelab" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/future_fighter/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David++</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tiny-lab"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>

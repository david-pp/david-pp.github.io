<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="TinyLab" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="TinyLab">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="TinyLab">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TinyLab">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/5/"/>


  <title> TinyLab </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?32177a2b43f11f13565131b8c1239878";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TinyLab</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep eyes on the star and feet on the ground.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/05/08/refactoring-tempvars/" itemprop="url">
                  临时变量管理器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-05-08T21:00:00+08:00" content="2012-05-08">
              2012-05-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/重构/" itemprop="url" rel="index">
                    <span itemprop="name">重构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/05/08/refactoring-tempvars/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/05/08/refactoring-tempvars/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有些变量，它们在特定的情况下才有意义。有些功能需要多步才能完成，结果就需要一些中间变量保存过程的状态，过程结束后变量就失去存在的价值。缺点：</p>
<ol>
<li>浪费存储空间，虽然内存很廉价，但还是能省则省  </li>
<li>中间变量变多的时候，所在类越来越大，越来越难以理解  </li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>封装一个中间变量管理器：支持创建、删除、取值、设值这几个操作就行。</p>
<p><strong>临时变量定义</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Player</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     enum TempVariableType</div><div class="line">     &#123;</div><div class="line">          kTempInvalid,</div><div class="line">          kTempTest,</div><div class="line">          kTempJumpVerification,</div><div class="line">     &#125;;</div><div class="line"> </div><div class="line">     TempVariableManager&lt;Player&gt; tmpvars;</div><div class="line">&#125;; </div><div class="line"> </div><div class="line">struct JumpVerification</div><div class="line">&#123;</div><div class="line">     JumpVerification(DWORD x_=0, DWORD y_=0, DWORD mapid_=0) :</div><div class="line">          x(x_), y(y_), mapid(mapid_) &#123;&#125;</div><div class="line">     DWORD x;</div><div class="line">     DWORD y;</div><div class="line">     DWORD mapid;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 中间变量的定义</div><div class="line">define_tempvariable(Player, kTempTest, DWORD);</div><div class="line">define_tempvariable(Player, kTempJumpVerification, JumpVerification);</div></pre></td></tr></table></figure>
<p><strong>临时变量的使用</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 新创建</div><div class="line">pUser-&gt;tmpvars.create&lt;SceneUser::kTempTest&gt;(20);</div><div class="line">pUser-&gt;tmpvars.create&lt;SceneUser::kTempJumpVerification&gt;(JumpVerification(10,10,101));</div><div class="line"> </div><div class="line">// 删除</div><div class="line">pUser-&gt;tmpvars.release(SceneUser::kTempTest);</div><div class="line">pUser-&gt;tmpvars.release(SceneUser::kTempJumpVerification);</div><div class="line"> </div><div class="line">// 取值</div><div class="line">pUser-&gt;tmpvars.get&lt;SceneUser::kTempTest&gt;();</div><div class="line">pUser-&gt;tmpvars.get&lt;SceneUser::kTempJumpVerification&gt;().x</div><div class="line">pUser-&gt;tmpvars.get&lt;SceneUser::kTempJumpVerification&gt;().y</div><div class="line"> </div><div class="line">JumpVerification&amp; jv = pUser-&gt;tmpvars.get&lt;SceneUser::kTempJumpVerification&gt;();</div><div class="line">jv.x;</div><div class="line">jv.y;</div><div class="line"> </div><div class="line">// 设值</div><div class="line">pUser-&gt;tmpvars.get&lt;SceneUser::kTempTest&gt;() = 100;</div><div class="line">pUser-&gt;tmpvars.get&lt;SceneUser::kTempJumpVerification&gt;().x = 100;</div><div class="line">JumpVerification&amp; jv = pUser-&gt;tmpvars.get&lt;SceneUser::kTempJumpVerification&gt;();</div><div class="line">jv.x = 100;</div><div class="line">jv.y = 100;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/25/xml-parsing/" itemprop="url">
                  解析XML文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-25T21:15:00+08:00" content="2012-04-25">
              2012-04-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/重构/" itemprop="url" rel="index">
                    <span itemprop="name">重构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/04/25/xml-parsing/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/04/25/xml-parsing/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>网游服务器端开发过程中，很多控制游戏的参数都不应该直接硬编码的。需要各种各样的配置和脚本文件，好处：</p>
<p>可以由策划或数值去随意修改，而不用动程序代码</p>
<p>配置可以动态加载，可以动态改变服务器运行中的参数，对已经发布的功能进行调整<br>一般，可采用：</p>
<ol>
<li>ini配置，一般用于window下的软件，游戏客户端有时会用到。比较简单，功能有限。  </li>
<li>Excel表格，数值策划特别喜欢用这个，可以做很多运算，生成数值，可以用VBA做更多的事情。  </li>
<li>xml配置，对于层次比较深、结构比较复杂的数据，应该算最佳选择了。  </li>
</ol>
<p>XML(eXtensible Markup Language)是一种标记语言，用于说明数据是什么，以及携带数据信息。主要用于：</p>
<ol>
<li>丰富文件(Rich Documents)：自定文件描述并使其更丰富  </li>
<li>元数据(Metadata)：描述其它文件  </li>
<li>配置文件(Configuration Files)：设定应用程序的参数  </li>
</ol>
<p>下面主要介绍一下对于xml文件作为服务器配置时候的解析方案。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>解析下面的XML文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;config&gt;</div><div class="line">     &lt;node1 prop1=&quot;100&quot; prop2=&quot;i am string&quot;, prop3=&quot;2012-01-02 23:00:00&quot;/&gt;</div><div class="line"> </div><div class="line">     &lt;node2 id=&quot;1&quot; prop1=&quot;100&quot; prop2=&quot;string1&quot;/&gt;</div><div class="line">     &lt;node2 id=&quot;2&quot; prop1=&quot;100&quot; prop2=&quot;string1&quot;/&gt;</div><div class="line">     &lt;node2 id=&quot;3&quot; prop1=&quot;100&quot; prop2=&quot;string1&quot;/&gt;</div><div class="line">     &lt;node2 id=&quot;4&quot; prop1=&quot;100&quot; prop2=&quot;string1&quot;/&gt;</div><div class="line"> </div><div class="line">     &lt;node3 prop1=&quot;100&quot;  prop2=&quot;string1&quot;/&gt;</div><div class="line">     &lt;node3 prop1=&quot;100&quot;  prop2=&quot;string1&quot;/&gt;</div><div class="line">     &lt;node3 prop1=&quot;100&quot;  prop2=&quot;string1&quot;/&gt;</div><div class="line">     &lt;node3 prop1=&quot;100&quot;  prop2=&quot;string1&quot;/&gt;</div><div class="line">&lt;/config&gt;</div></pre></td></tr></table></figure>
<ul>
<li>node1 – 整个xml文件里面只有一个该节点  </li>
<li>node2 – 有多个并且id属性可以作为它的键值，称之为节点map  </li>
<li>node3 – 有多个名为node3的节点，但没有键值，称之为节点vector  </li>
</ul>
<h3 id="一般的解决方案"><a href="#一般的解决方案" class="headerlink" title="一般的解决方案"></a>一般的解决方案</h3><p>使用XMLPaser（用libxml2封装的一个解析器）来解析（TinyXML也类似，DOM方式的都大同小异）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">XMLPaser xml;</div><div class="line">if (xml.initFile(&quot;xxx.xml&quot;))</div><div class="line">&#123;</div><div class="line">     xmlNodePtr root = xml.getRootNode(&quot;config&quot;);</div><div class="line">     if (root)</div><div class="line">     &#123;</div><div class="line">          // 解析node1的prop1和prop2属性</div><div class="line">           struct NodeConfig&#123;</div><div class="line">                    int prop1;</div><div class="line">                    string prop2;</div><div class="line">               &#125; config;</div><div class="line"> </div><div class="line">          xmlNodePtr node1 = root-&gt;getChildNode(root, &quot;node1&quot;);</div><div class="line">          if (node1)</div><div class="line">          &#123;</div><div class="line"> </div><div class="line">               node1-&gt;getNodePropNum(node1, &quot;prop1&quot;, &amp;config.prop1, sizeof(config.prop1));</div><div class="line">               node2-&gt;getNodePropStr(node1, &quot;prop2&quot;, config.prop2);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          // 解析node2节点map</div><div class="line">           struct NodeConfig&#123;</div><div class="line">                    int prop1;</div><div class="line">                    string prop2;</div><div class="line">           &#125;;</div><div class="line">          std::map&lt;int, NodeConfig&gt; nodemap;</div><div class="line"> </div><div class="line">          xmlNodePtr node2 = root-&gt;getChildNode(root, &quot;node2&quot;);</div><div class="line">          while (node2)</div><div class="line">          &#123;</div><div class="line">               int id;</div><div class="line">               NodeConfig config;</div><div class="line"> </div><div class="line">               node2-&gt;getNodePropNum(node2, &quot;id&quot;, &amp;id, sizeof(id));</div><div class="line">               node2-&gt;getNodePropNum(node2, &quot;prop1&quot;, &amp;config.prop1, sizeof(config.prop1));</div><div class="line">               node2-&gt;getNodePropStr(node2, &quot;prop2&quot;, config.prop2);</div><div class="line"> </div><div class="line">               nodemap[id] = config;               </div><div class="line"> </div><div class="line">               node2 = node2-&gt;getNextNode(node2, &quot;node2&quot;);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          // 解析node3节点vector</div><div class="line">          .....</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>坏味道分析</strong></p>
<p>上面的代码，有几点不足之处，列举如下：</p>
<p>1&gt; 代码重复</p>
<p>整个解析过程大同小异，一步一步遍历加载在内存中的节点树<br>节点或节点属性的名称、节点的层次结构不同的时候，就得写不同的代码，一般会采用复制代码的方式<br>使用不便</p>
<p>往往要写一个单件管理器，在服务器启动的时候加载该配置，然后在管理器里面把需要的数据结构都定义好<br>使用的时候，引用管理器里面的成员变量，代码既丑陋又容易出错</p>
<p>2&gt; 不安全</p>
<p>节点名称、属性名称都是字符串，拼错了，运行时会发生逻辑错误</p>
<h3 id="更好的解决方案"><a href="#更好的解决方案" class="headerlink" title="更好的解决方案"></a>更好的解决方案</h3><p>C++的结构与XML的对应树状结构对应起来，也就是数据绑定方案（Xml Data Binding）。自己曾经实现过一个Xml Data Binding库，名为xml_parser。具体用法如下：</p>
<p><strong>step1: 编写一份描述XML结构的配置文件（也是一份XML文件,xml_parser.xml）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;config&gt;</div><div class="line">     &lt;node1 prop1=&quot;int&quot; prop2=&quot;string&quot; prop3=&quot;t_Date&quot;/&gt;</div><div class="line">     &lt;node2 id=&quot;int&quot; prop1=&quot;int&quot; prop2=&quot;string&quot; container_=&quot;map&quot; key_=&quot;id&quot;/&gt;</div><div class="line">     &lt;node3 prop1=&quot;int&quot;  prop2=&quot;string&quot; container_=&quot;vector&quot; /&gt;</div><div class="line">&lt;/config&gt;</div></pre></td></tr></table></figure>
<p><strong>step2: 生成binding类</strong></p>
<pre><code>xmlpg -f xml_paser.xml -o xml_parser.h
</code></pre><p><strong>*step3: 应用程序中使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">xml_config&lt;xml_paser&gt; xml;</div><div class="line">if (xml.load(&quot;xxx.xml&quot;))</div><div class="line">&#123;</div><div class="line">     // node1的prop1和prop2属性</div><div class="line">     int prop1 = xml.node1.prop1();</div><div class="line">     string prop2 = xml.node1.prop2();</div><div class="line">     t_Date date  = xml.node1.prop3();</div><div class="line"></div><div class="line">     // node2节点map</div><div class="line">     for (xml_paser::Node2MapIter it = xml.node2.begin(); it != xml.node2.end(); ++ it)</div><div class="line">     &#123;</div><div class="line">          int id = it-&gt;first;</div><div class="line">          int prop1 = it-&gt;second.prop1();</div><div class="line">          string prop2 = it-&gt;second.prop2();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     // node3节点vector</div><div class="line">     for (size_t i = 0; i &lt; xml.node3.size(); i ++)</div><div class="line">     &#123;</div><div class="line">          int prop1 = xml.node3[i].prop1();</div><div class="line">          string prop2 = xml.node3[i].prop2();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="更多解决方案"><a href="#更多解决方案" class="headerlink" title="更多解决方案"></a>更多解决方案</h3><table class="table" border="1"><br><thead><br>     <tr><br>          <th>方式</th><br>          <th>特征</th><br>          <th>开源库</th><br>     </tr><br></thead><br><tbody><br>     <tr><br>          <td>DOM(Document Object Model)</td><br>          <td><br>               1. 文档对象模型，整个文档就是一个根节点及其子节点构成;<br>               2. 树状，有子节点、父节点、兄弟节点;<br>               3. 访问效率较低<br>          </td><br>          <td><br>               libxml2;<br>               Xerces-C++;<br>               TinyXML;<br>               SlimXML;<br>               RapidXML<br>          </td><br>     </tr><br>     <tr><br>          <td>SAX(Simple API for XML)</td><br>          <td>基于事件解析XML</td><br>          <td><br>               libxml2;<br>               Xerces-C++<br>          </td><br>     </tr><br>     <tr><br>          <td>Data Binding</td><br>          <td><br>1. C++的结构与XML的对应树状结构对应起来，使用起来比较容易;<br>2. 安全，C++的结构为静态的，不会因为写错节点或节点属性名称拼写错误而导致逻辑错误;<br>3. 代码简洁、清晰;<br>4. 访问效率高，对所为节点或节点属性的访问只是函数调用，而不像DOM方式去循环遍历整个子树的节点，做一系列字符串比较操作;<br>5. 不足之处，结构必须已知，DOM方式则不论程序里面对应的结构，先把整个节点树加载到内存中，程序根据自己的需要去读取自己想要的节点或节点属性<br>          </td><br>          <td>CodeSynthesis XSD</td><br>     </tr><br></tbody><br></table>


<h3 id="XML与Excel表格做配置的比较"><a href="#XML与Excel表格做配置的比较" class="headerlink" title="XML与Excel表格做配置的比较"></a>XML与Excel表格做配置的比较</h3><table class="table" border="1"><br><thead><br>     <tr><br>          <th>比较</th><br>          <th>XML</th><br>          <th>Excel表格</th><br>     </tr><br></thead><br><tbody><br>     <tr><br>          <td>结构</td><br>          <td>树状的层次结构</td><br>          <td>MxN的二维数组</td><br>     </tr><br>     <tr><br>          <td>适用性</td><br>          <td>信息具有层次性; 结构复杂</td><br>          <td>有一个键值可以索引的关联数组结构; 结构简单</td><br>     </tr><br>     <tr><br>          <td>不足之处</td><br>          <td>配置起来不是那么方便，每个节点名、属性名都必须指定</td><br>          <td>添加新列的时候，不一定所有行都用到该列属性，容易导致空间的浪费</td><br>     </tr><br></tbody><br></table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/24/badsmell-of-code/" itemprop="url">
                  代码的坏味道
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-24T01:20:00+08:00" content="2012-04-24">
              2012-04-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/重构/" itemprop="url" rel="index">
                    <span itemprop="name">重构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/04/24/badsmell-of-code/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/04/24/badsmell-of-code/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>代码坏味道</strong>：是指在代码之中潜在问题的警示信号。并非所有的坏味道所指示的确实是问题，但是对于大多数坏味道，均很有必要加以查看，并作出相应的修改。</p>
<p><strong>1. 重复的代码</strong></p>
<p>如果你在一个以上的地点看到相同的程序结构，那么当可肯定：设法将它们合而为一，程序会变得更好。</p>
<p>1&gt; 同一个class内的两个函数中含有重复的代码段<br>2&gt; 两个兄弟class的成员函数中含有重复的代码段<br>3&gt; 两个毫不相关的class内出现重复的代码段  </p>
<p>注意：重复的代码是多数潜在BUG的温床！</p>
<p><strong>2. 过长的函数</strong></p>
<p>拥有短函数的对象会活的比较好、比较长。</p>
<p>1&gt; 程序愈长就愈难理解<br>2&gt; 函数过长阅读起来也不方便<br>3&gt; 小函数的价值：解释能力、共享能力、选择能力  </p>
<p>原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。记着，起个好名字！</p>
<p><strong>3.  过大类</strong></p>
<p>如果想利用单一类做太多事情，其内往往就会出现太多的成员变量。</p>
<p>1&gt; 提取完成同一任务的相关变量到一个新的类<br>2&gt; 干太多事情的类，可以考虑把责任委托给其他类  </p>
<p>注意：一个类如果拥有太多的代码，也是代码重复、混乱、死亡的绝佳滋生地点。</p>
<p><strong>4.  过长的参数列表</strong></p>
<p>太长的参数列表难以理解，太多参数会造成前后不一致、不易使用，而且你需要更多数据时，就不得不修改它。</p>
<p>原则：参数不超过3个！</p>
<p><strong>5. 发散式变化</strong></p>
<p>我们希望软件能够更容易被修改。一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。如果不能做到这点，你就嗅出“坏味道：发散式变化”或“坏味道：霰弹式修改”。</p>
<p>发散式变化：一个类受多种变化的影响</p>
<p>数据库新加一个字段，同时修改三个函数：Load、Insert、Update</p>
<p>新加一个角色二进制，同时修改四处</p>
<p>原则：针对某一外界变化的所有相应修改，都只应该发生在单一类中</p>
<p><strong>6. 霰弹式修改</strong></p>
<p>如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改以响应之。如果需要修改的代码散布四处，你不但难以找到它们，也很容易忘记某个重要的修改。</p>
<p>霰弹式修改：一种变化引起多个类相应的修改</p>
<p><strong>7. 依恋情节</strong></p>
<p>函数对某个类的兴趣高过对自己所处类的兴趣，就会产生对这个类的依恋情节，造成紧耦合。</p>
<p>原则：判断哪个类拥有最多被此函数使用的数据，然后将这个函数和那些数据摆在一起。</p>
<p>原则：将总是变化的东西放在一块。</p>
<p><strong>8. 数据泥团</strong></p>
<p>有些数据项，喜欢成群结队地待在一块。那就把它们绑起来放在一个新的类里面。这样就可以：</p>
<p>1&gt; 缩短参数列表<br>2&gt; 简化函数调用  </p>
<p><strong>9. 基本型别偏执</strong></p>
<p>代码中有很多基本数据类型的数据。</p>
<p>原则：如果看到一些基本类型数据，尝试定义一种新的数据类型，符合它当前所代表的对象类型。</p>
<p><strong>10. switch惊悚现身</strong></p>
<p>面向对象程序的一个最明显特征就是：少用switch语句。从本质上说，switch语句的问题在于重复。</p>
<p>原则：看到switch你就应该考虑使用多态来替换它。</p>
<p><strong>11. 冗赘类</strong></p>
<p>你所创建的每一个类，都得有人去理解它、维护它，但一个类没有存在的必要时候，就让这个类庄严扑义吧！</p>
<p>原则：如果一个类的所得不值其身价，它就应该消失。</p>
<p><strong>12. 夸夸其谈其未来性</strong></p>
<p>对未来不可预知的变化考虑的过多，造成系统更难理解和维护。如果应对变化的代码都会被用到，那是值得的那么做；如果用不到，就不值得。</p>
<p>原则：代码应该满足当前的需求，并留有可扩展的余地。对于未来的变化，既不要考虑的太多，也不能一点都不考虑。</p>
<p><strong>13. 令人迷惑的暂时成员变量</strong></p>
<p>有时你会看到这样的对象：其内某个成员变量仅为某种特定的情形而设。这样的代码容易让人不解，因为你通常认为对象在所有时候都需要它的所有变量。</p>
<p>在变量未被使用的情况下猜测当初设置目的，会让你发疯。</p>
<p><strong>14. 无用的中间人</strong></p>
<p>过度使用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就过度运用了。所以，删除无用的中间人。</p>
<p><strong>15. 狎昵关系</strong></p>
<p>有时你会看到两个类过于亲密，花费太多时间去探究彼此的private成分。</p>
<p>原则：过分狎昵的类必须拆散。</p>
<p><strong>16. 异曲同工的类</strong></p>
<p>如果两个函数做同一件事情，却有着不同的签名式。</p>
<p>原则：删除一个，保留一个。</p>
<p><strong>17. 不完美的程序库类</strong><br>库的设计有时会不够好，不那么容易使用，可能还会有那么一点小缺陷。</p>
<p>工具：</p>
<p>1&gt; Introduce Foreign Method<br>2&gt; Introduce Local Extension  </p>
<p><strong>18. 过多的注释</strong></p>
<p>过多注释的代码段，往往都是因为那段代码比较糟糕，散发着一股恶臭。</p>
<p>原则：当你感觉需要写注释时，请尝试重构，试着让所有注释都变得多余。</p>
<p><strong>参考资料</strong>：</p>
<p>1&gt; 《重构：改善既有代码的设计》<br>2&gt; 《重构手册》  </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/20/weekly-sed/" itemprop="url">
                  每周一荐：流编辑器sed
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-20T23:45:00+08:00" content="2012-04-20">
              2012-04-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/每周一荐/" itemprop="url" rel="index">
                    <span itemprop="name">每周一荐</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/04/20/weekly-sed/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/04/20/weekly-sed/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>做网络游戏服务器端，最烦人的就是查后台日志。外面的玩家报BUG或者其他异常的时候，客服搞不定的时候，就需要服务器的程序去查日志。分析日志需要一些比较好的文本分析工具，grep和sed都是不错的文本分析工具，还有awk，再过复杂的日志分析估计就要写脚本了，推荐使用Python。</p>
<p>（其实我一直在纳闷，数据分析这些事情，怎么老是需要服务器程序去查，有专门的数据中心、运维和客服部门，人家才是专业的，工具比咱用的更“专业”吧。最后想了想，公司流程不完善，游戏后台日志分析自己这边还是做起来，不然搞的太被动了也不好。）</p>
<p>下面是sed的一个快速参考，更加详细的介绍，还有用法实例，可以参考《sed and awk》那本书。或者本文后面的那几个链接，都有很好的介绍。</p>
<h3 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a>命令行语法</h3><p>有两种调用sed的方式：</p>
<pre><code>sed [-n] [-e] &apos;command&apos; file(s)
sed [-n] -f scriptfile file(s)
</code></pre><p>第一种方式允许在命令行指定一个编辑命令，用单引号括起来。第二种形式允许指定一个scriptfile，即包含sed命令的文件。两种形式可以一起使用，并且他们可以被多次使用。编辑的结构是将命令和脚本文件串联起来。</p>
<p>下面是可识别的选项：</p>
<p>-n<br>    仅打印用p命令或s命令标记指定的行</p>
<p>-e cmd<br>    下一个参数是编辑命令。当指定多个脚本时很有用。</p>
<p>-f file<br>    下一个参数是一个包含编辑命令的文件。</p>
<p>如果脚本的第一行是”#n”，sed将按-n指定的方式工作。</p>
<p>频繁使用sed脚本通常是通过shell脚本来调用的。</p>
<h3 id="sed命令语法"><a href="#sed命令语法" class="headerlink" title="sed命令语法"></a>sed命令语法</h3><p>sed命令的一般形式为：</p>
<pre><code>[address[,address]][!]command[arguments]
</code></pre><p>sed将每个输入行拷贝到一个模式空间。sed指令由地址和编辑命令组成。如果命令的地址和模式空间中的行匹配，那么这个命令将被应用于匹配行。如果一个命令没有地址，那么它被应用于每个输入行。如果一个命令改变了模式空间的内容，后续的命令地址将被应用与模式空间中的当前行，而不是原始的输入行。</p>
<h4 id="模式寻址"><a href="#模式寻址" class="headerlink" title="模式寻址"></a>模式寻址</h4><p>地址可以是一个行号或是由斜杠包含着的一个模式（/pattern/）。模式是用正则表达式表示的。另外，\n可以用来与模式空间（N命令的结果）的任意换行符匹配，但模式空间底部的换行符除外。<br>如果没有指定模式，相应的命令将被应用于所有的行。如果只指定一个地址，那么相应的命令将被应用于和这个地址匹配的行。如果指定了两个用逗号分隔的地址，这个命令将被应用于位于第一个和第二个地址范围之间的所有行。一些命令只接收一个地址，包括a,i,r,q和=。</p>
<p>在地址后面的”!”操作符使sed将相应的命令作用于所有与该地址不匹配的行。</p>
<p>大括号（{}）被sed用于地址的嵌套或对同一个地址应用多个命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[/pattern/[,/pattern/]] &#123;</div><div class="line">	command1</div><div class="line">	command2</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>左大括号必须在一行的末尾，而右括号必须单独在一行。确保大括号后面没有空格。</p>
<h4 id="sed中的正则表达式元字符"><a href="#sed中的正则表达式元字符" class="headerlink" title="sed中的正则表达式元字符"></a>sed中的正则表达式元字符</h4><p>.<br>    匹配除换行符以为的任意单个字符</p>
<p>*<br>    匹配任意个（包括0个）在它前面的字符（包括由正则表达式指定的字符）</p>
<p>[…]<br>    匹配广括号中的字符中的任意一个字符。其它所有的元字符被指定为其中成员时都会失去它们原来的含义。如果方括号第一个字符为脱字符（^）则匹配除了换行符和列出的那些字符以为的所有字符。连字符（-）用来表示字符的范围。如果其中第一个字符为右方括号（]），则表示它是这个类的成员。</p>
<p>{n,m}<br>    它前面的某个范围内单个字符出现的次数（保护正则表达式指定的字符）。{n}将匹配n次出现，{n,}匹配大于等于n次出现的。</p>
<p>^<br>    定位位于行起始位置后面的正则表达式。只有当^符号出现在正则表达式的起始位置时才是特殊的。</p>
<p>$<br>    定位位于行末尾的正则表达式，只有当$符号出现在正则表达式的末尾时才是特殊的。</p>
<p>\<br>    转义随后的特殊字符</p>
<p>( )<br>    将包含在””和””之间的模式保存到一个特殊的保持空间。用这种方法在一行中可以最多保存9个模式。用转义序列”\1″ 到 “\9″ 可以重新使用它们。</p>
<p>\n<br>    匹配前面””和””保存的第n个模式，这里n是一个从1到9的数字，前面保存的模式从行的左边开始编号。</p>
<p>&amp;<br>    当在替换字符串中使用时打印整个被匹配的文本</p>
<h4 id="sed命令参考"><a href="#sed命令参考" class="headerlink" title="sed命令参考"></a>sed命令参考</h4><p>: :lable<br>    在脚本中标记一行，用于实现由b或t的控制转移。label最多可以包含7个字符。（GNU sed允许标签的长度任意）</p>
<p>= [address]=<br>    将所寻址的行编号写到标准输出。</p>
<p>a [address]a\ .. text<br>    在与address匹配的每行后面追加text。如果text多于一行，必须用反斜杠将这些行前面的换行符“隐藏”起来。text将被没有用这种方法隐藏的第一个换行符结束。text在模式空间中不是可用的并且后续命令不能应用于它。当编辑命令的列表用完时这个命令的结果将被输送到标准输出，而不管在模式空间中的当前行发生了什么。</p>
<p>c [address1[,address2]]c \ .. text<br>    用text代替（改变）由地址选定的行。当指定的是一个行范围时，将所有的这些行为作为一个组由text的一个副本来代替。每个text行后面的换行符必须用反斜杠将其转义，但最后一行除外。实际上，模式空间的内容被删除，因此后续的命令不能应用于它（或应用于text）</p>
<p>d [address1[,address2]]d<br>    从模式空间中删除行。因此行没有被传递到标准输出。一个新的输入行被读取，并用脚本的第一个命令来编辑。</p>
<p>D [address1[,address2]]D<br>    删除由命令N穿件的多行模式空间中的第一部分（直接嵌入的换行符），并且用脚本的第一条命令恢复编辑。如果这个命令使模式空间为空，那么将读取一个新的输入行，和执行了d命令。</p>
<p>g [address1[,address2]]g<br>    将保持空间中的内容复制到模式空间。如果保持空间为空，则将换行符添加到模式空间。</p>
<p>G [address1[,address2]]G<br>    将保持空间中的内容追加到模式空间。如果保持空间为空，则将换行符添加到模式空间。</p>
<p>h [address1[,address2]]h<br>    将模式空间的内容复制到保持空间，即一个特殊的临时缓冲区。保持空间的当前内容被清楚。</p>
<p>H [address1[,address2]]H<br>    将换行符和模式空间的内容追加到保持空间中，即使保持空间为空，这个命令也追加换行符。</p>
<p>i [address]i\ .. text<br>    将text插入到每个和address匹配的行的前面。</p>
<p>l [address1[,address2]]l<br>    列出模式空间的内容，将不可打印的字符表示为ASCII码。长的行被折行。</p>
<p>n [address1[,address2]]n<br>    读取下一个输入行到模式空间。当前行被送到标准输出。新行成为当前行并递增计数器。将控制转到n后面的命令，而不是恢复到脚本的顶部。</p>
<p>N [address1[,address2]]N<br>    将下一个输入行追加到模式空的内容之后；新添加的行与模式空间的当前内容用换行符分隔（这个命令用于实现两行的模式匹配。利用\n来匹配嵌入的换行符，则可以实现多行模式匹配）</p>
<p>p [address1[,address2]]p<br>    打印所寻址的行。注意这将导致输出的重复，除非默认的输出用”#n”或”-n”命令行选项限制。常用于改变流控制（d,n,b）的命令之前并可能阻止当前行被输出。</p>
<p>P [address1[,address2]]P<br>    打印由N命令创建的多行模式空间的地一部分（直接嵌入的换行符）。如果没有将N应用于某一行则和p相同。</p>
<p>q [address]q<br>    当遇到address时退出。寻址的行首先被写到输出（如果没有限制默认输出），包括用前面的a或r命令为它追加的文本。</p>
<p>r [address]r file<br>    读取file的内容并追加到模式空间内容的后面。必须在r和文件名file之间保留一个空格。</p>
<p>s [address1[,address2]]s/pattern/replacement/[flags]<br>    用replacement代替每个寻址行的pattern。如果使用了模式地址，那么模式//表示最后指定的模式地址。可指定下面的标志。</p>
<p>n<br>    替代每个寻址的行的地n个/pattern/。n是1到512之间的任意数值，并默认致为1。</p>
<p>g<br>    替代每个寻址的行的所有/pattern/，而不只是第一个。</p>
<p>p<br>    如果替换成功则打印这一行。如果成功进行了多次替换，将打印这个行的多个副本。</p>
<p>w file<br>    如果发生一次替换则将这行写入file。最多可以打开10个不同的file。</p>
<p>t [address1[,address2]]t [label]<br>    测试在寻址的行范围内是否成功执行了替换，如果是，则转移到有lable标志的行。如果没有给出lable，控制转移到脚本的底部。</p>
<p>w [address1[,address2]]w file<br>    将模式空间的内容追加到file。这个动作是在遇到命令时发生而不是在输出模式空间内容时发生。必须在w和这个文件名之间保留一个空格。在脚本中可以打开的最大文件数是10。如果文件不存在，这个命令将创建一个文件。如果文件存在，则每次执行脚步时将修改其内容，多重写入命令直接将输出写入到同一个文件并追加到这个文件的末端。</p>
<p>x [address1[,address2]]x<br>    交换模式空间和保持空间的内容。</p>
<p>y [address1[,address2]]y/abc/xyz/<br>    安位置将字符串abc中的字符转换成字符串xyz中的相应该字符。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/13/weekly-movie-treeoflife/" itemprop="url">
                  每周一荐：《生命之树》、《水上音乐》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-13T08:00:00+08:00" content="2012-04-13">
              2012-04-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/每周一荐/" itemprop="url" rel="index">
                    <span itemprop="name">每周一荐</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/04/13/weekly-movie-treeoflife/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/04/13/weekly-movie-treeoflife/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="电影：《生命之树》"><a href="#电影：《生命之树》" class="headerlink" title="电影：《生命之树》"></a>电影：《生命之树》</h3><p>《生命之树》由泰伦斯·马力克导演。故事开始于一个1950年代，生活在美国中西部的家庭的杰克在童年时收到双亲两种矛盾的教育。成年后的杰克渐渐迷失了自己，发现他在现代社会失去了灵魂，他寻觅生命的原初以及意义的答案，拷问信仰的存在，最终明白了生命的真谛。<br>故事讲述生长在美国中西部的11岁少年杰克的成长变迁。他的家庭由父母和三兄弟组成。在一个孩子眼中，起初一切都是新奇的。他从母亲身上看到了慈爱，而他的父亲告诉他，这个世界的生存法则就是把自己放在首位。在成长过程中，杰克竭力想要调和双亲相悖的人生观。</p>
<p><img src="/images/2012-04-13-1.jpg" alt="生命之树"></p>
<p>故事开始于一个50年代，生活在美国中西部的家庭，电影跟随着大儿子杰克的生命展开，穿过其无辜天真的童年到幻灭的成人时代。</p>
<p>西恩·潘饰演的杰克出生于美国中西部，父亲奥布莱恩是一个颇为守旧的农民，经常强调要以自己为中心，去做一个纯爷们真汉子，而母亲则是温柔又感性。杰克就在双亲不同的教育中长大成人，渐渐疲惫了现代都市生活的杰克突然发现自己已经迷失了。最终是父母的教育让他明白了，  生命之树 电影生命的真谛就在于家庭之中。</p>
<p>影片中母亲便说：“人生分为两种活法，一种是自然的，一种是圣洁的，要看你自己选择哪一种。”影片预告片最后一句仍是母亲的教导：“只要爱过，人生就不算白过。”</p>
<blockquote>
<p>There are two ways in life: the way of nature, and the way of Grace. You must choose which one you will follow.</p>
</blockquote>
<h3 id="音乐：《水上音乐》"><a href="#音乐：《水上音乐》" class="headerlink" title="音乐：《水上音乐》"></a>音乐：《水上音乐》</h3><p>《水上音乐》，又称《水乐》、《船乐》。亨德尔作于1717年，是一部管弦乐组曲。传说是在英国伦敦泰晤士河上为新即位的英皇乔治一世演奏的，故有“水上音乐”的美名。全部组曲由二十首小曲组成，开始是一首法国式的前奏曲，其后是布莱舞曲、小步舞曲等各种形式的舞曲，同时也有缓慢乐章。乐器使用了小提琴、低音提琴、日耳曼横笛、法兰西横笛、双簧管、圆号、小号等。</p>
<p><img src="/images/2012-04-13-2.jpg" alt="水上音乐"></p>
<p>现在我们演奏和听到的《水上音乐》已经不是亨德尔的原作，而是后来英国曼彻斯特的哈莱乐队指挥哈蒂（harty）爵士为近代乐队所改编的乐曲，共有六个乐章： 快板、布莱舞曲、小步舞曲、号角舞曲（一种古代的三拍子舞曲）、行板、坚决的快板。由于旋律优美动听，节奏轻巧而流传后世。这里我们选录了六个乐章中的第一乐章、第二乐章和第六乐章。</p>
<p>第一乐章为庄严的序曲，乐曲气氛活泼热烈，开始由圆号与弦乐器共同奏出轻盈的同音反复和华美的颤音，相互对答。</p>
<p>第二乐章为舞曲般的旋律，气氛轻松舒展。这里选录的第二主题为小调，抒情性很强。</p>
<p>第六乐章为坚决的快板，威武雄壮。这一部分是全曲最为精彩的篇章。</p>
<p>亨德尔的《水上音乐》，乃亨德尔访问伦敦时，为伦敦的王室而作，作于1715年。当时，在泰晤士河上夜游，是皇室喜爱的夏季活动。乘坐挂着彩灯的游船，周围有成群结队簇拥着的大小帆船，国王乘坐的船旁有音乐家的船演奏音乐。亨德尔一共参加了三次这样的夜游活动（1715年8月22日，1717年7月17日，1736年4月26日），他的《水上音乐》最早的原始手稿其实已丢失，最细致的复原本乃莱德利希所复制。这部作品根据亨德尔的三次夜游，编为三组。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/11/posa2-wrapper-facade/" itemprop="url">
                  POSA2：Wrapper Facade模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-11T00:05:00+08:00" content="2012-04-11">
              2012-04-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/04/11/posa2-wrapper-facade/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/04/11/posa2-wrapper-facade/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>用更加简洁、健壮、可移植、可维护和内聚的面向对象接口，封装已存在的非面向对象API的函数和相关数据。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>使用已存在的非面向对象的API提供的服务或机制，开发可维护和进化的应用。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>简洁的代码比复杂的代码更加健壮，因为它易于理解和维护  </li>
<li>可移植的软件可以容易的在不同的操作系统、编译器和硬件平台之间移植  </li>
<li>提高软件可维护性，会降低开发生命周期的开销  </li>
<li>高内聚的组件，易于学习、维护和增强  </li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>结构</strong>：</p>
<p><img src="/images/2012-04-11-1.jpg" alt="POSA"></p>
<p><strong>行为</strong>：</p>
<p><img src="/images/2012-04-11-2.jpg" alt="POSA"></p>
<p><strong>实现</strong>：</p>
<ol>
<li>识别已有的过程式API中内聚的抽象和关系  </li>
<li>把内聚的函数放入包装外观类中（Wrapper Facade Class）<br> 2.1. 创建内聚类<br> 2.2. 把多个独立的函数放入其中<br> 2.3. 自动创建和销毁，可以考虑使用构造函数和析构函数<br> 2.4. 选择间接的等级<br> 2.5. 检查依赖与特定平台变化的代码  </li>
<li>考虑以可控地访问实现细节（Escape-Hatch）  </li>
<li>开发一套错误处理机制  </li>
<li>定义相关的帮助类（可选）  </li>
</ol>
<p><strong>已知应用</strong></p>
<ul>
<li>MFC  </li>
<li>ACE  </li>
<li>效果  </li>
</ul>
<p><strong>优势</strong>：</p>
<ol>
<li>内聚的高层面向对象接口</li>
<li>易于移植和维护</li>
<li>模块化、可重用、可配置</li>
</ol>
<p><strong>不足</strong>：</p>
<ol>
<li>功能缩水（Escape-Hatch可以解决）</li>
<li>性能降低（类函数内联可以解决）</li>
<li>编程语言和编译器的限制</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/07/mediawiki-vim/" itemprop="url">
                  MediaWiki编辑工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-07T02:18:00+08:00" content="2012-04-07">
              2012-04-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/04/07/mediawiki-vim/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/04/07/mediawiki-vim/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-vim-wikimedia-vim"><a href="#1-vim-wikimedia-vim" class="headerlink" title="1. vim+wikimedia.vim"></a>1. vim+wikimedia.vim</h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>使用vim的wikimedia.vim插件，可以高亮wiki语法关键字，自动补齐等功能。对于喜欢用vim编辑器的人来说，用此方式编辑wiki再好不过了。可以自动识别的文件类型为*.wiki，或者set filetype=mediawiki。</p>
<p><img src="/images/2012-04-07-1.jpg" alt="vim"></p>
<h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><ol>
<li>下载VIM插件：<a href="http://www.vim.org/scripts/script.php?script_id=1787" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1787</a>  </li>
<li>解压缩到$HOME/.vim/或$VIMDIR/vimfile/目录下面  </li>
<li>确认：$HOME/.vim/syntax/mediawiki.vim  </li>
<li>确认：$HOME/.vim/ftdetect/mediawiki.vim  </li>
</ol>
<h3 id="2-WYSIWYG-CKEditor"><a href="#2-WYSIWYG-CKEditor" class="headerlink" title="2. WYSIWYG(CKEditor)"></a>2. WYSIWYG(CKEditor)</h3><h4 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h4><p>该MediaWiki扩展，使得用户可以以WYSIWYG方式编辑WIKI，使用了CKEditor。</p>
<h4 id="安装：-1"><a href="#安装：-1" class="headerlink" title="安装："></a>安装：</h4><ol>
<li>下载WYSIWYG包：<a href="http://www.smwplus.com/index.php/Help:WYSIWYG_extension_1.6.0" target="_blank" rel="external">http://www.smwplus.com/index.php/Help:WYSIWYG_extension_1.6.0</a>   </li>
<li>解压缩  </li>
<li>复制wysiwyg-1.6.0_0\extensions\WYSIWYG 到 ..\htdocs\mediawiki\extensions  </li>
<li><p>配置MediaWiki的LocalSettings.php   </p>
<p> require_once(“$IP/extensions/WYSIWYG/WYSIWYG.php”);</p>
</li>
<li><p>设置可以使用者的权限   </p>
</li>
</ol>
<p>所有人可用：<code>$wgGroupPermissions[&#39;*&#39;][&#39;wysiwyg&#39;]=true;</code></p>
<p>注册用户可以：<code>$wgGroupPermissions[&#39;registered_users&#39;][&#39;wysiwyg&#39;]=true;</code></p>
<p><img src="/images/2012-04-07-2.jpg" alt="CKEditor"></p>
<h3 id="Microsoft-Office-Word-Add-in-For-MediaWiki"><a href="#Microsoft-Office-Word-Add-in-For-MediaWiki" class="headerlink" title="Microsoft Office Word Add-in For MediaWiki"></a>Microsoft Office Word Add-in For MediaWiki</h3><h4 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h4><p>可以将MS Word 2007/2012的文档直接保存为MediaWiki语法格式的文件。</p>
<h4 id="安装：-2"><a href="#安装：-2" class="headerlink" title="安装："></a>安装：</h4><p>下载WORD插件：<a href="http://www.microsoft.com/download/en/details.aspx?id=12298" target="_blank" rel="external">http://www.microsoft.com/download/en/details.aspx?id=12298</a></p>
<p>运行插件安装程序</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/06/weekly-distributed-patttern/" itemprop="url">
                  每周一荐：分布式计算的模式语言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-06T01:08:00+08:00" content="2012-04-06">
              2012-04-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/每周一荐/" itemprop="url" rel="index">
                    <span itemprop="name">每周一荐</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/04/06/weekly-distributed-patttern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/04/06/weekly-distributed-patttern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="书籍：《面向模式的软件架构IV：分布式计算的模式语言》"><a href="#书籍：《面向模式的软件架构IV：分布式计算的模式语言》" class="headerlink" title="书籍：《面向模式的软件架构IV：分布式计算的模式语言》"></a>书籍：《面向模式的软件架构IV：分布式计算的模式语言》</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>迄今为止，人们提出的软件开发模式有不少是关于分布式计算的，但人们始终无法以完整的视角了解分布式计算中各种模式是如何协同工作、取长补短的。构建复杂的分布式系统似乎成为了永远也无法精通的一门手艺。本书的出版改变了这一切。</p>
<p>本书是经典的POSA系列的第4卷，介绍了一种模式设计语言，将分布式系统开发中的114个模式联系起来。书中首先介绍了一些分布式系统和模式语言的概念，然后通过一个仓库管理流程控制系统的例子，介绍如何使用模式语言设计分布式系统，最后介绍模式语言本身。</p>
<p><img src="/images/2012-04-06-1.jpg" alt="分布式计算的模式语言"></p>
<p>使用这一模式语言，人们可以有效地解决许多与分布式系统开发相关的技术问题，如</p>
<p>★ 对象交互</p>
<p>★ 接口与组件划分</p>
<p>★ 应用控制</p>
<p>★ 资源管理</p>
<p>★ 并发与同步</p>
<p>本书从实用角度展示了如何从现有的主要模式中整合出一门全面的模式语言，用于开发分布式计算中间件及应用程序。作为该领域在市场上唯一统揽全局的书，它将给读者带来醍醐灌顶的感觉！</p>
<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p>以前总是困惑自己正在开发的游戏网络通信框架是前人怎么想出来的，看着底层那些乱七八糟的代码，即膜拜又感到不解。看到本书讲的一个模式：Half-Sync/Half-Async 顿时感觉清楚了许多。这本书对于很多模式都讲的不是很细致，只是粗略总结一下，详细的用法和介绍还是要去参考一些《面向模式的软件架构I》、《面向模式的软件架构II》、《设计模式：可复用面向对象基础》。对于网络框架的架构这本书和《面向模式的软件架构II》必备。</p>
<p>下面把书中提及到的分布式相关的模式列举出来：</p>
<p><strong>从混沌到结构（From Mud To Structure ）</strong></p>
<ol>
<li>领域模型（Domain Model）  </li>
<li>分层（Layers）  </li>
<li>MVC模式（Model-View-Controller）  </li>
<li>PAC模式（Presentation-Abastraction-Control）  </li>
<li>微内核（Microkernel）  </li>
<li>反射（Reflection）  </li>
<li>管道和过滤器（Pipes and Filters）  </li>
<li>共享仓库（Shared Repository）  </li>
<li>黑板（Blackboard）  </li>
<li>领域对象（Domain Object）  </li>
</ol>
<p><strong>分布式架构</strong></p>
<ol>
<li>消息机制（Messaging）  </li>
<li>消息通道（Message Channel）  </li>
<li>消息端点（Message Endpoint）  </li>
<li>消息转换器（Message Translator）  </li>
<li>消息路由（Message Router）  </li>
<li>发布-订阅者（Publisher-Subscriber）  </li>
<li>代理者（Broker）   </li>
<li>客户端代理（Client Proxy）  </li>
<li>请求者（Requestor）  </li>
<li>调用者（Invoker）  </li>
<li>客户端请求处理（Client Request Handler）  </li>
<li>服务端请求处理（Server Request Handler）  </li>
</ol>
<p><strong>事件分派（Event Demultiplexing and Dispatching）</strong></p>
<ol>
<li>Reator  </li>
<li>Proator  </li>
<li>Acceptor-Connector  </li>
<li>Asynchronous Completion Token  </li>
</ol>
<p><strong>接口划分（Interface Partitioning ）</strong></p>
<ol>
<li>Explicit Interface  </li>
<li>Extension Interface  </li>
<li>Introspective Interface  </li>
<li>动态调用接口（Dynamic Invocation Interface）  </li>
<li>代理（Proxy）  </li>
<li>业务委托（Business Delegate）  </li>
<li>外观模式（Facade）  </li>
<li>复合方法（Combined Method）  </li>
<li>迭代器（Iterator）  </li>
<li>枚举方法（Enumeration Method）  </li>
<li>批处理方法（Batch Method）  </li>
</ol>
<p><strong>组件划分（Component Partitioning）</strong></p>
<ol>
<li>封装实现（Encapsulated Implementation）  </li>
<li>整体-部分（Whole-Part）  </li>
<li>组合模式（Composite）  </li>
<li>主从模式（Master-Slave）  </li>
<li>Half-Object plus Protocol  </li>
<li>Replicated Component Group  </li>
</ol>
<p><strong>应用控制（Application Control）</strong></p>
<ol>
<li>页控制器（Page Controller）  </li>
<li>前端控制器（Front Controller）  </li>
<li>应用控制器（Application Controller）  </li>
<li>命令处理器（Command Processor）  </li>
<li>模板视图（Template View）  </li>
<li>转换视图（Transform View）  </li>
<li>防火墙代理（Firewall Proxy）  </li>
<li>授权（Authorition）  </li>
</ol>
<p><strong>并发（Concurrency）</strong></p>
<ol>
<li>Half-Sync/Half-Async  </li>
<li>Leader/Followers  </li>
<li>Active Object  </li>
<li>Monitor Object  </li>
</ol>
<p><strong>同步（Synchronization）</strong></p>
<ol>
<li>守护挂起（Guarded Suspension）  </li>
<li>Future  </li>
<li>线程安全接口（Thread-Safe Interface）  </li>
<li>双检查锁（Double-Checked Locking）  </li>
<li>策略锁定（Strategized Locking）  </li>
<li>范围锁定（Scoped Locking）  </li>
<li>线程指定存储（Thread-Specific Storage）  </li>
<li>复制值（Copied Value）  </li>
<li>常量值（Immutable Value）  </li>
</ol>
<p><strong>对象交互（Object Interaction）</strong></p>
<ol>
<li>观察者（Observer）  </li>
<li>双分配（Double Dispatch）  </li>
<li>中间者（Mediator）  </li>
<li>命令模式（Command）  </li>
<li>备忘录模式（Memento）  </li>
<li>环境对象（Context Object）  </li>
<li>数据传输对象（Data Transfer Object）  </li>
<li>消息（Message）  </li>
</ol>
<p><strong>适配和扩展（Adaptation and Extension）</strong></p>
<ol>
<li>桥接模式（Bridge）  </li>
<li>对象适配器（Object Adapter）  </li>
<li>责任链（Chain of Responsibility）  </li>
<li>解释器（Interpreter）  </li>
<li>插入器（Interceptor）  </li>
<li>访问者（Visitor）  </li>
<li>修饰模式（Decorator）  </li>
<li>Execute-Around Object  </li>
<li>模板方法（Template Method）  </li>
<li>策略模式（Strategy）  </li>
<li>空对象（NULL Object）  </li>
<li>封装外观（Wrapper Facade）  </li>
<li>Declarative Component Configuration  </li>
</ol>
<p><strong>模态行为（Modal Behavior）</strong></p>
<ol>
<li>状态对象（Objects for States）  </li>
<li>状态方法（Methods for States）  </li>
<li>状态集合（Collections for States）  </li>
</ol>
<p><strong>资源管理（Resource Management）</strong></p>
<ol>
<li>容器（Container）  </li>
<li>组件配置（Component Configurator）  </li>
<li>对象管理器（Object Manager）  </li>
<li>查找（Lookup）  </li>
<li>虚拟代理（Virtual Proxy）  </li>
<li>生命周期回调（Lifecyce Callback）  </li>
<li>任务协调器（Task Coordinator）  </li>
<li>资源池（Resource Pool）  </li>
<li>资源缓冲（Resource Cache）  </li>
<li>Layzy Acquisition  </li>
<li>Eager Acquisition  </li>
<li>Partial Acquisition  </li>
<li>Activator  </li>
<li>Evictor  </li>
<li>Leasing  </li>
<li>自动垃圾回收（Automated Garbage Collection）  </li>
<li>计数句柄（Counting Handle）  </li>
<li>抽象工厂（Abstract Factory）  </li>
<li>构建者（Builder）  </li>
<li>工厂方法（Factory Method）  </li>
<li>Disposal Method  </li>
</ol>
<p><strong>数据库访问（Database Access）</strong></p>
<ol>
<li>数据库访问层（Database Access Layer）  </li>
<li>数据映射（Data Mapper）  </li>
<li>行数据网关（Row Data Gateway）  </li>
<li>表格数据网关闭（Table Data Gateway）  </li>
<li>Active Record  </li>
</ol>
<p>以上模式详细内容还需要更加深入的应用才能很好的掌握。继续学习…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/03/09/weekly-refactoring/" itemprop="url">
                  每周一荐：重构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-03-09T09:07:00+08:00" content="2012-03-09">
              2012-03-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/每周一荐/" itemprop="url" rel="index">
                    <span itemprop="name">每周一荐</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/03/09/weekly-refactoring/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/03/09/weekly-refactoring/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="书籍：《重构：改善既有代码的设计》"><a href="#书籍：《重构：改善既有代码的设计》" class="headerlink" title="书籍：《重构：改善既有代码的设计》"></a>书籍：《重构：改善既有代码的设计》</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Martin Fowler和《重构:改善既有代码的设计》(中文版)另几位作者清楚揭示了重构过程，他们为面向对象软件开发所做的贡献，难以衡量。《重构:改善既有代码的设计》(中文版)解释重构的原理（principles）和最佳实践方式（best practices），并指出何时何地你应该开始挖掘你的代码以求改善。《重构:改善既有代码的设计》(中文版)的核心是一份完整的重构名录（catalog of refactoring），其中每一项都介绍一种经过实证的代码变换手法（code transformation）的动机和技术。某些项目如Extract Method和Move Field看起来可能很浅显，但不要掉以轻心，因为理解这类技术正是有条不紊地进行重构的关键。</p>
<p><img src="/images/2012-03-09-1.jpg" alt="重构"></p>
<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><h5 id="Composing-Methods"><a href="#Composing-Methods" class="headerlink" title="Composing Methods"></a>Composing Methods</h5><p>Extract Method: 你有一段代码可以被组织在一起并独立起来，将其放入一个独立的函数，并让函数名称解释该函数的用途</p>
<p>Inline Method: 一个函数，其本体和名称同样清楚易懂，在函数调用点插入函数本体，然后移除该函数</p>
<p>Inline Temp: 你有一个临时变量，只被一个简单表达式赋值一次，将所有对该变量的引用，替换为对它赋值的那个表达式自身</p>
<p>Replace Temp With Query: 你的程序以一个临时变量保存某一个表达式的运算结果，将这个表达式提炼到一个独立的函数中，将这个临时变量的所有被引用点替换为对新函数的调用。新函数也可以被其它函数使用。</p>
<p>Introduce Explaining Variable: 你有个复杂的表达式，将该复杂的表达式或其中的一部分的结果放进一个临时变量，以此变量名称来解释表达式的用途</p>
<p>Split Temporary Variable: 你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不是一个集用临时变量。针对每次赋值，创造一个独立的、对应的临时变量。</p>
<p>Remove Assignments to Parameters: 你的代码对一个参数进行赋值动作，以一个临时变量取代该参数的位置</p>
<p>Replace Method With Method Object: 你有一个大型函数，其中对局部变量的使用，使你无法使用Extract Method。将这个函数放入一个单独的对象，如此一来局部变量就变成了对象内的值域，然后你尅在同一个对象中将这个大型函数分解为数个小型函数。</p>
<p>Substitute Algorithm: 你想要把某个算法替换为另一个更清楚的算法，将函数本体替换为另外一个算法。</p>
<h5 id="Moving-Feature-Between-Object"><a href="#Moving-Feature-Between-Object" class="headerlink" title="Moving  Feature Between Object"></a>Moving  Feature Between Object</h5><p>Move Method: 你的程序中，有个函数与其所驻class之外的另外一个class进行更多交流（调用或者，或被后者调用）。在该函数最长引用的class中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全删除。</p>
<p>Move Field: 你的程序中，某个值域被其所驻class之外的另一个classs更多的用到。在target class建立一个new field，修改source field的所有用户，令它们改用 new field。</p>
<p>Extract Class: 某个class做了应该由两个classes做的事。建立一个新class，将相关的值域和函数从旧class搬移到新class。</p>
<p>Inline Class: 你的某个class没有做太多事情（没有承担足够责任）。将class的所有特性搬移到另外一个class中，然后移除原class。</p>
<p>Hide Delgate: 客户直接调用server object（服务对象）的delegate class。在server端（某个class）建立客户所需的所有函数，用以隐藏委托关系。</p>
<p>Remove Middle Man: 某个class做了过多的简单委托动作。让客户端直接调用delegate（受托类）。</p>
<p>Introduce Foreign Method: 你所使用的server class 需要一个额外的函数，但你无法修改这个class。在client class中建立一个函数，并以一个server class实体作为第一个参数。</p>
<p>Introduce Local Extension: 你所使用的server class需要一些额外的函数，但你无法修改这个class。建立一个新class，使它包含这些额外函数。让这个扩展品成为source class的subclass（子类）或 wrapper（外覆类）。</p>
<h5 id="Organizing-Data"><a href="#Organizing-Data" class="headerlink" title="Organizing Data"></a>Organizing Data</h5><p>Self Encapsluate: 你直接访问一个值域，但与值域直接的耦合关系逐渐变得笨拙。为这个值域建getting/setting methods，并且以这些函数来访问值域。</p>
<p>Replace Data Value with Object: 你有一比数据项，需要额外的数据和行为。你将这笔数据变成一个对象。</p>
<p>Change Value to Reference: 你有一个class，衍生出许多相等实体，你希望将它们替换为单一对象。将这个value object变成一个reference object。</p>
<p>Change Reference to Value: 你有个reference object，很小且不可变，而且不易管理。将它鞭策一个value object。</p>
<p>Replace Array with Object: 你有一个数组，其中的元素各自代表不同的东西。以对象替换数组，对于数组中的每个元素，以一个值域表示。</p>
<p>Duplicate Observed Object: 你有一些domain data置于GUI控件中，而domain Method 需要访问之。将该数据copy 到一个domain object中，建立一个Observer模式，用以对domain object和GUI object内的重复数据进行同步控制。</p>
<p>Change Unidirectional Association to Bidirectional : 两个classes都需要对方的特性，但期间只有一条单向连接。添加一个反向指针，并使修改函数能够同时更新两条连接。</p>
<p>Change Bidirectional Association to Unidirectional: 两个classes直接有双向关联，但其中一个class如今不再需要另一个class的特性。去除不必要的关联。</p>
<p>Replace Magic Number with Symbolic Constant: 你有一个字面数值，带有特别的含义。创造一个常量，根据其意义为它命名，并将上述的字符数值替换为这个常量。</p>
<p>Encapsulate Filed: 你在class中一个public值域，将它声明为private，并提供相应得分访问函数。</p>
<p>Encapsulate Collection: 有个函数返回一个群集，让这个函数返回该群集的一个只读映像，并在这个class中提供添加/删除群集元素的函数。</p>
<p>Replace Record with Data class: 你需要面对传统编程环境中的record struct。为该record创建一个哑数据对象。</p>
<p>Replace Type Code with Class : class之中有一个数值型别码，但它并不影响class的行为。以一个新class替换该数值型别码。</p>
<p>Replace Type Code with Subclass: 你有一个不可变的type code，它会影响class的行为。以一个subclass取代这个type code。</p>
<p>Replace Type Code with State/Stratgery: 你有 一个type code，它会影响class的行为，但你无法使用subclassing。以state object取代type code。</p>
<p>Replace Subclass with Fields: 你的各个subclass的唯一差别只在返回常量数据的函数身上。修改这些函数，使它们返回superclass中的某个值域，然后销毁subclass。</p>
<h5 id="Simplifing-Conditional-Expression"><a href="#Simplifing-Conditional-Expression" class="headerlink" title="Simplifing Conditional Expression"></a>Simplifing Conditional Expression</h5><p>Decompose Condtional: 你有一个复杂的条件语句，从if、then、else三个段落中分别提取出独立函数。</p>
<p>Consolidate Condtional Expression: 你有一系列条件测试，都得到相同的结果。将这些测试合并为一个条件式，并将这个条件式提炼成为一个独立函数。</p>
<p>Consolidate Duplicate Condtional Fragment: 在条件式的每个分支上有着相同的一段代码。将这段代码搬移到条件式之外。</p>
<p>Remove Control Flag: 在一系列布尔表达式中，某个变量带有控制标记的作用。以break语句或return语句取代控制标记。</p>
<p>Replace Nested Condtional wiht Guard Clauses: 函数中的条件逻辑使人难以看清楚正常的执行路径。使用卫语句表现所以特殊情况。</p>
<p>Replace Conditional with Polymorphism: 你手上有个条件式，它根据对象型别的不同而选择不同的行为。将这个条件表达式的每个分支放进一个subclass内的覆写函数中，然后将原函数声明为抽象函数。</p>
<p>Introduce Null Object: 你需要再三检查某物是否为null value，将null value替换为null object。</p>
<p>Introduce Assertion: 某一段代码需要对程序状态作出某种假设，以断言明确表现这种假设。</p>
<h5 id="Making-Method-Calls-Simpler"><a href="#Making-Method-Calls-Simpler" class="headerlink" title="Making Method Calls Simpler"></a>Making Method Calls Simpler</h5><p>Rename Method: 函数的名称未能揭示函数的用途，修改函数的名称。</p>
<p>Add Parameter : 某个函数需要从调用端得到更多信息，为此函数添加一个对象参数，让该对象带进函数所需信息。</p>
<p>Remove Parameter: 函数本体不再需要某个参数，将该参数删除。</p>
<p>Seperate Query from Modifier: 某个函数既返回对象状态值，又修改对象状态，建立两个不同的函数，其中一个负责查下，另一个负责修改。</p>
<p>Parameterize Method: 若干函数做了类似的工作，但在函数本体中却包含了不同的值，建立一个单一函数，以参数表达那些不同的值。</p>
<p>Replace Parameter with Explict Methods: 你有一个函数，其内完全取决于参数采取不同的反应。针对该参数的每一个可能值，建立一个对立函数。</p>
<p>Preserver Whole Object :你从某个对象中取出若干值，将他们昨晚某一次函数调用时的参数。改使用传递整个对象。</p>
<p>Replace Parameter with Methods: 对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接收该参数的函数也可以调用前一个函数。让参数接受者去除该项参数，并直接调用前一个函数。</p>
<p>Introduce Parameter Object :  某些参数总是很自然的同时出现，以一个对象取代这些参数。</p>
<p>Remove Setting Method: 你的clas中的某个值域，应该在对象初始时被设值，然后就不再改变。去掉该值域的设值函数。</p>
<p>Hide Method: 有一个函数，从来没有被其它任何class用到。将这个函数修改为private。</p>
<p>Replace Constructor with Factory Method: 你希望在创建对象时不仅仅是对它做简单的建构动作。将构造函数替换为工厂函数。</p>
<p>Encapsulate Downcast: 某个函数返回的对象，需要由函数调用者执行向下转型动作。将down-cast动作移动到函数中。</p>
<p>Replace Error Code with Exception: 某一个函数返回一个特定的代码，用以表示某种错误情况。改用异常。</p>
<p>Replace Exception with Test: 面对一个调用者可预先加以检查的条件，你抛出了一个异常。修改调用者，使它在调用函数之前先做检查。</p>
<h5 id="Dealing-with-Generalization"><a href="#Dealing-with-Generalization" class="headerlink" title="Dealing with Generalization"></a>Dealing with Generalization</h5><p>Pull Up Field: 两个subclass拥有相同的值域，将此一值域移至superclass</p>
<p>Pull Up Method: 有些函数，在各个subclass中产生完全相同的结果，将该函数移至superclass</p>
<p>Pull Up Constructor Body: 你在各个subclass中拥有一些构造函数，他们的本体代码几乎完全一致。在superclass中新建一个构造函数，并在subclass构造函数中调用它</p>
<p>Push Down Method: superclass中的某个函数只与部分而非全部subclass有关。将这个函数移到相关的那些subclass去</p>
<p>Push Down Field: superclass中的某个值域只被部分而非全部subclass用到。将这个值域移到需要它的那些subclass去</p>
<p>Extract Subclass: class中的某些特性只被某些而非全部实体用到。新建一个subclass，将上面所说的那一部分特性移到subclass中</p>
<p>Extract Superclass: 两个class有些相似特性。为这两个classes建立一个superclass，将相同特性移到superclass</p>
<p>Extract Interface: 若干客户使用class接口中的同一子集；或者，两个classes的接口有部分相同。将相同的子集提炼到一个独立的接口中。</p>
<p>Collapse Hierarchy: superclass和subclass直接无太大区别，将它们合为一体。<br>Form Template Method: 你有一些subclasses，其中相应的某些函数以相同的顺序执行类似的措施，但各措施实际上有所不同。将各个措施分别放进独立函数中，并保持它们都有相同的签名式，于是原函数也就变得相同了。然后将原函数移到superclass。</p>
<p>Replace Inheritence with Delegation: 某个subclass只使用superclass接口中的一部分，或是根本不需要继承而来的数据。在subclass中新建一个值域用以保存superclass；调整subclass函数，令他改而委托superclass；然后去掉两者直接的继承关系。</p>
<p>Replace Delegation with Inheritence: 你在两个classes之间使用委托关系，并经常为整个接口编写许多及其简单的请托函数（delegating method），让请托class继承受托class。</p>
<h5 id="Big-Refactoring"><a href="#Big-Refactoring" class="headerlink" title="Big Refactoring"></a>Big Refactoring</h5><p>Tease Apart Inheritance: 某个继承体系同时承担两项责任。建立两个继承体系，并通过委托关系让其中一个可以调用另一个。</p>
<p>Convert Procedural Design to Objects: 你手上有一些代码，以传统的过程化风格写就。将数据记录变成对象，将行为分开，并将行为移入对象之中。</p>
<p>Seperate Domain from Presentation: 某些GUI class之中包含了domain logic。将domain logic分离出来，为它们建立独立的domain classes。</p>
<p>Extract Hierarchy: 你有某些class做了太多工作，其中一部分工作是以大量条件式完成的。建立继承体系，以一个subclass表示一种特殊情况。</p>
<h3 id="书籍：《重构手册》"><a href="#书籍：《重构手册》" class="headerlink" title="书籍：《重构手册》"></a>书籍：《重构手册》</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>利用这本通过示例“说话”的实例手册，可以充分发挥重构的强大功能，改善现有的软件。</p>
<p>身为程序员，你必须具备的一个基本功就是能够找出并改善有问题的代码，使程序能够在软件的整个生命周期中正常运转。重构可谓是安全地改善既有代码设计的一门艺术，由此可以提供高效而可靠的系统，使纷杂凌乱归于平稳有序，并能最大限度地抑制异常的出现！重构可能很难掌握，但是在专业顾问William C.Wake所撰写的这本书中，经由作者娓娓道来，有关内容得以通过一种易于学习的方式展现出来，不仅使学习之旅颇具实效，而且充满乐趣。</p>
<p><img src="/images/2012-03-09-2.jpg" alt="重构"></p>
<p>对于许多人来说，学习重构的最大障碍是如何找出代码的“坏味道（smell）”，即可能存在问题之处。本书并非让你流水帐式地通读这些坏味道，而是确保你对这些坏味道有切实的理解。在此奉上了一系列精心组织的问题，通过这些问题的解决，你将会茅塞顿开，不仅会在更深层次上了解重构，而且还将获得你自己的一些心得体会。Wake采用了实例手册的方式来组织全书，以帮助你了解最为重要的重构技术并将其应用于代码之中。这是一种强调学习的方法，要求你必须充分应用本书所提供的诸多技术。除此之外，这种方法还有一个附带的好处，即尽管当前你所作的工作也许并非重构，利用本书也将有助于你更多地考虑如何创建优质的代码。</p>
<h3 id="书籍：《重构与模式》"><a href="#书籍：《重构与模式》" class="headerlink" title="书籍：《重构与模式》"></a>书籍：《重构与模式》</h3><p>####简介</p>
<p>本书开创性地深入揭示了重构与模式这两种软件开发关键技术之间的联系，说明了通过重构实现模式改善既有的设计，往往优于在新的设计早期使用模式。本书不仅展示了一种应用模式和重构的创新方法，而且有助于读者结合实战深入理解重构和模式。书中讲述了27种重构方式。</p>
<p><img src="/images/2012-03-09-3.jpg" alt="重构"></p>
<p>2012/03/09 09:07 于上海</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/03/04/weekly-design-pattern/" itemprop="url">
                  每周一荐：设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-03-04T14:00:00+08:00" content="2012-03-04">
              2012-03-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/每周一荐/" itemprop="url" rel="index">
                    <span itemprop="name">每周一荐</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2012/03/04/weekly-design-pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/03/04/weekly-design-pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="书籍：《设计模式——改善既有代码的设计》"><a href="#书籍：《设计模式——改善既有代码的设计》" class="headerlink" title="书籍：《设计模式——改善既有代码的设计》"></a>书籍：《设计模式——改善既有代码的设计》</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。书中分类描述了一组设计良好、表达清楚的软件设计模式，这些模式在实用环境下特别有用。</p>
<p><img src="/images/2012-03-04-1.jpg" alt="设计模式"></p>
<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p>23个设计最基础的设计模式，每每读起如醍醐灌顶！不愧为经典之作！</p>
<p><strong>创建型</strong></p>
<p>Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</p>
<p>Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
<p>Factory Method：定义一个用于创建对象的接口，让子类决定实例化那一个类。Factory Method使得一个类的实例化延迟到其子类</p>
<p>Prototype：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<p>Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<p><strong>结构型</strong></p>
<p>Adapter：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作</p>
<p>Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化</p>
<p>Composite：将对象组合成树形结构以表示”部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性</p>
<p>Decorator：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式比生成子类给为灵活</p>
<p>Facade：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得子系统更加容易使用</p>
<p>Flyweight：运行共享技术有效地支持大量细粒度的对象</p>
<p>Proxy：为其它对象提供一种代理以控制对这个对象的访问</p>
<p><strong>行为型</strong></p>
<p>Chain of Responsibility：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>
<p>Command：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作</p>
<p>Interpreter：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</p>
<p>Iterator：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</p>
<p>Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<p>Memento：在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</p>
<p>Observer：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p>
<p>State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类</p>
<p>Strategy：定义一系列的算法，把他们一个个封装起来，并且使它们可互相替换。本模式使得算法可独立与使用它的客户而变化</p>
<p>Template Method：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<p>Visitor：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p>
<h3 id="书籍：《设计模式解析》"><a href="#书籍：《设计模式解析》" class="headerlink" title="书籍：《设计模式解析》"></a>书籍：《设计模式解析》</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>本书以作者自身学习、使用模式和多年来为软件开发人员(包括面向对象技术老兵和新手)讲授模式的经验为基础撰写而成。首先概述了模式的基础知识，以及面向对象分析和设计在当代软件开发中的重要性，随后使用易懂的示例代码阐明了12个最常用的模式，包括它们的基础概念、优点、权衡取舍、实现技术以及需要避免的缺陷，使读者能够理解模式背后的基本原则和动机，理解为什么它们会这样运作。</p>
<p><img src="/images/2012-03-04-2.jpg" alt="设计模式"></p>
<h4 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h4><p><strong>对象、封装、面向对象设计不同视角的定义</strong></p>
<p>视角对象封装面向对象设计概念具有责任的一个实体任何形式的隐藏：实现细节、派生类、设计细节、实例化规则共性分析规约接口集合共性分析、变性分析实现数据和方法集合数据隐藏变性分析</p>
<p><strong>优秀代码的目标</strong>：</p>
<ul>
<li>高效</li>
<li>健壮</li>
<li>灵活</li>
<li>无冗余</li>
<li>可读</li>
<li>可测试</li>
</ul>
<p><strong>面向对象的一些原则和方法</strong></p>
<p>内聚性（cohesion）：例程中操作之间联系的紧密程度</p>
<p>耦合性（coupling）：两个例程之间联系的紧密程度</p>
<p>软件开发的目标：高内聚、松耦合</p>
<p><strong>发现变化并将其封装</strong></p>
<ol>
<li><p>寻找变化，并将它封装在一个单独的类中     </p>
</li>
<li><p>将这个类包含在另一个类</p>
</li>
</ol>
<p>当一个类处理越来越多不同变化时，代码的内聚性就会变得很差。即：它处理的特殊情况越多，可理解性就越差。</p>
<p>设计的两步法：</p>
<p>1&gt; 抽象类（共性）—— 需要什么接口来出来这个类的所有责任？</p>
<p>2&gt; 派生类（可变性）——对于这个给定的特定实现，应该怎样根据给定的规约来实现它？</p>
<p>处理新需求的选择： </p>
<p>1&gt; 分析瘫痪；</p>
<p>2&gt; 放任自流； </p>
<p>3&gt; 考虑变化的设计</p>
<p><strong>考虑变化的设计</strong></p>
<p>原则：针对接口编程，而不是针对实现编程</p>
<p>原则：优先使用对象组合，而不是类继承</p>
<p>原则：考虑设计中什么应该是可变的</p>
<p>防止“分支蔓延”</p>
<p>一条规则，实现一次</p>
<p><strong>组合起来：用模式思考</strong></p>
<p>Alexander: 设计应该从问题的一个简单陈述开始，然后通过在这个陈述中加入信息，使它更加详细（也更加复杂）。一种基于模式的方法（《建筑的永恒之道》）</p>
<p>从整体的概念性理解开始，以理解需要实现的目标</p>
<p>找到整体中出现的模式</p>
<p>从为其它模式创造背景的那些模式开始</p>
<p>从背景向内：应用这些模式，找到新的模式，并重复</p>
<p>最后，通过每次应用一个模式，改进设计，并在所创建的背景中予以实现</p>
<p><strong>用模式思考的过程</strong>：</p>
<ol>
<li>找出模式  </li>
<li>分析和应用模式  </li>
<li>按背景的创建顺序将模式排序  </li>
<li>选择模式并扩展设计  </li>
<li>找到其它模式  </li>
<li>重复  </li>
<li>添加细节  </li>
</ol>
<p>考虑背景时候的一条规则：先考虑系统中需要什么，然后再去关注如何创建它们</p>
<p>背景和被使用的关系：当一个模式使用另一个模式时，被使用的模式就处于使用模式的背景中</p>
<p><strong>设计模式的策略</strong>：</p>
<p>从背景设计</p>
<p>在类中封装变化</p>
<p>设计模式的原则：</p>
<p>开闭原则——模块、方法和类应该对扩展开放，对修改封闭。换言之，软件应该设计成不加修改缘由代码就能扩展功能。</p>
<p>依赖倒置原则——其背后的理念是在设计细节之前先创建总体概念。高层模块不应该依赖底层模块。相反，它们都应该依赖于抽象。</p>
<p>理性怀疑原则——小心过分依赖模式。概念层次的模式和模型都是真理的抽象。它们是已往经验和教训的结晶。使用它们来帮助我们思考摆在前面的问题。</p>
<p>共性与可变性分析（CVA）：</p>
<p>先寻找共性</p>
<p>从这些共性创建抽象</p>
<p>从共性的变化寻找派生</p>
<p>看共性之间的关系如何</p>
<p>分析矩阵：</p>
<p>找到某种特定情况中最重要的特性，并用矩阵将它们组织起来。用特性所表示的概念为每个特性标记。</p>
<p>继续处理其它情况，安需要扩展这个矩阵。处理每一情况时应该独立于其它情况。</p>
<p>用新的概念扩展该分析矩阵</p>
<p>用行发现规则</p>
<p>用列发现实现</p>
<p>从这种分析中确定模式</p>
<p>得到高层设计</p>
<p>对象创建和管理规则：对象应该要么构造和/或管理其它对象，要么使用对象，而不应该兼而有之。</p>
<p>常见的设计模式：</p>
<pre><code>Facade  
Adapter  
Strategy  
Bridge  
Abstract Factory  
Decorator  
Observer  
Template Method  
Singleton 和 Double-Checked Locking  
Object Pool  
Factory Method  
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="David++" />
          <p class="site-author-name" itemprop="name">David++</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">92</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/david-pp" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/davidpp" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gamelab" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/future_fighter/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David++</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tiny-lab"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>

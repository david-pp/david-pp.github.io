<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="TinyLab" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="TinyLab">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="TinyLab">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TinyLab">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/7/"/>


  <title> TinyLab </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?32177a2b43f11f13565131b8c1239878";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TinyLab</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep eyes on the star and feet on the ground.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/10/12/prototype-clone/" itemprop="url">
                  Prototype模式去掉Clone方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-10-12T23:02:00+09:00" content="2009-10-12">
              2009-10-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/10/12/prototype-clone/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/10/12/prototype-clone/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="意图"><a href="#意图" class="headerlink" title="意图:"></a>意图:</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图:"></a>结构图:</h3><p><img src="/images/2009-10-12-1.jpg" alt="结构图"></p>
<p>Prototype的主要缺陷是每一个Prototype的子类都必须实现Clone操作，这很烦。<br>一般都这样实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">Prototype* ConcretePrototype::Clone()</div><div class="line">&#123;</div><div class="line">     return new ConcretePrototype(*this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="现在想去掉这个重复的操作"><a href="#现在想去掉这个重复的操作" class="headerlink" title="现在想去掉这个重复的操作"></a>现在想去掉这个重复的操作</h3><p><strong>结构图如下</strong>:</p>
<p><img src="/images/2009-10-12-2.jpg" alt="结构图"></p>
<p><strong>实现如下</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class PrototypeWrapper</div><div class="line">&#123;</div><div class="line">     public:</div><div class="line">          ~PrototypeWrapper() &#123;&#125;</div><div class="line">          virtual Prototype* clone() = 0;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;typename T&gt;</div><div class="line">class PrototypeWrapperImpl : public PrototypeWrapper</div><div class="line">&#123;</div><div class="line">     public:</div><div class="line">          PrototypeWrapperImpl()</div><div class="line">          &#123;</div><div class="line">               _prototype = new T();</div><div class="line">          &#125;</div><div class="line">          virtual Prototype* clone()</div><div class="line">          &#123;</div><div class="line">               return new T(*_prototype);</div><div class="line">          &#125;</div><div class="line">     private: </div><div class="line">          T* _prototype;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>使用</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">PrototypeWrapper* prototype = new PrototypeWrapperImpl&lt;ConcretePrototype&gt;();</div><div class="line">Prototype* p = prototype-&gt;clone();</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/08/26/assert-static-dyn/" itemprop="url">
                  编译时断言和运行时断言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-08-26T19:15:00+09:00" content="2009-08-26">
              2009-08-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/08/26/assert-static-dyn/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/08/26/assert-static-dyn/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通常为了检测一些条件，我们往往在程序里面加断言。一般只在DEBUG版有效，RELEASE版断言不生成任何代码。C++可以使用两种断言: 静态断言和动态断言，即就是运行期断言和编译期断言！顾名思义，运行期断言是在程序运行过程中判断指定的条件，若条件满足，万事OK，若断言失败，则程序给出提示然后被abort掉；编译期断言是在编译时候检查条件是否满足，不满足情况下，编译器给出错误提示(需要人为实现)，只要条件不成立，程序是编译不过的。静态断言，BOOST库有实现(boost/static_assert.hpp)，主要原理就是根据”sizeof(不完整类型)”会报错。动态断言在cassert库文件有实现。实现如下:</p>
<h3 id="动态断言-（cassert）"><a href="#动态断言-（cassert）" class="headerlink" title="动态断言:（cassert）"></a>动态断言:（cassert）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#ifdef NDEBUG</div><div class="line"> </div><div class="line">// 不做任何处理</div><div class="line">#  define assert(expr)   </div><div class="line"> </div><div class="line">#else</div><div class="line"> </div><div class="line">// __assert_failed 打印错误消息(包含表达式串，文件，所在行，所在函数名)，然后abort()。</div><div class="line">#  define assert(expr)  ((expr) ? 0 : __assert_failed(__STRING(expr),  __FILE__,  __LINE__, __PRETTY_FUNCTION__, 0))  </div><div class="line"> </div><div class="line">#endif</div></pre></td></tr></table></figure>
<h3 id="静态断言-boost-static-assert-hpp"><a href="#静态断言-boost-static-assert-hpp" class="headerlink" title="静态断言:(boost/static_assert.hpp)"></a>静态断言:(boost/static_assert.hpp)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">template &lt;bool x&gt; struct STATIC_ASSERTION_FAILURE;</div><div class="line"> </div><div class="line">template &lt;&gt; struct STATIC_ASSERTION_FAILURE&lt;true&gt; &#123; enum &#123; value = 1 &#125;; &#125;;</div><div class="line"> </div><div class="line">template&lt;int x&gt; struct static_assert_test&#123;&#125;;</div><div class="line"> </div><div class="line">#define BOOST_STATIC_ASSERT( B ) /</div><div class="line">    typedef ::boost::static_assert_test&lt;/</div><div class="line">    sizeof(::boost::STATIC_ASSERTION_FAILURE&lt; (bool) (B) &gt;)</div><div class="line">    &gt;  boost_static_assert_typedef_</div><div class="line"> </div><div class="line">// 当B为false时，sizeof(STATIC_ASSERTION_FAILURE&lt;false&gt;)，STATIC_ASSERTION_FAILURE&lt;false&gt;)没有实现(不能实例化)，为不完整类，编译器报错！</div></pre></td></tr></table></figure>
<p>注意：和动态断言不同的是，静态断言可以在名称空间，类，函数，模板(函数模板和类模板)中使用，因为他用的是typedef。</p>
<p>静态断言的详细用法，查看：<a href="http://www.boost.org/doc/libs/1_39_0/doc/html/boost_staticassert.html" target="_blank" rel="external">http://www.boost.org/doc/libs/1_39_0/doc/html/boost_staticassert.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/04/02/export-symbol/" itemprop="url">
                  Kernel. EXPORT_SYMBOL解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-04-02T00:04:00+09:00" content="2009-04-02">
              2009-04-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/04/02/export-symbol/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/04/02/export-symbol/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Code-Segment："><a href="#Code-Segment：" class="headerlink" title="Code Segment："></a>Code Segment：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">include/module.h:</div><div class="line"> </div><div class="line">struct kernel_symbol </div><div class="line">&#123;</div><div class="line">    unsigned long value;   </div><div class="line">    const char *name;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">/* For every exported symbol, place a struct in the __ksymtab section */</div><div class="line">#define __EXPORT_SYMBOL(sym, sec)               /</div><div class="line">    __CRC_SYMBOL(sym, sec)                  /</div><div class="line">    static const char __kstrtab_##sym[]         /</div><div class="line">    __attribute__((section(&quot;__ksymtab_strings&quot;)))       /</div><div class="line">    = MODULE_SYMBOL_PREFIX #sym;                        /</div><div class="line">    static const struct kernel_symbol __ksymtab_##sym   /</div><div class="line">    __attribute_used__                  /</div><div class="line">    __attribute__((section(&quot;__ksymtab&quot; sec), unused))   /</div><div class="line">    = &#123; (unsigned long)&amp;sym, __kstrtab_##sym &#125;</div><div class="line">#define EXPORT_SYMBOL(sym)                  /</div><div class="line">    __EXPORT_SYMBOL(sym, &quot;&quot;)</div><div class="line">#define EXPORT_SYMBOL_GPL(sym)                  /</div><div class="line">    __EXPORT_SYMBOL(sym, &quot;_gpl&quot;)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis:"></a>Analysis:</h3><ol>
<li><p>kernel_symbol: 内核函数符号结构体</p>
<p> value： 记录使用EXPORT_SYMBOL(fun)，函数fun的地址<br> name： 记录函数名称（”fun”），在静态内存中</p>
</li>
<li><p>EXPORT_SYMBOL(sym) ：导出函数符号，保存函数地址和名称</p>
</li>
</ol>
<p>宏等价于：（去掉gcc的一些附加属性,MODULE_SYMBOL_PREFIX该宏一般是””)</p>
<pre><code>static const char __kstrtab_sym[] = &quot;sym&quot;;
static const struct kernel_symbol __ksymtab_sym =
    {(unsigned long)&amp;sym, __kstrtab_sym }
</code></pre><ol>
<li>gcc 附加属性</li>
</ol>
<p><strong>atrribute</strong> 指定变量或者函数属性。在此查看详细<a href="http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes" target="_blank" rel="external">http://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes</a>。</p>
<p>__attribute((section(“section-name”)) var : 编译器将变量var放在section-name所指定的data或者bss段里面。</p>
<p>很容易看出：EXPORT_SYMBOL(sym)将sym函数的名称<strong>kstrtab_sym记录在，段名为”</strong>kstrtab_strings”数据段中。 将sym所对应的kernel_symbol记录在名为__ksymtab段中。</p>
<p>EXPORT_SYMBOL_GPL(sym) 和EXPORT_SYMBOL不同之处在于sym对应的kenel_symbol记录在__ksymtab_gpl段中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/18/pthread-5/" itemprop="url">
                  深入Pthread(五)：线程属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-18T20:31:00+09:00" content="2009-02-18">
              2009-02-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/18/pthread-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/18/pthread-5/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程属性相关API"><a href="#线程属性相关API" class="headerlink" title="线程属性相关API"></a>线程属性相关API</h3><pre><code>phtread_attr_t attr;
int pthread_attr_init(pthread_attr_t* attr);
int pthread_attr_destroy(pthread_attr_t* attr);
int pthread_attr_getdetachstate(pthread_attr_t* attr, int* detachstate);
int pthread_attr_setdetachstate(pthread_attr_t* attr, int detachstate);

#ifdef _POSIX_THREAD_ATTR_STACKSIZE
int pthread_attr_getstacksize(pthread_attr_t* attr, size_t* stacksize);
int pthread_attr_setstacksize(pthread_attr_t* attr, size_t stacksize);
#endif

#ifdef _POSIX_THREAD_ATTR_STACKADDR
int pthread_attr_getstackaddr(pthread_attr_t* attr, void* stackaddr);
int pthread_attr_setstackaddr(pthread_attr_t* attr, void** stackaddr); 
#endif
</code></pre><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>POSIX定义的线程属性有：可分离状态（detachstate）, 线程栈大小（stacksize）,线程栈地址（ stackaddr）,作用域（scope）, 继承调度（inheritsched）, 调度策略（schedpolicy）和调度参数（ schedparam）。 有些系统并不支持所有这些属性，使用前注意查看系统文档。</p>
<p>但是所有Pthread系统都支持detachstate属性，该属性可以是PTHREAD_CREATE_JOINABLE或PTHREAD_CREATE_DETACHED，默认的是joinable的。拥有joinable属性的线程可以被另外一个线程等待，同时还可以获得线程的返回值，然后被回收。而detached的线程结束时，使用的资源立马就会释放，不用其他线程等待。</p>
<p>线程stacksize属性移植性不是很好，若你的系统定义了_POSIX_THREAD_ATTR_STACKSIZE ，才可以调用api设定线程堆栈大小。Pthreads规定线程堆栈大小必须大于等于PTHREAD_STACK_MIN。</p>
<p>线程stackaddr属性移植性相当不好，若系统定义了_POSIX_THREAD_ATTR_STACKADDR，才可以调用api设定线程堆栈地址，指定一块内存区域，这块内存区域大小至少是PTHREAD_STACK_MIN。机器堆栈向上增长的，必须指定为低地址；机器堆栈向下增长的，必须指定为高地址。这个属性，最好不要用。</p>
<h3 id="例程："><a href="#例程：" class="headerlink" title="例程："></a>例程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;limits.h&gt;  </div><div class="line">  </div><div class="line">pthread_attr_t attr;  </div><div class="line">  </div><div class="line">  </div><div class="line">void* thread_routine(void* arg)  </div><div class="line">&#123;  </div><div class="line">    sleep(1);  </div><div class="line">#ifdef _POSIX_THREAD_ATTR_STACKSIZE  </div><div class="line">    size_t stacksize;  </div><div class="line">    int status = pthread_attr_getstacksize(&amp;attr, &amp;stacksize);  </div><div class="line">    printf(&quot;[stacksize:%lu]thread routine is running..../n&quot;,stacksize);  </div><div class="line">#endif  </div><div class="line">  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    pthread_t pid;  </div><div class="line">    int status;  </div><div class="line">    size_t stacksize;  </div><div class="line">    status = pthread_attr_init(&amp;attr);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status,&quot;Init attr&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Set detachstate&quot;);  </div><div class="line">  </div><div class="line">#ifdef _POSIX_THREAD_ATTR_STACKSIZE  </div><div class="line">    status = pthread_attr_getstacksize(&amp;attr, &amp;stacksize);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Get stacksize&quot;);  </div><div class="line">    printf(&quot;Original thread size:%lu/n&quot;, stacksize);  </div><div class="line">  </div><div class="line">    status = pthread_attr_setstacksize(&amp;attr, 2*PTHREAD_STACK_MIN);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Set stacksize&quot;);  </div><div class="line">#endif  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;pid, &amp;attr, thread_routine, NULL);  </div><div class="line">    if(status !=0 )  </div><div class="line">        ERROR_ABORT(status, &quot;Create thread&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_attr_destroy(&amp;attr);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Destroy attr&quot;);  </div><div class="line">  </div><div class="line">    printf(&quot;Main thread is over.../n&quot;);  </div><div class="line">    pthread_exit(NULL);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/16/pthread-4/" itemprop="url">
                  深入Pthread(四)：一次初始化-pthread_once_t
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-16T19:27:00+09:00" content="2009-02-16">
              2009-02-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/16/pthread-4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/16/pthread-4/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="用到的API："><a href="#用到的API：" class="headerlink" title="用到的API："></a>用到的API：</h3><pre><code>pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t* once_control, void (*init_routine)(void));
</code></pre><p>有些事需要一次且仅需要一次执行。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始化（pthread_once_t）会比较容易些。</p>
<h3 id="例程："><a href="#例程：" class="headerlink" title="例程："></a>例程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;</div><div class="line">#include &quot;errors.h&quot;</div><div class="line"> </div><div class="line"> </div><div class="line">pthread_once_t once_block = PTHREAD_ONCE_INIT;</div><div class="line">pthread_mutex_t mutex;</div><div class="line"> </div><div class="line"> </div><div class="line">/*This is the one-time initialization routine. It will be</div><div class="line">* called exactly once, no matter how many calls to pthread_once</div><div class="line">* with the same control structure are made during the course of</div><div class="line">* the program.</div><div class="line">*/</div><div class="line"> </div><div class="line">void once init routine (void)</div><div class="line">&#123;</div><div class="line">    int status;</div><div class="line">    status = pthread_mutex_init (&amp;mutex, NULL);</div><div class="line">    if (status != 0)</div><div class="line">        err_abort (status, &quot;Init Mutex&quot;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* Thread start routine that calls pthread_once. </div><div class="line">*/</div><div class="line">void *thread routine (void *arg) </div><div class="line">&#123;</div><div class="line">    int status; </div><div class="line">    status = pthread_once (&amp;once_block, once_init_routine); </div><div class="line">    if (status != 0) </div><div class="line">        err_abort (status, &quot;Once init&quot;); </div><div class="line">    status = pthread_mutex_lock (&amp;mutex); </div><div class="line">    if (status != 0) </div><div class="line">        err_abort (status, &quot;Lock mutex&quot;); </div><div class="line">    printf (&quot;thread routine has locked the mutex./n&quot;);</div><div class="line"> </div><div class="line">    status = pthread_mutex_unlock (&amp;mutex); </div><div class="line">    if (status ! = 0) </div><div class="line">        err_abort (status, &quot;Unlock mutex&quot;); </div><div class="line">    return NULL; </div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123;</div><div class="line">    pthread_t thread_id; </div><div class="line">    char *input, buffer[64]; </div><div class="line">    int status; </div><div class="line">    status = pthread_create (&amp;thread_id, NULL, thread_routine, NULL); </div><div class="line">    if (status != 0) </div><div class="line">        err_abort (status, &quot;Create thread&quot;); </div><div class="line">    status = pthread_once (&amp;once_block, once_init_routine); </div><div class="line">    if (status != 0) </div><div class="line">        err_abort (status, &quot;Once init&quot;); </div><div class="line">    status = pthread_mutex_lock (&amp;mutex); </div><div class="line">    if (status != 0) </div><div class="line">        err_abort (status, &quot;Lock mutex&quot;); </div><div class="line">    printf (&quot;Main has locked the mutex./n&quot;); </div><div class="line">    status = pthread_mutex_unlock (&amp;mutex); </div><div class="line">    if (status != 0) </div><div class="line">        err_abort (status, &quot;Unlock mutex&quot;); </div><div class="line">    status = pthread_join (thread_id, NULL); </div><div class="line">    if (status != 0) </div><div class="line">        err_abort (status, &quot;Join thread&quot;); </div><div class="line">    return 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/12/pthread-3/" itemprop="url">
                  深入Phtread(三)：线程的同步-Condition Variables
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-12T21:28:00+09:00" content="2009-02-12">
              2009-02-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/12/pthread-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/12/pthread-3/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>继续昨天的线程同步，条件变量（Condition Variables）是用于线程间，通信共享数据状态改变的机制。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当线程互斥地访问一些共享的状态时，往往会有些线程需要等到这些状态改变后才应该继续执行。如：有一个共享的队列，一个线程往队列里面插入数据，另一个线程从队列中取数据，当队列为空的时候，后者应该等待队列里面有值才能取数据。而共享数据（队列）应该用mutex来保护，为了检查共享数据的状态（队列是否为空），线程必须先锁定mutex，然后检查，最后解锁mutex。</p>
<p>问题出来了：当另外一个线程B锁定mutex后，往队列里面插入了一个值，B并不知道A在等着它往队列里面放入一个值。，线程A（等待状态改变）一直在运行，线程B可能已经检查过队列是空的，并不知道队列里已经有值了，所以一直阻塞着自己。为了解决这样的问题引入了条件变量机制。线程B等待于一个条件变量，当线程A插入了一个值后，signal或broadcast这个条件变量，通知线程B状态已改变，A发现条件变量被signaled了，就继续执行。就这样，当一个线程改变共享数据状态后，可以及时通知那些等待于该状态的线程。图示下：</p>
<p><img src="/images/2009-02-12-1.jpg" alt="条件变量"></p>
<p>中间的矩形代表条件变量，当线程线位于矩形内，表示线程等待该条件变量。位于中心线下下方，则表示signal了该条件变量。</p>
<p>开始线程1 signal 了条件变量，由于没有其他线程等待于该条件变量，所以没什么效果。然后，线程1和线程2先后等待该条件变量，过了一会，线程3 signal了条件变量，线程3的信号解除了线程1的阻塞。然后，线程3等待该条件变量。最后线程1 broadcast了该条件变量，同时解除了等待于条件变量的线程1和线程2。</p>
<h3 id="条件变量的创建和销毁"><a href="#条件变量的创建和销毁" class="headerlink" title="条件变量的创建和销毁"></a>条件变量的创建和销毁</h3><pre><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int pthread_cond_init(pthread_cond_t* cond, pthread_condattr_t* condattr);
int pthread_cond_destroy(pthread_cond_t* cond);
</code></pre><p>和互斥量一样，可以动态创建和静态创建。</p>
<p><strong>静态创建</strong>：条件变量声明为extern或static变量时。</p>
<p>例程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &quot;error.h&quot;  </div><div class="line">  </div><div class="line">typedef struct my_struct_tag  </div><div class="line">&#123;  </div><div class="line">    pthread_mutex_t mutex;  </div><div class="line">    pthread_cond_t cond;  </div><div class="line">    int value;  </div><div class="line">&#125; my_struct_t;  </div><div class="line">  </div><div class="line">my_struct_t data = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0&#125;;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>动态创建</strong>：一般情况下，条件变量要和它的判定条件定义在一起，此时若包含该条件变量的数据动态创建了，则条件变量也需要动态创建，不过记得不用时用pthread_cond_destroy销毁。</p>
<p>例程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &quot;error.h&quot;  </div><div class="line">  </div><div class="line">typedef struct my_struct_tag  </div><div class="line">&#123;  </div><div class="line">    pthread_mutex_t mutex;  </div><div class="line">    pthread_cond_t cond;  </div><div class="line">    int value;  </div><div class="line">&#125; my_struct_t;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    my_struct_t* data;  </div><div class="line">    data = (my_struct_t*)malloc(sizeof(my_struct_t));  </div><div class="line">    if(data == NULL)  </div><div class="line">        ERROR_ABORT(errno,&quot;Allocate structure&quot;);  </div><div class="line">  </div><div class="line">    int status;  </div><div class="line">    status = pthread_mutex_init(&amp;data-&gt;mutex, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Initial mutex&quot;);  </div><div class="line">    status = pthread_cond_init(&amp;data-&gt;cond, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Initial condition&quot;);  </div><div class="line">  </div><div class="line">    /* .... */  </div><div class="line">      </div><div class="line">    status = pthread_cond_destroy(&amp;data-&gt;cond);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Destroy cond&quot;);  </div><div class="line">    status = pthread_mutex_destroy(&amp;data-&gt;mutex);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Destroy mutex&quot;);  </div><div class="line">  </div><div class="line">    free(data);  </div><div class="line">  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h3><pre><code>int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);
int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, struct timespec* expiration);
</code></pre><p>条件变量与互斥量一起使用，调用pthread_cond_wait或pthread_cond_timedwait时，记得在前面锁定mutex，尽可能多的判断判定条件。上面提到的两个等待条件变量的函数，显示解锁mutex，然后阻塞线程等待状态改变，等待的条件变量signaled后，锁定mutex，返回。记着，这两个函数返回时，mutex一定是锁定的。</p>
<p>多个条件变量可以共享一个互斥变量，相反则不成立。</p>
<p>例程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &lt;time.h&gt;  </div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;errno.h&gt;  </div><div class="line">  </div><div class="line">typedef struct my_struct_tag  </div><div class="line">&#123;  </div><div class="line">    pthread_mutex_t mutex;  </div><div class="line">    pthread_cond_t cond;  </div><div class="line">    int value;  </div><div class="line">&#125; my_struct_t;  </div><div class="line">  </div><div class="line">my_struct_t data = &#123; PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0&#125;;  </div><div class="line">  </div><div class="line">int hibernation = 1;  </div><div class="line">  </div><div class="line">void* wait_thread(void* arg)  </div><div class="line">&#123;  </div><div class="line">    int  status;  </div><div class="line">    sleep(hibernation);  </div><div class="line">  </div><div class="line">    status = pthread_mutex_lock(&amp;data.mutex);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Lock mutex&quot;);  </div><div class="line">  </div><div class="line">    data.value = 1;  </div><div class="line">    status = pthread_cond_signal(&amp;data.cond);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Singal cond&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_mutex_unlock(&amp;data.mutex);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Unlock mutex&quot;);  </div><div class="line">  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main(int argc, char* argv[])  </div><div class="line">&#123;  </div><div class="line">    pthread_t tid;  </div><div class="line">    int status;  </div><div class="line">    struct timespec timeout;  </div><div class="line">  </div><div class="line">    if(argc &gt; 1)  </div><div class="line">        hibernation = atoi(argv[1]);  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;tid, NULL, wait_thread, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Create wait thread&quot;);  </div><div class="line">  </div><div class="line">    timeout.tv_sec = time(NULL) + 2;  </div><div class="line">    timeout.tv_nsec = 0;  </div><div class="line">  </div><div class="line">    status = pthread_mutex_lock(&amp;data.mutex);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Lock mutex&quot;);  </div><div class="line">  </div><div class="line">    while(data.value == 0)  </div><div class="line">    &#123;  </div><div class="line">        status = pthread_cond_timedwait(&amp;data.cond, &amp;data.mutex, &amp;timeout);  </div><div class="line">        if(status == ETIMEDOUT)  </div><div class="line">        &#123;  </div><div class="line">            printf(&quot;Condition wait timed out./n&quot;);  </div><div class="line">            break;  </div><div class="line">        &#125;else  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status, &quot;timewait&quot;);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if(data.value != 0)  </div><div class="line">        printf(&quot;Condition wa signaled!/n&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_mutex_unlock(&amp;data.mutex);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Unlock mutex&quot;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="唤醒等待条件变量的线程"><a href="#唤醒等待条件变量的线程" class="headerlink" title="唤醒等待条件变量的线程"></a>唤醒等待条件变量的线程</h3><pre><code>int pthread_cond_signal(pthread_cond_t* cond);
int pthread_cond_broadcast(pthread_cond_t* cond);
</code></pre><p>一但有线程由于某些判定条件（predicate）没满足，等待条件变量。我们就有必要当条件满足时，发送信号去唤醒这些线程。</p>
<p>注意：broadcast通常很容易被认为是signal的通用版，其实不能这样理解，准确一点应该说，signal是broadcast的优化版。具体区别不大，但signal效率较broadcast高些。但你不确信有几个线程等待条件变量时用broadcast（When in doubt, broadcast!）。</p>
<p>例程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &lt;time.h&gt;  </div><div class="line">#include &lt;string.h&gt;  </div><div class="line">#include &lt;errno.h&gt;  </div><div class="line">  </div><div class="line">typedef struct alarm_tag  </div><div class="line">&#123;  </div><div class="line">    struct alarm_tag* link;  </div><div class="line">    int seconds;  </div><div class="line">    time_t time;  </div><div class="line">    char message[64];  </div><div class="line">&#125; alarm_t;  </div><div class="line">  </div><div class="line">pthread_mutex_t alarm_mutex = PTHREAD_MUTEX_INITIALIZER;  </div><div class="line">pthread_cond_t alarm_cond = PTHREAD_COND_INITIALIZER;  </div><div class="line">alarm_t* alarm_list = NULL;  </div><div class="line">time_t current_alarm = 0;  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * alarm_mutex need to be locked   </div><div class="line"> */  </div><div class="line">void alarm_insert(alarm_t* alarm)  </div><div class="line">&#123;  </div><div class="line">    int status;  </div><div class="line">  </div><div class="line">    alarm_t* next;  </div><div class="line">    alarm_t** last;  </div><div class="line">    last = &amp;alarm_list;  </div><div class="line">    next = *last;  </div><div class="line">  </div><div class="line">    while(next != NULL)  </div><div class="line">    &#123;  </div><div class="line">        if(next-&gt;time &gt;= alarm-&gt;time)  </div><div class="line">        &#123;  </div><div class="line">            alarm-&gt;link = next;  </div><div class="line">            *last = alarm;  </div><div class="line">            break;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        last = &amp;next-&gt;link;  </div><div class="line">        next = next-&gt;link;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    if(next == NULL)&#123;  </div><div class="line">        *last = alarm;  </div><div class="line">        alarm-&gt;link = NULL;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /*for test: output the list*/  </div><div class="line">    printf(&quot;[list: &quot;);  </div><div class="line">    for(next = alarm_list; next != NULL; next = next-&gt;link)  </div><div class="line">    &#123;  </div><div class="line">        printf(&quot;%d(%d)[/&quot;%s/&quot;]  &quot;, next-&gt;time, next-&gt;time-time(NULL), next-&gt;message);  </div><div class="line">    &#125;  </div><div class="line">    printf(&quot;]/n&quot;);  </div><div class="line">  </div><div class="line">    if(current_alarm ==0  || alarm-&gt;time &lt; current_alarm)  </div><div class="line">    &#123;  </div><div class="line">        current_alarm = alarm-&gt;time;  </div><div class="line">        status = pthread_cond_signal(&amp;alarm_cond);  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status,&quot;Signal cond&quot;);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void* alarm_thread(void* arg)  </div><div class="line">&#123;  </div><div class="line">    alarm_t* alarm;  </div><div class="line">    int sleep_time;  </div><div class="line">    time_t now;  </div><div class="line">    int status, expired;  </div><div class="line">    struct timespec cond_time;  </div><div class="line">  </div><div class="line">    while(1)  </div><div class="line">    &#123;  </div><div class="line">        status = pthread_mutex_lock(&amp;alarm_mutex);  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status, &quot;lock&quot;);  </div><div class="line">  </div><div class="line">        current_alarm = 0;  </div><div class="line">  </div><div class="line">        while(alarm_list == NULL)  </div><div class="line">        &#123;  </div><div class="line">            status = pthread_cond_wait(&amp;alarm_cond, &amp;alarm_mutex);  </div><div class="line">            if(status != 0 )  </div><div class="line">                ERROR_ABORT(status, &quot;Wait cond&quot;);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        alarm = alarm_list;  </div><div class="line">        alarm_list = alarm-&gt;link;  </div><div class="line">        now = time(NULL);  </div><div class="line">        expired = 0;  </div><div class="line">  </div><div class="line">        if(alarm-&gt;time &gt; now)  </div><div class="line">        &#123;  </div><div class="line">            printf(&quot;[wating: %d(%d)/&quot;%s/&quot;]/n&quot;, alarm-&gt;time, alarm-&gt;time - time(NULL), alarm-&gt;message);  </div><div class="line">  </div><div class="line">            cond_time.tv_sec = alarm-&gt;time;  </div><div class="line">            cond_time.tv_nsec = 0;  </div><div class="line">            current_alarm = alarm-&gt;time;  </div><div class="line">            while(current_alarm == alarm-&gt;time)  </div><div class="line">            &#123;  </div><div class="line">                status = pthread_cond_timedwait(&amp;alarm_cond, &amp;alarm_mutex,&amp;cond_time);  </div><div class="line">                if(status == ETIMEDOUT)  </div><div class="line">                &#123;  </div><div class="line">                    expired = 1;  </div><div class="line">                    break;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            if(!expired)  </div><div class="line">                alarm_insert(alarm);  </div><div class="line">        &#125;else  </div><div class="line">            expired = 1;  </div><div class="line">  </div><div class="line">        if(expired)  </div><div class="line">        &#123;  </div><div class="line">            printf(&quot;(%d) %s/n&quot;, alarm-&gt;seconds, alarm-&gt;message);  </div><div class="line">            free(alarm);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        status = pthread_mutex_unlock(&amp;alarm_mutex);  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status, &quot;Unlock mutex&quot;);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return 0;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    pthread_t pid;  </div><div class="line">    int status;  </div><div class="line">    char line[128];  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;pid, NULL, alarm_thread, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;pthread_create&quot;);  </div><div class="line">  </div><div class="line">    while(1)  </div><div class="line">    &#123;  </div><div class="line">        fprintf(stdout, &quot;Alarm&gt;&quot;);  </div><div class="line">        fgets(line, sizeof(line), stdin);  </div><div class="line">        if(strlen(line) &lt;= 0)  </div><div class="line">            continue;  </div><div class="line">  </div><div class="line">        alarm_t* alarm = (alarm_t*)malloc(sizeof(alarm_t));  </div><div class="line">        if(alarm == NULL)  </div><div class="line">            ERROR_ABORT(errno,&quot;memory can&apos;t allocated!&quot;);  </div><div class="line">  </div><div class="line">        if(sscanf(line, &quot;%d %s&quot;, &amp;alarm-&gt;seconds, alarm-&gt;message) != 2)  </div><div class="line">        &#123;  </div><div class="line">            printf(&quot;Bad Command/n&quot;);  </div><div class="line">            free(alarm);  </div><div class="line">            continue;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        status = pthread_mutex_lock(&amp;alarm_mutex);  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status, &quot;pthread mutex locking..&quot;);  </div><div class="line">  </div><div class="line">        alarm-&gt;time = time(NULL) + alarm-&gt;seconds;  </div><div class="line">  </div><div class="line">        /* insert into list*/  </div><div class="line">  </div><div class="line">        alarm_insert(alarm);  </div><div class="line">  </div><div class="line">        status = pthread_mutex_unlock(&amp;alarm_mutex);  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status, &quot;pthread mutex unlocking...&quot;);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/11/pthread-2/" itemprop="url">
                  深入Phtread(二)：线程的同步-Mutex
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-11T20:30:00+09:00" content="2009-02-11">
              2009-02-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/11/pthread-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/11/pthread-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>并行的世界，没有同步，就失去了秩序，就会乱作一团！试想，交通没有红绿灯，生产线产品装配没有一定的顺序… 结果是显而易见的。多个线程也需要同步，否则程序运行起来结果不可预测，这是我们最不能容忍的。交通的同步机制就是红绿灯，Pthread提供了互斥量（mutex）和条件变量（Condition Variables）两种机制去同步线程。</p>
<ol>
<li><a href="#1">不变量，临界区和判定条件</a></li>
<li><a href="#2">互斥量（Mutex）</a></li>
<li><a href="#3">创建和销毁互斥量</a></li>
<li><a href="#4">锁定和解锁</a></li>
<li><a href="#5">调整mutex大小</a></li>
<li><a href="#6">使用多个mutex</a></li>
<li><a href="#7">锁定链</a></li>
</ol>
<h3 id="1-不变量，临界区和判定条件"><a href="#1-不变量，临界区和判定条件" class="headerlink" title=" 1. 不变量，临界区和判定条件"></a><a id="1"></a> 1. 不变量，临界区和判定条件</h3><p><strong>不变量（Invariant）</strong>：程序所做的一些假设，特别是指变量之间的关系。如：一个queue，有头节点，和其它数据节点，这些元素之间的连接关系就是不变量。当程序里面不变量遭受破坏时，后果往往是很严重的，轻则数据出错，重则程序直接崩溃。</p>
<p><strong>临界区（Critical Section）</strong>：处理共享数据的一段代码。</p>
<p><strong>判定条件（Predicates）</strong>：描述不变量状态的逻辑表达式。</p>
<h3 id="2-互斥量（Mutex）"><a href="#2-互斥量（Mutex）" class="headerlink" title=" 2. 互斥量（Mutex）"></a><a id="2"></a> 2. 互斥量（Mutex）</h3><p>一般，多个线程之间都会共享一些数据，当多个线程同时访问操作这些共享数据时。问题出来了，一个线程正在修改数据时，另外一个可能也去操作这些数据，结果就会变得不一致了。如(gv=0是共享的数据)：</p>
<pre><code>线程A：a = gv; gv = a + 10; 
线程B: b = gv; gv = a + 100;
</code></pre><p>可能发生A执行完a=gv(0)时，B开始执行b=gv(0); gv=a+100，此时gv=100，然后a执行gv=a+10，最后gv=10。并不是我们要的结果，我们的想法是两个线程并发的给gv加上一个值，期望结果110。^_^ 若这是你银行卡的余额，若没有同步，那就惨了（你往卡里打钱，你有个朋友也同时往你卡里汇钱，很有可能余额只仅加上一方打的）。</p>
<p>互斥量就是为了解决这种问题而设计的，它是Dijkstra信号量的一种特殊形式。它使得线程可以互斥地访问共享数据。如：</p>
<p><img src="/images/2009-02-11-1.jpg" alt="互斥量"></p>
<p>上图展示了三个线程共享一个互斥量，位于矩形中心线下方的线程锁定了该互斥量；位于中心线上方且在矩形范围内的线程等待该互斥量被解锁，出于阻塞状态，在矩形外面的线程正常运行。刚开始，mutex是解锁的，线程1成功将其锁定，据为己有，因为并没有其它线程拥有它。然后，线程2尝试去锁定，发现被线程1占用，所以阻塞于此，等到线程1解锁了该mutex，线程2立马将mutex锁定。过了会，线程3尝试去锁定mutex，由于mutex被锁定，所以阻塞于此。线程1调用pthread_mutex_trylock尝试去锁定个mutex，发现该mutex被锁定，自己返回继续执行，并没有阻塞。继续线程2解锁，线程3锁定成功，最后线程3完成任务解锁mutex。</p>
<h3 id="3-创建和销毁互斥量"><a href="#3-创建和销毁互斥量" class="headerlink" title=" 3. 创建和销毁互斥量"></a><a id="3"></a> 3. 创建和销毁互斥量</h3><pre><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_init(pthread_mutex_t* mutex, pthread_mutexattr_t* attr);
int pthread_mutex_destroy(pthread_mutex_t* mutex);
</code></pre><p>不要尝试去使用复制的的mutex，结果未定义。</p>
<p>静态创建，当mutex以extern或者static存储时，可以用PTHREAD_MUTEX_INITIALIZER初始化，此时该mutex使用默认属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">  </div><div class="line">typedef struct my_struct_tag  </div><div class="line">&#123;  </div><div class="line">    pthread_mutex_t mutex;  </div><div class="line">    int value;  </div><div class="line">&#125; my_struct_t;  </div><div class="line">  </div><div class="line">my_struct_t data = &#123; PTHREAD_MUTEX_INITIALIZER, 0&#125;;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态创建，往往使用mutex时，都会将它和共享数据绑在一起，此时就需要pthread_mutex_init去动态初始化了，记得用完后pthread_mutex_destroy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">  </div><div class="line">typedef struct my_struct_tag  </div><div class="line">&#123;  </div><div class="line">    pthread_mutex_t mutex;  </div><div class="line">    int value;  </div><div class="line">&#125; my_struct_t;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    my_struct_t* data;  </div><div class="line">    int status;  </div><div class="line">  </div><div class="line">    data = (my_struct_t*)malloc(sizeof(my_struct_t));  </div><div class="line">    status = pthread_mutex_init(&amp;data-&gt;mutex, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;pthread_mutex_init&quot;);  </div><div class="line">  </div><div class="line">    pthread_mutex_destroy(&amp;data-&gt;mutex);  </div><div class="line">    free(data);  </div><div class="line">  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-锁定和解锁"><a href="#4-锁定和解锁" class="headerlink" title=" 4. 锁定和解锁"></a><a id="4"></a> 4. 锁定和解锁</h3><p>原则见上面。</p>
<pre><code>int pthread_mutex_lock(pthread_mutex_t* mutex);
int pthread_mutex_trylock(pthread_mutex_t* mutex);
int pthread_mutex_unlock(pthread_mutex_t* mutex);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &lt;sys/types.h&gt;  </div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;errno.h&gt;  </div><div class="line">  </div><div class="line">#define SPIN 10000000  </div><div class="line">  </div><div class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  </div><div class="line">long counter;  </div><div class="line">time_t end_time;  </div><div class="line">  </div><div class="line">void* counter_thread(void* arg)  </div><div class="line">&#123;  </div><div class="line">    int status;  </div><div class="line">    int spin;  </div><div class="line">  </div><div class="line">    while(time(NULL) &lt; end_time)  </div><div class="line">    &#123;  </div><div class="line">        status = pthread_mutex_lock(&amp;mutex);  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status, &quot;Lock mutex&quot;);  </div><div class="line">  </div><div class="line">        for(spin = 0; spin &lt; SPIN; spin++)  </div><div class="line">            counter++;  </div><div class="line">  </div><div class="line">        status = pthread_mutex_unlock(&amp;mutex);  </div><div class="line">        if(status != 0)  </div><div class="line">            ERROR_ABORT(status, &quot;Unlock mutex&quot;);  </div><div class="line">        sleep(1);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    printf(&quot;Coutner is %#lx/n&quot;, counter);  </div><div class="line">  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void* monitor_thread(void* arg)  </div><div class="line">&#123;  </div><div class="line">    int status;  </div><div class="line">    int misses = 0;  </div><div class="line">  </div><div class="line">    while(time(NULL) &lt; end_time)  </div><div class="line">    &#123;  </div><div class="line">        sleep(3);  </div><div class="line">  </div><div class="line">        status = pthread_mutex_trylock(&amp;mutex);  </div><div class="line">        if(status != EBUSY)  </div><div class="line">        &#123;  </div><div class="line">            if(status != 0)  </div><div class="line">                ERROR_ABORT(status, &quot;Trylock mutex&quot;);  </div><div class="line">              </div><div class="line">            printf(&quot;Counter is %ld/n&quot;, counter/SPIN);  </div><div class="line">            status = pthread_mutex_unlock(&amp;mutex);  </div><div class="line">            if(status != 0)  </div><div class="line">                ERROR_ABORT(status, &quot;Unlock mutex&quot;);  </div><div class="line">        &#125;else  </div><div class="line">            misses++;  </div><div class="line">    &#125;  </div><div class="line">    printf(&quot;Monitro thread missed update %d times./n&quot;, misses);  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    int status;  </div><div class="line">    pthread_t pid_counter;  </div><div class="line">    pthread_t pid_monitor;  </div><div class="line">  </div><div class="line">    end_time = time(NULL) + 60;  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;pid_counter, NULL, counter_thread, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;fail to create thread counter&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;pid_monitor, NULL, monitor_thread, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;fail to create monitor thread&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_join(pid_counter, NULL);  </div><div class="line">    if(status != 0 )  </div><div class="line">        ERROR_ABORT(status, &quot;fail to join counter thread&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_join(pid_monitor, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;fail to join monitor thread&quot;);  </div><div class="line">  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-调整mutex大小"><a href="#5-调整mutex大小" class="headerlink" title=" 5. 调整mutex大小"></a><a id="5"></a> 5. 调整mutex大小</h3><p>mutex应该多大？这里的大小是相对的，如mutex锁定到解锁之间的代码只有一行，比起有10行的就小了。 原则是：尽可能大，但不要太大（As big as neccessary, but no bigger）。考虑下面的因素：</p>
<p>1&gt; mutex并不是免费的，是有开销的，不要太小了，太小了程序只忙于锁定和解锁了。</p>
<p>2&gt; mutex锁定的区域是线性执行的，若太大了，没有发挥出并发的优越性。</p>
<p>3&gt; 自己掂量1和2，根据实际情况定，或者尝试着去做。</p>
<h3 id="6-使用多个mutex"><a href="#6-使用多个mutex" class="headerlink" title=" 6. 使用多个mutex"></a><a id="6"></a> 6. 使用多个mutex</h3><p>使用多个mutex一定要注意，防止死锁（deadlock）发生。下面是一个典型死锁：</p>
<pre><code>线程A：pthread_mutex_lock(&amp;mutex_a); pthread_mutex_lock(&amp;mutex_b); ...
线程B：pthread_mutex_lock(&amp;mutex_b); pthread_mutex_lock(&amp;mutex_a); ...
</code></pre><p>存在这种可能，线程A执行了第一句，锁定了mutex_a；然后线程开始执行第一句锁定mutex_b；然后他们互相等待解锁mutex，A等mutex_b被解锁，B等mutex_a被解锁，不肯让步，出于死锁状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;time.h&gt;  </div><div class="line">  </div><div class="line">pthread_mutex_t mutex_a = PTHREAD_MUTEX_INITIALIZER;  </div><div class="line">pthread_mutex_t mutex_b = PTHREAD_MUTEX_INITIALIZER;  </div><div class="line">  </div><div class="line">void* thread1(void* arg)  </div><div class="line">&#123;  </div><div class="line">    while(1)  </div><div class="line">    &#123;  </div><div class="line">        /*sleep(1);*/  </div><div class="line">        pthread_mutex_lock(&amp;mutex_a);  </div><div class="line">        pthread_mutex_lock(&amp;mutex_b);  </div><div class="line">  </div><div class="line">        printf(&quot;[%lu]thread 1 is running! /n&quot;, time(NULL));  </div><div class="line">  </div><div class="line">        pthread_mutex_unlock(&amp;mutex_b);  </div><div class="line">        pthread_mutex_unlock(&amp;mutex_a);  </div><div class="line">    &#125;  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void* thread2(void* arg)  </div><div class="line">&#123;  </div><div class="line">    while(1)  </div><div class="line">    &#123;  </div><div class="line">        /*sleep(1);*/  </div><div class="line">  </div><div class="line">        pthread_mutex_lock(&amp;mutex_b);  </div><div class="line">        pthread_mutex_lock(&amp;mutex_a);  </div><div class="line">  </div><div class="line">        printf(&quot;[%lu]thread 2 is running! /n&quot;,time(NULL));  </div><div class="line">  </div><div class="line">        pthread_mutex_unlock(&amp;mutex_a);  </div><div class="line">        pthread_mutex_unlock(&amp;mutex_b);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    pthread_t tid1, tid2;  </div><div class="line">    int status;  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;tid1, NULL, thread1, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;thread 1&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;tid2, NULL, thread2, NULL);  </div><div class="line">    if(status !=0)  </div><div class="line">        ERROR_ABORT(status, &quot;thread 2&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_join(tid1, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;join thread1&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_join(tid2, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;join thread2&quot;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解决死锁的方法</strong>：</p>
<p>a. 固定锁定顺序（Fixed locking hierarchy）：锁定mutex的顺序固定。</p>
<pre><code>线程A：pthread_mutex_lock(&amp;mutex_a); pthread_mutex_lock(&amp;mutex_b); ...
线程B：pthread_mutex_lock(&amp;mutex_a); pthread_mutex_lock(&amp;mutex_b); ...
</code></pre><p>b. 尝试和回退（Try and back off）： 锁定第一个后，尝试锁定下一个，若锁定成功，继续尝试下一个，若锁定失败，解锁先去锁定的。</p>
<p>解锁顺序不会引起死锁.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt;  </div><div class="line">#include &quot;error.h&quot;  </div><div class="line">#include &lt;errno.h&gt;  </div><div class="line">  </div><div class="line">#define ITERATIONS 100  </div><div class="line">  </div><div class="line">  </div><div class="line">pthread_mutex_t mutex[3] = &#123;  </div><div class="line">    PTHREAD_MUTEX_INITIALIZER,  </div><div class="line">    PTHREAD_MUTEX_INITIALIZER,  </div><div class="line">    PTHREAD_MUTEX_INITIALIZER  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line">int backoff = 1;  </div><div class="line">int yield_flag = 0;  </div><div class="line">  </div><div class="line">void* lock_forward(void* arg)  </div><div class="line">&#123;  </div><div class="line">    int i, iterate, backoffs;  </div><div class="line">    int status;  </div><div class="line">  </div><div class="line">    for(iterate = 0; iterate &lt; ITERATIONS; iterate++)  </div><div class="line">    &#123;  </div><div class="line">        backoffs = 0;  </div><div class="line">        for(i = 0; i &lt; 3; i++)&#123;  </div><div class="line">            if(i == 0)  </div><div class="line">            &#123;  </div><div class="line">                status = pthread_mutex_lock(&amp;mutex[i]);  </div><div class="line">                if(status != 0)  </div><div class="line">                    ERROR_ABORT(status,&quot;Lock mutex&quot;);  </div><div class="line">            &#125;else  </div><div class="line">            &#123;  </div><div class="line">                if(backoff)  </div><div class="line">                    status = pthread_mutex_trylock(&amp;mutex[i]);  </div><div class="line">                else  </div><div class="line">                    status = pthread_mutex_lock(&amp;mutex[i]);  </div><div class="line">  </div><div class="line">                if(status == EBUSY)  </div><div class="line">                &#123;  </div><div class="line">                    backoff++;  </div><div class="line">                    printf(&quot;forward locker backing off at %d./n&quot;, i);  </div><div class="line">                    for(; i &gt;= 0; i--)  </div><div class="line">                    &#123;  </div><div class="line">                        status = pthread_mutex_unlock(&amp;mutex[i]);  </div><div class="line">                        if(status != 0)  </div><div class="line">                            ERROR_ABORT(status, &quot;Unlock mutex&quot;);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;else  </div><div class="line">                &#123;  </div><div class="line">                    if(status != 0)  </div><div class="line">                        ERROR_ABORT(status, &quot;Lock mutex&quot;);  </div><div class="line">                      </div><div class="line">                    printf(&quot;forward locker got %d /n&quot;, i);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            if(yield_flag)&#123;  </div><div class="line">                if(yield_flag &gt; 0)  </div><div class="line">                    sched_yield();  </div><div class="line">                else  </div><div class="line">                    sleep(1);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        printf(&quot;lock forward got all locks , %d backoffs/n&quot;, backoffs);  </div><div class="line">  </div><div class="line">        pthread_mutex_unlock(&amp;mutex[2]);  </div><div class="line">        pthread_mutex_unlock(&amp;mutex[1]);  </div><div class="line">        pthread_mutex_unlock(&amp;mutex[0]);  </div><div class="line">        sched_yield();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void* lock_backward(void* arg)  </div><div class="line">&#123;  </div><div class="line">    int i, iterate, backoffs;  </div><div class="line">    int status;  </div><div class="line">  </div><div class="line">    for(iterate = 0; iterate &lt; ITERATIONS; iterate++)  </div><div class="line">    &#123;  </div><div class="line">        backoffs = 0;  </div><div class="line">        for(i = 2; i &gt;= 0; i--)&#123;  </div><div class="line">            if(i == 2)  </div><div class="line">            &#123;  </div><div class="line">                status = pthread_mutex_lock(&amp;mutex[i]);  </div><div class="line">                if(status != 0)  </div><div class="line">                    ERROR_ABORT(status,&quot;Lock mutex&quot;);  </div><div class="line">            &#125;else  </div><div class="line">            &#123;  </div><div class="line">                if(backoff)  </div><div class="line">                    status = pthread_mutex_trylock(&amp;mutex[i]);  </div><div class="line">                else  </div><div class="line">                    status = pthread_mutex_lock(&amp;mutex[i]);  </div><div class="line">  </div><div class="line">                if(status == EBUSY)  </div><div class="line">                &#123;  </div><div class="line">                    backoff++;  </div><div class="line">                    printf(&quot;backward locker backing off at %d./n&quot;, i);  </div><div class="line">                    for(; i &lt; 3; i++)  </div><div class="line">                    &#123;  </div><div class="line">                        status = pthread_mutex_unlock(&amp;mutex[i]);  </div><div class="line">                        if(status != 0)  </div><div class="line">                            ERROR_ABORT(status, &quot;Unlock mutex&quot;);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;else  </div><div class="line">                &#123;  </div><div class="line">                    if(status != 0)  </div><div class="line">                        ERROR_ABORT(status, &quot;Lock mutex&quot;);  </div><div class="line">                      </div><div class="line">                    printf(&quot;backward locker got %d /n&quot;, i);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            if(yield_flag)&#123;  </div><div class="line">                if(yield_flag &gt; 0)  </div><div class="line">                    sched_yield();  </div><div class="line">                else  </div><div class="line">                    sleep(1);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        printf(&quot;lock backward got all locks , %d backoffs/n&quot;, backoffs);  </div><div class="line">  </div><div class="line">        pthread_mutex_unlock(&amp;mutex[0]);  </div><div class="line">        pthread_mutex_unlock(&amp;mutex[1]);  </div><div class="line">        pthread_mutex_unlock(&amp;mutex[2]);  </div><div class="line">        sched_yield();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    return NULL;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main(int argc, char* argv[])  </div><div class="line">&#123;  </div><div class="line">    pthread_t forward, backward;  </div><div class="line">    int status;  </div><div class="line">  </div><div class="line">    if(argc &gt; 1)  </div><div class="line">        backoff = atoi(argv[1]);  </div><div class="line">  </div><div class="line">    if(argc &gt; 2)  </div><div class="line">        yield_flag = atoi(argv[2]);  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;forward, NULL, lock_forward, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Create forward&quot;);  </div><div class="line">  </div><div class="line">    status = pthread_create(&amp;backward, NULL, lock_backward, NULL);  </div><div class="line">    if(status != 0)  </div><div class="line">        ERROR_ABORT(status, &quot;Create backward&quot;);  </div><div class="line">  </div><div class="line">    pthread_exit(NULL);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-锁定链"><a href="#7-锁定链" class="headerlink" title=" 7. 锁定链"></a><a id="7"></a> 7. 锁定链</h3><p>一般用于遍历数据结果（树，链表），一个用于锁定指针，一个锁定数据。</p>
<p>形如：</p>
<pre><code>pthread_mutex_lock(&amp;mutex_a); 
pthread_mutex_lock(&amp;mutex_b); 
...
pthread_mutex_unlock(&amp;mutex_a)
...
pthread_mutex_unlock(&amp;mutex_b)
</code></pre><p>注意，锁定链往往会出现大量的锁定和解锁操作，有时会得不偿失。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/10/pthread-1/" itemprop="url">
                  深入Phtread(一)：线程的一生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-10T20:41:00+09:00" content="2009-02-10">
              2009-02-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/10/pthread-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/10/pthread-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们每个人都并行地活在这个世界上 ，每一天每个人都干着不同的事情。每个人的人生都是不同的，从出生 -&gt; 活着 -&gt; 死去， 个中滋味，只能自己体味了。我们的线程兄弟也一样，只不过它的环境没有人类社会这么复杂，它的一生，被操作系统控制，被我们程序员控制着！呵呵,想想都觉得这兄弟可怜啊！不过这哥们可不许小瞧了，功能大了去了！具体线程的定义和好处参考其它关于线程的资料。该篇主要讲线程兄弟的大体的一生（从被创建到销毁）。进入正题：</p>
<p>线程的一生始终处于下面四种状态之一： </p>
<ul>
<li><p><strong>Ready</strong>    就绪状态，等待处理器的调度。可能是刚新创建的，或阻塞状态，等待的资源得到满足刚解除阻塞状态，或处于运行状态被别的线程抢占了处理器。</p>
</li>
<li><p><strong>Running</strong>    运行状态，线程正在处理器上运行。多处理器可能会不止一个线程正在运行。</p>
</li>
<li><p><strong>Blocked</strong>    阻塞状态，线程等待某些资源，不能运行。如：等待一个条件变量，锁定互斥量，或者等待I/O操作的完成。</p>
</li>
<li><p><strong>Terminated</strong>    终止状态，线程从它的开始函数（创建时指定的）终止。调用pthread_exit或者被其它线程取消（cancelled）。此时，线程并没有被分离（detached），也没有被连接（joined）。一旦线程被joined或detached, 将会被系统回收。</p>
</li>
</ul>
<p>线程的状态图：</p>
<p><img src="/images/2009-02-10-1.gif" alt="线程状态图"></p>
<h3 id="1-创建和使用线程常见的pthread函数"><a href="#1-创建和使用线程常见的pthread函数" class="headerlink" title="1. 创建和使用线程常见的pthread函数"></a>1. 创建和使用线程常见的pthread函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pthread_t thread;</div><div class="line">int pthread_equal(pthread_t t1, pthread_t t2);</div><div class="line">int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start)(void*), void* arg);</div><div class="line">pthread_t pthread_self();</div><div class="line">int sched_yield();</div><div class="line">int pthread_exit(void* value_ptr);</div><div class="line">int pthread_detach(pthread_t thread);</div><div class="line">int pthread_join(pthread_t thread, void** value_ptr);</div></pre></td></tr></table></figure>
<h3 id="2-创建线程："><a href="#2-创建线程：" class="headerlink" title="2. 创建线程："></a>2. 创建线程：</h3><p>有一个比较特殊的线程， 就是主线程或者称为初始线程，它是当一个进程被创建时创建的。而其他线程则是在初始线程中调用pthread_create创建的。创建的新线程初始为Ready状态，等待处理器调度。</p>
<h3 id="3-执行线程："><a href="#3-执行线程：" class="headerlink" title="3. 执行线程："></a>3. 执行线程：</h3><p>线程被创建后，就会执行phtread_create的start参数指定的函数，我们可以通过pthread_create的arg参数向线程开始函数传递一个参数，若不想传就直接赋值NULL。</p>
<p>上面提到了一个特殊的线程：初始线程，它的开始函数就是我们学习C/C++见到的第一个函数main，只不过这个开始函数不是由我们来调用的，而是由操作系统Shell。操作系统先初始化进程，然后运行主线程的开始函数main。注意：初始线程和我们自己创建的线程有稍许不同：-开始函数参数不同，main的参数是int arg, char<em> argv，而我们自己的线程参数是void</em> arg。-自己创建的线程开始函数返回了，其它线程可以继续执行。而初始线程开始函数main返回后进程会终止，导致其它正在运行的线程也就被强行终止，若不想在main退出后关闭进程，可以在main最后调用pthread<em>exit,不过此时该进程就成了僵尸进程（defunct），直到所有线程执行完毕。- 还有一个很重要的区别，多数系统上，初始线程使用的是进程的栈，而自己创建的线程则使用自己的栈，往往自建线程的栈没有初始线程的栈空间大，要注意线程栈溢出哦！（phread提供了修改线程栈大小的函数，后面再说^</em>^）</p>
<h3 id="4-运行和阻塞"><a href="#4-运行和阻塞" class="headerlink" title="4. 运行和阻塞"></a>4. 运行和阻塞</h3><p>线程兄弟和我们一样，不能一直都醒着工作，它也要休息。线程一生大多处于三种状态：ready, running, 和blocked（和我一样，吃饭,工作,睡觉^_^）。 线程被创建时出于就绪状态，就绪状态等待处理器，处理器有空闲了，线程就转到运行状态疯狂工作，突然发现自己需要的其它资源（互斥量，条件变量）在别的线程手里，或者别的线程优先级比自己大一下从它手里抢走了处理器，或处理器烦了它了（时间片已经用完），或自己不好意思不干事还占用处理器了（等待I/O操作完成），就转换成阻塞状态，停止运行，可以休息下了。 休息可不是给它放长假，任务还没完成了…继续，当等待的资源得到满足，再次投入工作，进入运行状态。周而复始，直到任务完成。</p>
<h4 id="5-终止线程："><a href="#5-终止线程：" class="headerlink" title="5. 终止线程："></a>5. 终止线程：</h4><p>线程一般都是在开始函数执行完时终止的。线程开始函数中调用pthread_exit或者其它线程调用pthread_cancel都可以终止线程。终止后线程处于terminated状态（注意：不是destroyed），然后等待系统回收。</p>
<p>若创建线程时指定线程是detached的，直接在线程开始函数执行完后就会被回收。</p>
<p>若是joinable，那就需要初始线程或其他线程调用pthread_join来等待要终止的线程了， 同时还可以通过pthread_joind的第二个参数获得线程的返回值。pthread_join后，线程就被detached，然后被系统回收。</p>
<h3 id="6-回收线程"><a href="#6-回收线程" class="headerlink" title="6. 回收线程"></a>6. 回收线程</h3><p>线程创建时，detachsate属性是PTHREAD_CREATE_DETACHED，则在开始函数返回后被回收。</p>
<p>或其他线程使用了pthread_join 或自己调用了pthread_detach,线程出于terminated状态后，立马就会被系统回收：释放系统资源和进程资源，包含线程返回值占用的内存，线程堆栈，寄存器状态等等。</p>
<p>今天就到此，以后深挖！^_^</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/06/initramfs/" itemprop="url">
                  initramfs 简介，一个新的 initial RAM disks 模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-06T15:00:00+09:00" content="2009-02-06">
              2009-02-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/06/initramfs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/06/initramfs/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译自: <a href="http://linuxdevices.com/articles/AT4017834659.html" target="_blank" rel="external">http://linuxdevices.com/articles/AT4017834659.html</a> (by Rob Landley, TimeSys (Mar. 15, 2005))</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当 Linux 内核启动系统时，它必须找到并执行第一个用户程序，通常是 init。用户程序存在于文件系统，故 Linux 内核必须找到并挂载上第一个(根)文件系统，方能成功开机。</p>
<p>通常，可用的文件系统都列在 /etc/fstab，所以 mount 可以找到它们。但 /etc/fstab 它本身就是一个文件，存在于文件系统中。找到第一个文件系统成为鸡生蛋蛋生鸡的问题，而且为了解决它，内核开发者建立内核命令列选项 root=，用来指定 root 文件系统存在于哪个设备上。</p>
<p>十五年前，root= 很容易解释。它可以是软盘或硬盘上的分区。如今 root 文件系统可以存在于各种不同类型的硬件(SCSI, SATA, flash MTD) ，或是由不同类型硬件所建立的 RAID 上。它的位置随着不同启动而不同，像可热插拔的 USB 设备被插到有多个 USB 孔的系统上 - 当有多个 USB 设备时，哪一个是正确的？root 文件系统也可能被压缩(如何？)，被加密(用什么 keys？)，或 loopback 挂载(哪里？)。它甚至可以存在外部的网络服务器，需要内核去取得 DHCP 地址，完成 DNS lookup，并登入到远程服务器(需账号及密码)，全部都在内核可以找到并执行第一个 userspace 程序之前。</p>
<p>如今，root= 已没有足够的信息。即使将所有特殊案例的行为都放进内核也无法帮助设备列举，加密，或网络登入这些随着系统不同而不同的系统。更糟的是，替核心加入这些复杂的工作，就像是用汇编语言写 web 软件 ：可以做到，但使用适当的工具会更容易完成。核心是被设计成服从命令，而不是给命令。</p>
<p>为了这个不断增加复杂度的工作， 核心开发者决定去寻求更好的方法来解决这整个问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>Linux 2.6 核心将一个小的 ram-based initial root filesystem(initramfs) 包进内核，且若这个文件系统包含一个程序 init，核心会将它当作第一个程序执行。此时，找寻其它文件系统并执行其它程序已不再是内核的问题，而是新程序的工作。</p>
<p>initramfs 的内容不需是一般功能。若给定系统的 root 文件系统存在于一个加密过的网络块设备，且网络地址、登入、加密都存在 USB 设备 “larry” (需密码方能存取)里，系统的 initramfs 可以有特殊功能的程序，它知道这些事，并使这可以运作。</p>
<p>对系统而言，不需要很大的 root 文件系统，也不需要寻址或切换到任何其它 root 文件系统。</p>
<h3 id="这跟-initrd-有何不同"><a href="#这跟-initrd-有何不同" class="headerlink" title="这跟 initrd 有何不同?"></a>这跟 initrd 有何不同?</h3><p>Linux kernel 已经有方法提供 ram-based root filesystem，initrd 机制。对 2.4 及更早的 kernel 来说，initrd 仍然是唯一的方法去做这一连串的事。但 kernel 开发者选择在 2.6 实现一个新的机制是有原因的。</p>
<h3 id="ramdisk-vs-ramfs"><a href="#ramdisk-vs-ramfs" class="headerlink" title="ramdisk vs ramfs"></a>ramdisk vs ramfs</h3><p>ramdisk (如 initrd) 是 基于ram的块设备，这表明它是一块固定大小的内存，它可以被格式化及挂载，就像磁盘一样。这表明 ramdisk 的内容需先格式化并用特殊的工具(像是 mke2fs 及 losetup)做前置作业，而且如同所有的块设备，它需要文件系统驱动程序在执行时期解释数据。这也有人工的大小限制不论是浪费空间(若 ramdisk 没有满，已被占用的额外的内存也不能用来做其它事)或容量限制(若 ramdisk 满了，但其它仍有闲置的内存，也不能不经由重新格式化将它扩展)。</p>
<p>但 ramdisk 由于缓冲机制（caching）实际上浪费了更多内存。Linux 被设计为将所有的文件及目录做缓存，不论是对块设备的读出或写入，所以 Linux 复制数据到 ramdisk及从 ramdisk 复制数据出来，page cache 给 file data 用，而 dentry cache 给目录用。ramdisk 的下面则伪装为块设备。</p>
<p>几年前，Linus Torvalds 有一个巧妙的想法：Linux 的缓存是否可以被挂载一个文件系统？只要保持文件在缓存中且不要将它们清除，直到它们被删除或系统重新启动？Linus 写了一小段程序将缓存包起来，称它为 ramfs，而其它的 kernel 开发者建立一个加强版本称为 tmpfs(它可以写数据到 swap，及限制挂载点的大小，所以在它消耗完所有可用的内存前它会填满)。initramfs 就是 tmpfs 的一个实例。<br>这些基于ram的文件系统自己改变大小以符合数据所需的大小。增加文件到 ramfs(或增大原有的文件)会自动配置更多的内存，并删除或截去文件以释放内存。在块设备及缓存间没有复制动作，因为没有实际的块设备。在缓存中的只是数据的复制。更好的是这并不是新的程序代码，而是已存在的 Linux 缓存程序代码新的应用，这表示它几乎没有增加大小，非常简单，且基于已经历测试的基础上。</p>
<p>系统使用 initramfs 作为它的 root 文件系统甚至不需要将文件系统驱动程序内建到 kernel，因为没有块设备要用来做文件服务器。只是存在内存中的文件罢了。</p>
<h3 id="initrd-vs-initramfs"><a href="#initrd-vs-initramfs" class="headerlink" title="initrd vs initramfs"></a>initrd vs initramfs</h3><p>底层架构的改变是 kernel 开发者建立一个新的实现的理由，但当他们在那里时他们清除了很多不好的行为及假设。<br>initrd 被设计为旧的 root= 的 root 设备检测程序代码的前端，而不是取代它。它执行 /linuxrc，这被用来完成设定功能(像是登入网络，决定哪个设备含有 root 分区，或用文件做为 loopback 设备)，告诉 kernel 哪个块设备含有真的 root 设备(通过写入de_t 数据到 /proc/sys/kernel/real-root-dev)，且回传给 kernel，所以 kernel 可以挂载真的 root 设备及执行真的 init 程序。</p>
<p>这里假设“真的根设备”是块设备而不是网络共享的，同时也假设 initrd 自己不是做为真的 root 文件系统。kernel 也不会执行 /linuxrc 而做为特殊的进程（ID=1），因为这个 process ID(它有特殊的属性，像是做为唯一无法被以 kill -9 的 process) 被保留给 init，kernel 在它挂载真的 root 文件系统后会等它执行。</p>
<p>用 initramfs，kernel 开发者移除所有的假设。当 kernel 启动了在 initramfs 外的 /init，kernel 即做好决定并回去等待接受命令。用 initramfs，kernel 不需要关心真的 root 档案系统在哪里，而在 initramfs 的 /init 被执行为真的 init，以 PID 1。(若 initramfs 的 init 需要不干涉特别的 PID 给其它程序，它可以用 exec() 系统呼叫，就像其它人一样)</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>传统的 root= kernel 命令列选项仍然被支持且可用。但在开发支持initial RAM disk支持内核时，提供了许多优化和灵活性。</p>
<h3 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h3><p><strong>查看initramfs的内容</strong></p>
<pre><code># mkdir initrd
# cd intrd
# cp /boot/initrd.img initrd.img
# gunzip initrd.img
# cpio -i --make-directories &lt; initrd.img
#
</code></pre><p><strong>创建initramfs</strong></p>
<p>a. mkinitramf</p>
<pre><code># mkinitramfs -o /boot/initrd.img 2.6.2
</code></pre><p>Note: 2.6.25是需要创建initramfs的kernel版本号，如果是给当前kernel制作initramfs，可以用uname -r查看当前的版本号。提供kernel版本号的主要目的是为了在initramfs中添加指定kernel的驱动模块。mkinitramfs会把/lib/modules/${kernel_version}/ 目录下的一些启动会用到的模块添加到initramfs中。</p>
<p>b. update-initramfs</p>
<p>更新当前kernel的initramfs</p>
<pre><code># update-initramfs -u
</code></pre><p>在添加模块时，initramfs tools只会添加一些必要模块，用户可以通过在/etc/initramfs-tools/modules文件中加入模块名称来指定必须添加的模块。</p>
<p>命令：mkinitramfs, update-initramfs</p>
<p><strong>mkinitcpio</strong></p>
<p>在Arch Linux中，有一个新一代的initramfs制作工具。相对于老的mkinitrd和mkinitramfs，它有以下很多优点。查看详细《使用mkinitcpio》。</p>
<p><strong>参考链接</strong>：</p>
<ul>
<li>精通initramfs构建 <a href="http://linuxman.blog.ccidnet.com/blog-htm-do-list-uid-60710-type-blog-dirid-14402.html" target="_blank" rel="external">http://linuxman.blog.ccidnet.com/blog-htm-do-list-uid-60710-type-blog-dirid-14402.html</a> </li>
<li>制作initramfs镜像 <a href="http://www.diybl.com/course/6_system/linux/Linuxjs/200888/135080.html" target="_blank" rel="external">http://www.diybl.com/course/6_system/linux/Linuxjs/200888/135080.html</a>  </li>
</ul>
<hr>
<p>原文如下：</p>
<hr>
<h3 id="The-problem-Why-“root-”-doesn’t-scale"><a href="#The-problem-Why-“root-”-doesn’t-scale" class="headerlink" title="The problem. (Why “root=” doesn’t scale.)"></a>The problem. (Why “root=” doesn’t scale.)</h3><p>When the Linux kernel boots the system, it must find and run the first user program, generally called “init”. User programs live in filesystems, so the Linux kernel must find and mount the first (or “root”) filesystem in order to boot successfully.</p>
<p>Ordinarily, available filesystems are listed in the file /etc/fstab so the mount program can find them. But /etc/fstab is itself a file, stored in a filesystem. Finding the very first filesystem is a chicken and egg problem, and to solve it the kernel developers created the kernel command line option “root=”, to specify which device the root filesystem lives on.</p>
<p>Fifteen years ago, “root=” was easy to interpret. It was either a floppy drive or a partition on a hard drive. These days the root filesystem could be on dozens of different types of hardware (SCSI, SATA, flash MTD), or even spread across several of them in a RAID. Its location could move around from boot to boot, such as hot pluggable USB devices on a system with multiple USB ports – when there are several USB devices, which one is correct? The root filesystem might be compressed (how?), encrypted (with what keys?), or loopback mounted (where?). It could even live out on a network server, requiring the kernel to acquire a DHCP address, perform a DNS lookup, and log in to a remote server (with username and password), all before the kernel can find and run the first userspace program.</p>
<p>These days, “root=” just isn’t enough information. Even hard-wiring tons of special case behavior into the kernel doesn’t help with device enumeration, encryption keys, or network logins that vary from system to system. Worse, programming the kernel to perform these kind of complicated multipart tasks is like writing web software in assembly language: it can be done, but it’s considerably easier to simply use the proper tools for the job. The kernel is designed to follow orders, not give them.</p>
<p>With no end to this ever-increasing complexity in sight, the kernel developers decided to back up and find a better way to deal with the whole problem.</p>
<h3 id="The-solution"><a href="#The-solution" class="headerlink" title="The solution"></a>The solution</h3><p>Linux 2.6 kernels bundle a small ram-based initial root filesystem into the kernel, and if this filesystem contains a program called “/init” the kernel runs that as its first program. At that point, finding some other filesystem containing some other program to run is no longer the kernel’s problem, but is now the job of the new program.</p>
<p>The contents of initramfs don’t have to be general purpose. If a given system’s root filesystem lives on an encrypted network block device, and the network address, login, and decryption key are all to be found on a USB device named “larry” (which requires a password to access), that system’s initramfs can have a special-purpose program that knows all about that, and makes it happen.</p>
<p>For systems that don’t need a large root filesystem, there’s no need to locate or switch to any other root filesystem.</p>
<h3 id="How-is-this-different-from-initrd"><a href="#How-is-this-different-from-initrd" class="headerlink" title="How is this different from initrd?"></a>How is this different from initrd?</h3><p>The linux kernel already had a way to provide a ram-based root filesystem, the initrd mechanism. For 2.4 and earlier kernels, initrd is still the only way to do this sort of thing. But the kernel developers chose to implement a new mechanism in 2.6 for several reasons.</p>
<h3 id="ramdisk-vs-ramfs-1"><a href="#ramdisk-vs-ramfs-1" class="headerlink" title="ramdisk vs ramfs"></a>ramdisk vs ramfs</h3><p>A ramdisk (like initrd) is a ram based block device, which means it’s a fixed size chunk of memory that can be formatted and mounted like a disk. This means the contents of the ramdisk have to be formatted and prepared with special tools (such as mke2fs and losetup), and like all block devices it requires a filesystem driver to interpret the data at runtime. This also imposes an artificial size limit that either wastes space (if the ramdisk isn’t full, the extra memory it takes up still can’t be used for anything else) or limits capacity (if the ramdisk fills up but other memory is still free, you can’t expand it without reformatting it).</p>
<p>But ramdisks actually waste even more memory due to caching. Linux is designed to cache all files and directory entries read from or written to block devices, so Linux copies data to and from the ramdisk into the “page cache” (for file data), and the “dentry cache” (for directory entries). The downside of the ramdisk pretending to be a block device is it gets treated like a block device.</p>
<p>A few years ago, Linus Torvalds had a neat idea: what if Linux’s cache could be mounted like a filesystem? Just keep the files in cache and never get rid of them until they’re deleted or the system reboots? Linus wrote a tiny wrapper around the cache called “ramfs”, and other kernel developers created an improved version called “tmpfs” (which can write the data to swap space, and limit the size of a given mount point so it fills up before consuming all available memory). Initramfs is an instance of tmpfs.</p>
<p>These ram based filesystems automatically grow or shrink to fit the size of the data they contain. Adding files to a ramfs (or extending existing files) automatically allocates more memory, and deleting or truncating files frees that memory. There’s no duplication between block device and cache, because there’s no block device. The copy in the cache is the only copy of the data. Best of all, this isn’t new code but a new application for the existing Linux caching code, which means it adds almost no size, is very simple, and is based on extremely well tested infrastructure.</p>
<p>A system using initramfs as its root filesystem doesn’t even need a single filesystem driver built into the kernel, because there are no block devices to interpret as filesystems. Just files living in memory.</p>
<h3 id="Initrd-vs-initramfs"><a href="#Initrd-vs-initramfs" class="headerlink" title="Initrd vs initramfs"></a>Initrd vs initramfs</h3><p>The change in underlying infrastructure was a reason for the kernel developers to create a new implementation, but while they were at it they cleaned up a lot of bad behavior and assumptions.</p>
<p>Initrd was designed as front-end to the old “root=” root device detection code, not a replacement for it. It ran a program called “/linuxrc” which was intended to perform setup functions (like logging on to the network, determining which of several devices contained the root partition, or associating a loopback device with a file), tell the kernel which block device contained the real root device (by writing the de_t number to /proc/sys/kernel/real-root-dev), and then return to the kernel so the kernel could mount the real root device and execute the real init program.</p>
<p>This assumed that the “real root device” was a block device rather than a network share, and also assumed that initrd wasn’t itself going to be the real root filesystem. The kernel didn’t even execute “/linuxrc” as the special process ID 1, because that process ID (and its special properties like being the only process that can not be killed with “kill -9”) was reserved for init, which the kernel was waiting to run after it mounted the real root filesystem.</p>
<p>With initramfs, the kernel developers removed all these assumptions. Once the kernel launches “/init” out of initramfs, the kernel is done making decisions and can go back to following orders. With initramfs, the kernel doesn’t care where the real root filesystem is (it’s initramfs until further notice), and the “/init” program from initramfs is run as a real init, with PID 1. (If initramfs’s init needs to hand that special Process ID off to another program, it can use the exec() syscall just like everybody else.)</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>The traditional root= kernel command-line option is still supported and usable, but new developments in the types of initial RAM disks supported by the kernel provide many optimizations and much-needed flexibility for the future of the Linux kernel. The next article in this series, available in next month’s issue of TimeSource, explains how you can start making the transition to the new initramfs initial RAM disk mechanism.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2009/02/05/posix-thread-cn/" itemprop="url">
                  POSIX多线程程序设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2009-02-05T22:27:00+09:00" content="2009-02-05">
              2009-02-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux开发/" itemprop="url" rel="index">
                    <span itemprop="name">Linux开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2009/02/05/posix-thread-cn/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2009/02/05/posix-thread-cn/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li><a href="#abstract">摘要</a>  </li>
<li><a href="#david">译者序</a></li>
<li><a href="#pthread-intro">Pthreads 概述</a><br> 3.1 <a href="#3.1">什么是线程?</a><br> 3.2 <a href="#3.2">什么是Pthreads?</a><br> 3.3 <a href="#3.3">为什么使用Pthreads?</a><br> 3.4 <a href="#3.4">使用线程设计程序</a>   </li>
<li><a href="#4">Pthreads API编译多线程程序</a>  </li>
<li><a href="#5">线程管理</a><br> 5.1 <a href="#5.1">创建和终止线程</a><br> 5.2 <a href="#5.2">向线程传递参数</a><br> 5.3 <a href="#5.3">连接（Joining）和分离（Detaching）线程</a><br> 5.4 <a href="#5.4">栈管理</a><br> 5.5 <a href="#5.5">其它函数</a>   </li>
<li><a href="#6">互斥量（Mutex Variables）</a><br> 6.1 <a href="#6.1">互斥量概述</a><br> 6.2 <a href="#6.2">创建和销毁互斥量</a><br> 6.3 <a href="#6.3">锁定（Locking）和解锁（Unlocking）互斥量</a>  </li>
<li><a href="#7">条件变量（Condition Variable）</a><br> 7.1 <a href="#7.1">条件变量概述</a><br> 7.2 <a href="#7.2">创建和销毁条件变量</a><br> 7.3 <a href="#7.3">等待（Waiting）和发送信号（Signaling）</a>  </li>
<li><a href="#8">没有覆盖的主题</a></li>
<li><a href="#9">Pthread 库API参考</a>  </li>
<li><a href="#10">参考资料</a></li>
</ol>
<hr>
<h3 id="1-摘要"><a href="#1-摘要" class="headerlink" title=" 1. 摘要"></a><a id="abstract"></a> 1. 摘要</h3><p>在多处理器共享内存的架构中（如：对称多处理系统SMP），线程可以用于实现程序的并行性。历史上硬件销售商实现了各种私有版本的多线程库，使得软件开发者不得不关心它的移植性。对于UNIX系统，IEEE POSIX 1003.1标准定义了一个C语言多线程编程接口。依附于该标准的实现被称为POSIX theads 或 Pthreads。 </p>
<p>该教程介绍了Pthreads的概念、动机和设计思想。内容包含了Pthreads API主要的三大类函数：线程管理（Thread Managment）、互斥量（Mutex Variables）和条件变量（Condition Variables）。向刚开始学习Pthreads的程序员提供了演示例程。 </p>
<p>适于：刚开始学习使用线程实现并行程序设计；对于C并行程序设计有基本了解。不熟悉并行程序设计的可以参考EC3500: Introduction To Parallel Computing。</p>
<hr>
<h3 id="2-译者序"><a href="#2-译者序" class="headerlink" title=" 2. 译者序"></a><a id="david"></a> 2. 译者序</h3><p>三天时间，终于在工作期间，抽空把上一篇POSIX threads programing翻译完了。由于水平有限，翻译质量差强人意，若有不合理或错误之处，请您之处，在此深表感谢！有疑问点此查看原文。在参考部分提及的几本关于Pthreads库的大作及该文章原文和译文可在下面的连接下载：</p>
<ul>
<li>本篇及其英文原文:  <a href="http://download.csdn.net/source/992256" target="_blank" rel="external">http://download.csdn.net/source/992256</a></li>
<li>多线程编程指南:  <a href="http://download.csdn.net/source/992248" target="_blank" rel="external">http://download.csdn.net/source/992248</a></li>
<li>Programing with POSIX thread(强烈推荐): <a href="http://download.csdn.net/source/992239" target="_blank" rel="external">http://download.csdn.net/source/992239</a></li>
<li>Pthread Primer(强烈推荐): <a href="http://download.csdn.net/source/992213" target="_blank" rel="external">http://download.csdn.net/source/992213</a></li>
</ul>
<hr>
<h3 id="3-Pthreads概述"><a href="#3-Pthreads概述" class="headerlink" title=" 3. Pthreads概述"></a><a id="pthread-intro"></a> 3. Pthreads概述</h3><h4 id="3-1-什么是线程"><a href="#3-1-什么是线程" class="headerlink" title=" 3.1 什么是线程?"></a><a id="3.1"></a> 3.1 什么是线程?</h4><p>技术上，线程可以定义为：可以被操作系统调度的独立的指令流。但是这是什么意思呢？ </p>
<p>对于软件开发者，在主程序中运行的“函数过程”可以很好的描述线程的概念。 </p>
<p>进一步，想象下主程序（a.out）包含了许多函数，操作系统可以调度这些函数，使之同时或者（和）独立的执行。这就描述了“多线程”程序。<br>怎样完成的呢？ </p>
<p>在理解线程之前，应先对UNIX进程（process）有所了解。进程被操作系统创建，需要相当多的“额外开销”。进程包含了程序的资源和执行状态信息。如下： </p>
<ul>
<li>进程ID，进程group ID，用户ID和group ID </li>
<li>环境 </li>
<li>工作目录  </li>
<li>程序指令 </li>
<li>寄存器 </li>
<li>栈 </li>
<li>堆 </li>
<li>文件描述符 </li>
<li>信号操作（Signal actions） </li>
<li>共享库 </li>
<li>进程间通信工具（如：消息队列，管道，信号量或共享内存） </li>
</ul>
<p><img src="/images/2009-02-05-process.gif" alt="进程"></p>
<p>线程使用并存在于进程资源中，还可以被操作系统调用并独立地运行，这主要是因为线程仅仅复制必要的资源以使自己得以存在并执行。 </p>
<p>独立的控制流得以实现是因为线程维持着自己的： </p>
<ul>
<li>堆栈指针 </li>
<li>寄存器 </li>
<li>调度属性（如：策略或优先级） </li>
<li>待定的和阻塞的信号集合（Set of pending and blocked signals） </li>
<li>线程专用数据（TSD：Thread Specific Data.） </li>
</ul>
<p>因此，在UNIX环境下线程： </p>
<ul>
<li>存在于进程，使用进程资源 </li>
<li>拥有自己独立的控制流，只要父进程存在并且操作系统支持 </li>
<li>只复制必可以使得独立调度的必要资源 </li>
<li>可以和其他线程独立（或非独立的）地共享进程资源 </li>
<li>当父进程结束时结束，或者相关类似的 </li>
<li>是“轻型的”，因为大部分额外开销已经在进程创建时完成了 </li>
</ul>
<p>因为在同一个进程中的线程共享资源： </p>
<ul>
<li>一个线程对系统资源（如关闭一个文件）的改变对所有其它线程是可以见的 </li>
<li>两个同样值的指针指向相同的数据 </li>
<li>读写同一个内存位置是可能的，因此需要成员显式地使用同步 </li>
</ul>
<hr>
<h4 id="3-2-什么是-Pthreads"><a href="#3-2-什么是-Pthreads" class="headerlink" title=" 3.2 什么是 Pthreads?"></a><a id="3.2"></a> 3.2 什么是 Pthreads?</h4><p>历史上，硬件销售商实现了私有版本的多线程库。这些实现在本质上各自不同，使得程序员难于开发可移植的应用程序。 </p>
<p>为了使用线程所提供的强大优点，需要一个标准的程序接口。对于UNIX系统，IEEE POSIX 1003.1c（1995）标准制订了这一标准接口。依赖于该标准的实现就称为POSIX threads 或者Pthreads。现在多数硬件销售商也提供Pthreads，附加于私有的API。 </p>
<p>Pthreads 被定义为一些C语言类型和函数调用，用pthread.h头（包含）文件和线程库实现。这个库可以是其它库的一部分，如libc。 </p>
<hr>
<h4 id="3-3-为什么使用-Pthreads"><a href="#3-3-为什么使用-Pthreads" class="headerlink" title=" 3.3 为什么使用 Pthreads?"></a><a id="3.3"></a> 3.3 为什么使用 Pthreads?</h4><p>使用Pthreads的主要动机是提高潜在程序的性能。 </p>
<p>当与创建和管理进程的花费相比，线程可以使用操作系统较少的开销，管理线程需要较少的系统资源。 </p>
<p>例如，下表比较了fork()函数和pthread_create()函数所用的时间。计时反应了50,000个进程/线程的创建，使用时间工具实现，单位是秒，没有优化标志。 </p>
<p>备注：不要期待系统和用户时间加起来就是真实时间，因为这些SMP系统有多个CPU同时工作。这些都是近似值。 </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th rowspan="2">平台</th><br>            <th colspan="3">fork()</th><br>            <th colspan="3">pthread_create()</th><br>        </tr><br>        <tr><br>            <th>real</th><br>            <th>user</th><br>            <th>sys</th><br>            <th>real</th><br>            <th>user</th><br>            <th>sys</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>AMD 2.4 GHz Opteron (8cpus/node) </td><br>            <td>41.07</td><br>            <td>60.08</td><br>            <td>9.01</td><br>            <td>0.66</td><br>            <td>0.19</td><br>            <td>0.43</td><br>        </tr><br>        <tr><br>            <td>IBM 1.9 GHz POWER5 p5-575 (8cpus/node) </td><br>            <td>64.24</td><br>            <td>30.78</td><br>            <td>27.68</td><br>            <td>1.75</td><br>            <td>0.69</td><br>            <td>1.10</td><br>        </tr><br>        <tr><br>            <td>IBM 1.5 GHz POWER4 (8cpus/node) </td><br>            <td>104.05</td><br>            <td>48.64</td><br>            <td>47.21</td><br>            <td>2.01</td><br>            <td>1.00</td><br>            <td>1.52</td><br>        </tr><br>        <tr><br>            <td>INTEL 2.4 GHz Xeon (2 cpus/node) </td><br>            <td>54.95</td><br>            <td>1.54</td><br>            <td>20.78</td><br>            <td>1.64</td><br>            <td>0.67</td><br>            <td>0.90</td><br>        </tr><br>        <tr><br>            <td>INTEL 1.4 GHz Itanium2 (4 cpus/node)  </td><br>            <td>54.54</td><br>            <td>1.07</td><br>            <td>22.22</td><br>            <td>2.03</td><br>            <td>1.26</td><br>            <td>0.67</td><br>        </tr><br>    </tbody><br></table>

<p>在同一个进程中的所有线程共享同样的地址空间。较于进程间的通信，在许多情况下线程间的通信效率比较高，且易于使用。 </p>
<p>较于没有使用线程的程序，使用线程的应用程序有潜在的性能增益和实际的优点： </p>
<ul>
<li>CPU使用I/O交叠工作：例如，一个程序可能有一个需要较长时间的I/O操作，当一个线程等待I/O系统调用完成时，CPU可以被其它线程使用。 </li>
<li>优先/实时调度：比较重要的任务可以被调度，替换或者中断较低优先级的任务。 </li>
<li>异步事件处理：频率和持续时间不确定的任务可以交错。例如，web服务器可以同时为前一个请求传输数据和管理新请求。 </li>
</ul>
<p>考虑在SMP架构上使用Pthreads的主要动机是获的最优的性能。特别的，如果一个程序使用MPI在节点通信，使用Pthreads可以使得节点数据传输得到显著提高。 </p>
<p>例如： </p>
<ul>
<li>MPI库经常用共享内存实现节点任务通信，这至少需要一次内存复制操作（进程到进程）。 </li>
<li>Pthreads没有中间的内存复制，因为线程和一个进程共享同样的地址空间。没有数据传输。变成cache-to-CPU或memory-to-CPU的带宽（最坏情况），速度是相当的快。 </li>
<li>比较如下： </li>
</ul>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th>Platform</th><br>            <th>MPI Shared Memory Bandwidth(GB/sec) </th><br>            <th>Pthreads Worst Case Memory-to-CPU Bandwidth (GB/sec) </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>AMD 2.4 GHz Opteron </td><br>            <td>1.2</td><br>            <td>5.3</td><br>        </tr><br>        <tr><br>            <td>IBM 1.9 GHz POWER5 p5-575</td><br>            <td>4.1</td><br>            <td>16</td><br>        </tr><br>        <tr><br>            <td>IBM 1.5 GHz POWER4 </td><br>            <td>2.1</td><br>            <td>4</td><br>        </tr><br>        <tr><br>            <td>Intel 1.4 GHz Xeon </td><br>            <td>0.3</td><br>            <td>4.3</td><br>        </tr><br>        <tr><br>            <td>Intel 1.4 GHz Itanium 2</td><br>            <td>1.8</td><br>            <td>6.4</td><br>        </tr><br>    </tbody><br></table>

<hr>
<h4 id="3-4-使用线程设计程序"><a href="#3-4-使用线程设计程序" class="headerlink" title=" 3.4 使用线程设计程序"></a><a id="3.4"></a> 3.4 使用线程设计程序</h4><h5 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程:"></a>并行编程:</h5><p>在现代多CPU机器上，pthread非常适于并行编程。可以用于并行程序设计的，也可以用于pthread程序设计。 </p>
<p>并行程序要考虑许多，如下： </p>
<ul>
<li>用什么并行程序设计模型？ </li>
<li>问题划分 </li>
<li>加载平衡（Load balancing） </li>
<li>通信 </li>
<li>数据依赖 </li>
<li>同步和竞争条件 </li>
<li>内存问题 </li>
<li>I/O问题 </li>
<li>程序复杂度 </li>
<li>程序员的努力/花费/时间 </li>
<li>…  </li>
</ul>
<p>包含这些主题超出本教程的范围，有兴趣的读者可以快速浏览下“Introduction to Parallel Computing”教程。 </p>
<p>大体上，为了使用Pthreads的优点，必须将任务组织程离散的，独立的，可以并发执行的。例如，如果routine1和routine2可以互换，相互交叉和（或者）重叠，他们就可以线程化。 </p>
<p>拥有下述特性的程序可以使用pthreads： </p>
<ul>
<li>工作可以被多个任务同时执行，或者数据可以同时被多个任务操作。 </li>
<li>阻塞与潜在的长时间I/O等待。 </li>
<li>在某些地方使用很多CPU循环而其他地方没有。 </li>
<li>对异步事件必须响应。 </li>
<li>一些工作比其他的重要（优先级中断）。 </li>
</ul>
<p>Pthreads 也可以用于串行程序，模拟并行执行。很好例子就是经典的web浏览器，对于多数人，运行于单CPU的桌面/膝上机器，许多东西可以同时“显示”出来。 </p>
<p>使用线程编程的几种常见模型： </p>
<ul>
<li><p><strong>管理者/工作者（Manager/worker）</strong>：一个单线程，作为管理器将工作分配给其它线程（工作者），典型的，管理器处理所有输入和分配工作给其它任务。至少两种形式的manager/worker模型比较常用：静态worker池和动态worker池。 </p>
</li>
<li><p><strong>管道（Pipeline）</strong>：任务可以被划分为一系列子操作，每一个被串行处理，但是不同的线程并发处理。汽车装配线可以很好的描述这个模型。 </p>
</li>
<li><p><strong>Peer</strong>: 和manager/worker模型相似，但是主线程在创建了其它线程后，自己也参与工作。 </p>
</li>
</ul>
<h5 id="共享内存模型（Shared-Memory-Model）"><a href="#共享内存模型（Shared-Memory-Model）" class="headerlink" title="共享内存模型（Shared Memory Model）:"></a>共享内存模型（Shared Memory Model）:</h5><p>所有线程可以访问全局，共享内存 </p>
<p>线程也有自己私有的数据 </p>
<p>程序员负责对全局共享数据的同步存取（保护） </p>
<h5 id="线程安全（Thread-safeness）"><a href="#线程安全（Thread-safeness）" class="headerlink" title="线程安全（Thread-safeness）:"></a>线程安全（Thread-safeness）:</h5><p>线程安全：简短的说，指程序可以同时执行多个线程却不会“破坏“共享数据或者产生“竞争”条件的能力。 </p>
<p>例如：假设你的程序创建了几个线程，每一个调用相同的库函数： </p>
<ul>
<li>这个库函数存取/修改了一个全局结构或内存中的位置。 </li>
<li>当每个线程调用这个函数时，可能同时去修改这个全局结构活内存位置。 </li>
<li>如果函数没有使用同步机制去阻止数据破坏，这时，就不是线程安全的了。 </li>
</ul>
<p>如果你不是100%确定外部库函数是线程安全的，自己负责所可能引发的问题。 </p>
<p>建议：小心使用库或者对象，当不能明确确定是否是线程安全的。若有疑虑，假设其不是线程安全的直到得以证明。可以通过不断地使用不确定的函数找出问题所在。 </p>
<hr>
<h3 id="4-编译多线程程序"><a href="#4-编译多线程程序" class="headerlink" title=" 4. 编译多线程程序"></a><a id="4"></a> 4. 编译多线程程序</h3><p>下表列出了一些编译使用了pthreads库程序的命令： </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th>Compiler/Platform</th><br>            <th>Compiler Command</th><br>            <th>Description</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td rowspan="3">IBM AIX</td><br>            <td>xlc_r / cc_r </td><br>            <td>C (ANSI  /  non-ANSI) </td><br>        </tr><br>        <tr><br>            <td>xlC_r </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td>xlf_r -qnosave, xlf90_r -qnosave </td><br>            <td>Fortran - using IBM’s Pthreads API (non-portable) </td><br>        </tr><br>        <tr><br>            <td rowspan="2">INTEL Linux </td><br>            <td>icc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>icpc -pthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">PathScale Linux  </td><br>            <td>pathcc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>pathCC -pthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">PGI Linux </td><br>            <td>pgcc -lpthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>pgCC -lpthread </td><br>            <td>C++</td><br>        </tr><br>        <tr><br>            <td rowspan="2">GNU Linux, AIX </td><br>            <td>gcc -pthread</td><br>            <td>C</td><br>        </tr><br>        <tr><br>            <td>g++ -pthread </td><br>            <td>C++</td><br>        </tr><br>    </tbody><br></table>

<hr>
<h3 id="5-线程管理（Thread-Management）"><a href="#5-线程管理（Thread-Management）" class="headerlink" title=" 5. 线程管理（Thread Management）"></a><a id="5"></a> 5. 线程管理（Thread Management）</h3><h4 id="5-1-创建和结束线程"><a href="#5-1-创建和结束线程" class="headerlink" title=" 5.1 创建和结束线程"></a><a id="5.1"></a> 5.1 创建和结束线程</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_create (thread,attr,start_routine,arg)  
pthread_exit (status)  
pthread_attr_init (attr)  
pthread_attr_destroy (attr)  
</code></pre><p><strong>创建线程</strong>:  </p>
<p>最初，main函数包含了一个缺省的线程。其它线程则需要程序员显式地创建。 </p>
<p>pthread_create 创建一个新线程并使之运行起来。该函数可以在程序的任何地方调用。 </p>
<p>pthread_create参数： </p>
<pre><code>thread：返回一个不透明的，唯一的新线程标识符。 
attr：不透明的线程属性对象。可以指定一个线程属性对象，或者NULL为缺省值。 
start_routine：线程将会执行一次的C函数。 
arg: 传递给start_routine单个参数，传递时必须转换成指向void的指针类型。没有参数传递时，可设置为NULL。 
</code></pre><p>一个进程可以创建的线程最大数量取决于系统实现。 </p>
<p>一旦创建，线程就称为peers，可以创建其它线程。线程之间没有指定的结构和依赖关系。 </p>
<p>Q：一个线程被创建后，怎么知道操作系统何时调度该线程使之运行？ </p>
<p>A：除非使用了Pthreads的调度机制，否则线程何时何地被执行取决于操作系统的实现。强壮的程序应该不依赖于线程执行的顺序。</p>
<p><strong>线程属性</strong>:</p>
<p>线程被创建时会带有默认的属性。其中的一些属性可以被程序员用线程属性对象来修改。 </p>
<p>pthread_attr_init 和 pthread_attr_destroy用于初始化/销毁先成属性对象。 </p>
<p>其它的一些函数用于查询和设置线程属性对象的指定属性。 </p>
<p>一些属性下面将会讨论。 </p>
<p><strong>结束终止</strong>:  </p>
<p>结束线程的方法有一下几种： </p>
<ul>
<li>线程从主线程（main函数的初始线程）返回。 </li>
<li>线程调用了pthread_exit函数。 </li>
<li>其它线程使用 pthread_cancel函数结束线程。 </li>
<li>调用exec或者exit函数，整个进程结束。 </li>
</ul>
<p>pthread_exit用于显式退出线程。典型地，pthread_exit()函数在线程完成工作时，不在需要时候被调用，退出线程。 </p>
<p>如果main()在其他线程创建前用pthread_exit()退出了，其他线程将会继续执行。否则，他们会随着main的结束而终止。 </p>
<p>程序员可以可选择的指定终止状态，当任何线程连接（join）该线程时，该状态就返回给连接（join）该线程的线程。 </p>
<p>清理：pthread_exit()函数并不会关闭文件，任何在线程中打开的文件将会一直处于打开状态，知道线程结束。 </p>
<p>讨论：对于正常退出，可以免于调用pthread_exit()。当然，除非你想返回一个返回值。然而，在main中，有一个问题，就是当main结束时，其它线程还没有被创建。如果此时没有显式的调用pthread_exit()，当main结束时，进程（和所有线程）都会终止。可以在main中调用pthread_exit()，此时尽管在main中已经没有可执行的代码了，进程和所有线程将保持存活状态，。 </p>
<p><strong>例子: Pthread 创建和终止</strong></p>
<p>该例用pthread_create()创建了5个线程。每一个线程都会打印一条“Hello World”的消息，然后调用pthread_exit()终止线程。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NUM_THREADS     5 </div><div class="line"> </div><div class="line">void *PrintHello(void *threadid) </div><div class="line">&#123; </div><div class="line">   int tid; </div><div class="line">   tid = (int)threadid; </div><div class="line">   printf(&quot;Hello World! It&apos;s me, thread #%d!/n&quot;, tid); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t threads[NUM_THREADS]; </div><div class="line">   int rc, t; </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++)&#123; </div><div class="line">      printf(&quot;In main: creating thread %d/n&quot;, t); </div><div class="line">      rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t); </div><div class="line">      if (rc)&#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create() is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-2-向线程传递参数"><a href="#5-2-向线程传递参数" class="headerlink" title=" 5.2 向线程传递参数"></a><a id="5.2"></a> 5.2 向线程传递参数</h4><p>pthread_create()函数允许程序员想线程的start routine传递一个参数。当多个参数需要被传递时，可以通过定义一个结构体包含所有要传的参数，然后用pthread_create()传递一个指向改结构体的指针，来打破传递参数的个数的限制。<br>所有参数都应该传引用传递并转化成（void*）。 </p>
<pre><code>Q：怎样安全地向一个新创建的线程传递数据？ 
A：确保所传递的数据是线程安全的（不能被其他线程修改）。下面三个例子演示了那个应该和那个不应该。 
</code></pre><p>Example 1 - Thread Argument Passing  </p>
<p>下面的代码片段演示了如何向一个线程传递一个简单的整数。主线程为每一个线程使用一个唯一的数据结构，确保每个线程传递的参数是完整的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int *taskids[NUM_THREADS]; </div><div class="line"> </div><div class="line">for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">&#123; </div><div class="line">   taskids[t] = (int *) malloc(sizeof(int)); </div><div class="line">   *taskids[t] = t; </div><div class="line">   printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) taskids[t]); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example 2 - Thread Argument Passing  </p>
<p>例子展示了用结构体向线程设置/传递参数。每个线程获得一个唯一的结构体实例。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct thread_data&#123; </div><div class="line">   int  thread_id; </div><div class="line">   int  sum; </div><div class="line">   char *message; </div><div class="line">&#125;; </div><div class="line"> </div><div class="line">struct thread_data thread_data_array[NUM_THREADS]; </div><div class="line"> </div><div class="line">void *PrintHello(void *threadarg) </div><div class="line">&#123; </div><div class="line">   struct thread_data *my_data; </div><div class="line">   ... </div><div class="line">   my_data = (struct thread_data *) threadarg; </div><div class="line">   taskid = my_data-&gt;thread_id; </div><div class="line">   sum = my_data-&gt;sum; </div><div class="line">   hello_msg = my_data-&gt;message; </div><div class="line">   ... </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   ... </div><div class="line">   thread_data_array[t].thread_id = t; </div><div class="line">   thread_data_array[t].sum = sum; </div><div class="line">   thread_data_array[t].message = messages[t]; </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) &amp;thread_data_array[t]); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example 3 - Thread Argument Passing (Incorrect)  </p>
<p>例子演示了错误地传递参数。循环会在线程访问传递的参数前改变传递给线程的地址的内容。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int rc, t; </div><div class="line"> </div><div class="line">for(t=0; t&lt;NUM_THREADS; t++)  </div><div class="line">&#123; </div><div class="line">   printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">   rc = pthread_create(&amp;threads[t], NULL, PrintHello,  </div><div class="line">        (void *) &amp;t); </div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-3-连接（Joining）和分离（Detaching）线程"><a href="#5-3-连接（Joining）和分离（Detaching）线程" class="headerlink" title=" 5.3 连接（Joining）和分离（Detaching）线程"></a><a id="5.3"></a> 5.3 连接（Joining）和分离（Detaching）线程</h4><p><strong>函数</strong>:  </p>
<pre><code>pthread_detach (threadid,status)  
pthread_attr_setdetachstate (attr,detachstate)  
pthread_attr_getdetachstate (attr,detachstate)  
pthread_join (threadid,status)  
</code></pre><p><strong>连接</strong>: </p>
<p>“连接”是一种在线程间完成同步的方法。例如： </p>
<p>pthread_join()函数阻赛调用线程知道threadid所指定的线程终止。 </p>
<p>如果在目标线程中调用pthread_exit()，程序员可以在主线程中获得目标线程的终止状态。 </p>
<p>连接线程只能用pthread_join()连接一次。若多次调用就会发生逻辑错误。 </p>
<p>两种同步方法，互斥量（mutexes）和条件变量（condition variables），稍后讨论。 </p>
<p>可连接（Joinable or Not）?  </p>
<p>当一个线程被创建，它有一个属性定义了它是可连接的（joinable）还是分离的（detached）。只有是可连接的线程才能被连接（joined），若果创建的线程是分离的，则不能连接。 </p>
<p>POSIX标准的最终草案指定了线程必须创建成可连接的。然而，并非所有实现都遵循此约定。 </p>
<p>使用pthread_create()的attr参数可以显式的创建可连接或分离的线程，典型四步如下： </p>
<ul>
<li>声明一个pthread_attr_t数据类型的线程属性变量 </li>
<li>用pthread_attr_init()初始化改属性变量 </li>
<li>用pthread_attr_setdetachstate()设置可分离状态属性 </li>
<li>完了后，用pthread_attr_destroy()释放属性所占用的库资源 </li>
</ul>
<p><strong>分离（Detaching）</strong>：</p>
<p>pthread_detach()可以显式用于分离线程，尽管创建时是可连接的。<br>没<br>有与pthread_detach()功能相反的函数 </p>
<p><strong>建议</strong>：</p>
<ul>
<li>若线程需要连接，考虑创建时显式设置为可连接的。因为并非所有创建线程的实现都是将线程创建为可连接的。 </li>
<li>若事先知道线程从不需要连接，考虑创建线程时将其设置为可分离状态。一些系统资源可能需要释放。 </li>
</ul>
<p><strong>例子: Pthread Joining</strong></p>
<p>Example Code - Pthread Joining  </p>
<p>这个例子演示了用Pthread join函数去等待线程终止。因为有些实现并不是默认创建线程是可连接状态，例子中显式地将其创建为可连接的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NUM_THREADS    3 </div><div class="line"> </div><div class="line">void *BusyWork(void *null) </div><div class="line">&#123; </div><div class="line">   int i; </div><div class="line">   double result=0.0; </div><div class="line">   for (i=0; i&lt;1000000; i++) </div><div class="line">   &#123; </div><div class="line">     result = result + (double)random(); </div><div class="line">   &#125; </div><div class="line">   printf(&quot;result = %e/n&quot;,result); </div><div class="line">   pthread_exit((void *) 0); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t thread[NUM_THREADS]; </div><div class="line">   pthread_attr_t attr; </div><div class="line">   int rc, t; </div><div class="line">   void *status; </div><div class="line"> </div><div class="line">   /* Initialize and set thread detached attribute */ </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line"> </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">   &#123; </div><div class="line">      printf(&quot;Creating thread %d/n&quot;, t); </div><div class="line">      rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, NULL);  </div><div class="line">      if (rc) </div><div class="line">      &#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create()  </div><div class="line">                is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   /* Free attribute and wait for the other threads */ </div><div class="line">   pthread_attr_destroy(&amp;attr); </div><div class="line">   for(t=0; t&lt;NUM_THREADS; t++) </div><div class="line">   &#123; </div><div class="line">      rc = pthread_join(thread[t], &amp;status); </div><div class="line">      if (rc) </div><div class="line">      &#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_join()  </div><div class="line">                is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">      printf(&quot;Completed join with thread %d status= %ld/n&quot;,t, (long)status); </div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-4-栈管理"><a href="#5-4-栈管理" class="headerlink" title=" 5.4 栈管理"></a><a id="5.4"></a> 5.4 栈管理</h4><p><strong>函数</strong>:  </p>
<pre><code>pthread_attr_getstacksize (attr, stacksize)  
pthread_attr_setstacksize (attr, stacksize)  
pthread_attr_getstackaddr (attr, stackaddr)  
pthread_attr_setstackaddr (attr, stackaddr)  
</code></pre><p><strong>防止栈问题</strong>:</p>
<p>POSIX标准并没有指定线程栈的大小，依赖于实现并随实现变化。 </p>
<p>很容易超出默认的栈大小，常见结果：程序终止或者数据损坏。 </p>
<p>安全和可移植的程序应该不依赖于默认的栈限制，但是取而代之的是用pthread_attr_setstacksize分配足够的栈大小。 </p>
<p>pthread_attr_getstackaddr和pthread_attr_setstackaddr函数可以被程序用于将栈设置在指定的内存区域。 </p>
<p>在LC上的一些实际例子:  </p>
<p>默认栈大小经常变化很大，最大值也变化很大，可能会依赖于每个节点的线程数目。 </p>
<table class="table table-striped"><br>    <thead><br>        <tr><br>            <th> Node Architecture</th><br>            <th> #CPUS </th><br>            <th> Memory(GB) </th><br>            <th> Default Size (bytes) </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td> AMD Opteron </td><br>            <td> 8 </td><br>            <td> 16 </td><br>            <td> 2,097,152 </td><br>        </tr><br>        <tr><br>            <td> Intel IA64 </td><br>            <td> 4 </td><br>            <td> 8 </td><br>            <td> 33,554,432 </td><br>        </tr><br>        <tr><br>            <td> Intel IA32 </td><br>            <td> 2 </td><br>            <td> 4 </td><br>            <td> 2,097,152 </td><br>        </tr><br>        <tr><br>            <td> IBM Power5 </td><br>            <td> 8 </td><br>            <td> 32 </td><br>            <td> 196,608</td><br>        </tr><br>        <tr><br>            <td> IBM Power4 </td><br>            <td> 8 </td><br>            <td> 16 </td><br>            <td> 196,608</td><br>        </tr><br>        <tr><br>            <td> IBM Power3 </td><br>            <td> 16 </td><br>            <td> 32 </td><br>            <td> 98,304 </td><br>        </tr><br>    </tbody><br></table>


<p><strong>例子: 栈管理</strong></p>
<p>Example Code - Stack Management  </p>
<p>这个例子演示了如何去查询和设定线程栈大小。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#define NTHREADS 4 </div><div class="line">#define N 1000 </div><div class="line">#define MEGEXTRA 1000000 </div><div class="line">  </div><div class="line">pthread_attr_t attr; </div><div class="line">  </div><div class="line">void *dowork(void *threadid) </div><div class="line">&#123; </div><div class="line">   double A[N][N]; </div><div class="line">   int i,j,tid; </div><div class="line">   size_t mystacksize; </div><div class="line"> </div><div class="line">   tid = (int)threadid; </div><div class="line">   pthread_attr_getstacksize (&amp;attr, &amp;mystacksize); </div><div class="line">   printf(&quot;Thread %d: stack size = %li bytes /n&quot;, tid, mystacksize); </div><div class="line">   for (i=0; i&lt;N; i++) </div><div class="line">     for (j=0; j&lt;N; j++) </div><div class="line">      A[i][j] = ((i*j)/3.452) + (N-i); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line">  </div><div class="line">int main(int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   pthread_t threads[NTHREADS]; </div><div class="line">   size_t stacksize; </div><div class="line">   int rc, t; </div><div class="line">  </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_getstacksize (&amp;attr, &amp;stacksize); </div><div class="line">   printf(&quot;Default stack size = %li/n&quot;, stacksize); </div><div class="line">   stacksize = sizeof(double)*N*N+MEGEXTRA; </div><div class="line">   printf(&quot;Amount of stack needed per thread = %li/n&quot;,stacksize); </div><div class="line">   pthread_attr_setstacksize (&amp;attr, stacksize); </div><div class="line">   printf(&quot;Creating threads with stack size = %li bytes/n&quot;,stacksize); </div><div class="line">   for(t=0; t&lt;NTHREADS; t++)&#123; </div><div class="line">      rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (void *)t); </div><div class="line">      if (rc)&#123; </div><div class="line">         printf(&quot;ERROR; return code from pthread_create() is %d/n&quot;, rc); </div><div class="line">         exit(-1); </div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line">   printf(&quot;Created %d threads./n&quot;, t); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="5-5-其他各种函数"><a href="#5-5-其他各种函数" class="headerlink" title=" 5.5 其他各种函数"></a><a id="5.5"></a> 5.5 其他各种函数</h4><pre><code>pthread_self ()  
pthread_equal (thread1,thread2)  
</code></pre><p>pthread_self返回调用该函数的线程的唯一，系统分配的线程ID。 </p>
<p>pthread_equal比较两个线程ID,若不同返回0，否则返回非0值。 </p>
<p>注意这两个函数中的线程ID对象是不透明的，不是轻易能检查的。因为线程ID是不透明的对象，所以C语言的==操作符不能用于比较两个线程ID。 </p>
<pre><code>pthread_once (once_control, init_routine)  
</code></pre><p>pthread_once 在一个进程中仅执行一次init_routine。任何线程第一次调用该函数会执行给定的init_routine，不带参数，任何后续调用都没有效果。 </p>
<p>init_routine函数一般是初始化的程序 </p>
<p>once_control参数是一个同步结构体，需要在调用pthread_once前初始化。例如： </p>
<pre><code>pthread_once_t once_control = PTHREAD_ONCE_INIT;  
</code></pre><hr>
<h3 id="6-互斥量（Mutex-Variables）"><a href="#6-互斥量（Mutex-Variables）" class="headerlink" title=" 6. 互斥量（Mutex Variables）"></a><a id="6"></a> 6. 互斥量（Mutex Variables）</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title=" 6.1 概述"></a><a id="6.1"></a> 6.1 概述</h4><p>互斥量（Mutex）是“mutual exclusion”的缩写。互斥量是实现线程同步，和保护同时写共享数据的主要方法 </p>
<p>互斥量对共享数据的保护就像一把锁。在Pthreads中，任何时候仅有一个线程可以锁定互斥量，因此，当多个线程尝试去锁定该互斥量时仅有一个会成功。直到锁定互斥量的线程解锁互斥量后，其他线程才可以去锁定互斥量。线程必须轮着访问受保护数据。 </p>
<p>互斥量可以防止“竞争”条件。下面的例子是一个银行事务处理时发生了竞争条件：</p>
<table class="table talbe.stripped"><br>    <thead><br>        <tr><br>            <th> Thread 1 </th><br>            <th> Thread 2 </th><br>            <th> Balance </th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Read balance: $1000 </td><br>            <td></td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Read balance: $1000 </td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Deposit $200 </td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td>Deposit $200</td><br>            <td></td><br>            <td>$1000</td><br>        </tr><br>        <tr><br>            <td>Update balance $1000+$200 </td><br>            <td></td><br>            <td>$1200</td><br>        </tr><br>        <tr><br>            <td></td><br>            <td>Update balance $1000+$200 </td><br>            <td>$1200</td><br>        </tr><br>    </tbody><br></table>

<p>上面的例子，当一个线程使用共享数据资源时，应该用一个互斥量去锁定“Balance”。 </p>
<p>一个拥有互斥量的线程经常用于更新全局变量。确保了多个线程更新同样的变量以安全的方式运行，最终的结果和一个线程处理的结果是相同的。这个更新的变量属于一个“临界区（critical section）”。 </p>
<p>使用互斥量的典型顺序如下： </p>
<ul>
<li>创建和初始一个互斥量 </li>
<li>多个线程尝试去锁定该互斥量 </li>
<li>仅有一个线程可以成功锁定改互斥量 </li>
<li>锁定成功的线程做一些处理 </li>
<li>线程解锁该互斥量 </li>
<li>另外一个线程获得互斥量，重复上述过程 </li>
<li>最后销毁互斥量 </li>
</ul>
<p>当多个线程竞争同一个互斥量时，失败的线程会阻塞在lock调用处。可以用“trylock”替换“lock”，则失败时不会阻塞。 </p>
<p>当保护共享数据时，程序员有责任去确认是否需要使用互斥量。如，若四个线程会更新同样的数据，但仅有一个线程用了互斥量，则数据可能会损坏。 </p>
<hr>
<h4 id="6-2-创建和销毁互斥量"><a href="#6-2-创建和销毁互斥量" class="headerlink" title=" 6.2 创建和销毁互斥量"></a><a id="6.2"></a> 6.2 创建和销毁互斥量</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_mutex_init (mutex,attr)  
pthread_mutex_destroy (mutex)  
pthread_mutexattr_init (attr)  
pthread_mutexattr_destroy (attr)  
</code></pre><p><strong>用法</strong>：</p>
<p>互斥量必须用类型pthread_mutex_t类型声明，在使用前必须初始化，这里有两种方法可以初始化互斥量： </p>
<p>声明时静态地，如：<br>    pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;  </p>
<p>动态地用pthread_mutex_init()函数，这种方法允许设定互斥量的属性对象attr。 </p>
<p>互斥量初始化后是解锁的。 </p>
<p>attr对象用于设置互斥量对象的属性，使用时必须声明为pthread_mutextattr_t类型，默认值可以是NULL。Pthreads标准定义了三种可选的互斥量属性： </p>
<ul>
<li>协议（Protocol）： 指定了协议用于阻止互斥量的优先级改变 </li>
<li>优先级上限（Prioceiling）：指定互斥量的优先级上限 </li>
<li>进程共享（Process-shared）：指定进程共享互斥量 </li>
</ul>
<p>注意所有实现都提供了这三个可先的互斥量属性。 </p>
<p>pthread_mutexattr_init()和pthread_mutexattr_destroy()函数分别用于创建和销毁互斥量属性对象。 </p>
<p>pthread_mutex_destroy()应该用于释放不需要再使用的互斥量对象。 </p>
<hr>
<h4 id="6-3-锁定和解锁互斥量"><a href="#6-3-锁定和解锁互斥量" class="headerlink" title=" 6.3 锁定和解锁互斥量"></a><a id="6.3"></a> 6.3 锁定和解锁互斥量</h4><p><strong>函数</strong>：  </p>
<pre><code>pthread_mutex_lock (mutex)  
pthread_mutex_trylock (mutex)  
pthread_mutex_unlock (mutex)  
</code></pre><p><strong>用法</strong>：</p>
<p>线程用pthread_mutex_lock()函数去锁定指定的mutex变量，若该mutex已经被另外一个线程锁定了，该调用将会阻塞线程直到mutex被解锁。 </p>
<p>pthread_mutex_trylock() will attempt to lock a mutex. However, if the mutex is already locked, the routine will return immediately with a “busy” error code. This routine may be useful in  </p>
<p>pthread_mutex_trylock()</p>
<p>尝试着去锁定一个互斥量，然而，若互斥量已被锁定，程序会立刻返回并返回一个忙错误值。该函数在优先级改变情况下阻止死锁是非常有用的。 </p>
<p>线程可以用pthread_mutex_unlock()解锁自己占用的互斥量。在一个线程完成对保护数据的使用，而其它线程要获得互斥量在保护数据上工作时，可以调用该函数。若有一下情形则会发生错误： </p>
<ul>
<li>互斥量已经被解锁 </li>
<li>互斥量被另一个线程占用 </li>
</ul>
<p>互斥量并没有多么“神奇”的，实际上，它们就是参与的线程的“君子约定”。写代码时要确信正确地锁定，解锁互斥量。下面演示了一种逻辑错误： </p>
<pre><code>·                    Thread 1     Thread 2     Thread 3 
·                    Lock         Lock          
·                    A = 2        A = A+1      A = A*B 
·                    Unlock       Unlock     
</code></pre><p>Q：有多个线程等待同一个锁定的互斥量，当互斥量被解锁后，那个线程会第一个锁定互斥量？ </p>
<p>A：除非线程使用了优先级调度机制，否则，线程会被系统调度器去分配，那个线程会第一个锁定互斥量是随机的。 </p>
<p><strong>例子：使用互斥量</strong></p>
<p>Example Code - Using Mutexes  </p>
<p>例程演示了线程使用互斥量处理一个点积（dot product）计算。主数据通过一个可全局访问的数据结构被所有线程使用，每个线程处理数据的不同部分，主线程等待其他线程完成计算并输出结果。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line">#include &lt;malloc.h&gt; </div><div class="line"> </div><div class="line">/*    </div><div class="line">The following structure contains the necessary information   </div><div class="line">to allow the function &quot;dotprod&quot; to access its input data and  </div><div class="line">place its output into the structure.   </div><div class="line">*/ </div><div class="line"> </div><div class="line">typedef struct  </div><div class="line"> &#123; </div><div class="line">   double      *a; </div><div class="line">   double      *b; </div><div class="line">   double     sum;  </div><div class="line">   int     veclen;  </div><div class="line"> &#125; DOTDATA; </div><div class="line"> </div><div class="line">/* Define globally accessible variables and a mutex */ </div><div class="line"> </div><div class="line">#define NUMTHRDS 4 </div><div class="line">#define VECLEN 100 </div><div class="line">   DOTDATA dotstr;  </div><div class="line">   pthread_t callThd[NUMTHRDS]; </div><div class="line">   pthread_mutex_t mutexsum; </div><div class="line"> </div><div class="line">/* </div><div class="line">The function dotprod is activated when the thread is created. </div><div class="line">All input to this routine is obtained from a structure  </div><div class="line">of type DOTDATA and all output from this function is written into </div><div class="line">this structure. The benefit of this approach is apparent for the  </div><div class="line">multi-threaded program: when a thread is created we pass a single </div><div class="line">argument to the activated function - typically this argument </div><div class="line">is a thread number. All  the other information required by the  </div><div class="line">function is accessed from the globally accessible structure.  </div><div class="line">*/ </div><div class="line"> </div><div class="line">void *dotprod(void *arg) </div><div class="line">&#123; </div><div class="line"> </div><div class="line">   /* Define and use local variables for convenience */ </div><div class="line"> </div><div class="line">   int i, start, end, offset, len ; </div><div class="line">   double mysum, *x, *y; </div><div class="line">   offset = (int)arg; </div><div class="line">      </div><div class="line">   len = dotstr.veclen; </div><div class="line">   start = offset*len; </div><div class="line">   end   = start + len; </div><div class="line">   x = dotstr.a; </div><div class="line">   y = dotstr.b; </div><div class="line"> </div><div class="line">   /* </div><div class="line">   Perform the dot product and assign result </div><div class="line">   to the appropriate variable in the structure.  </div><div class="line">   */ </div><div class="line"> </div><div class="line">   mysum = 0; </div><div class="line">   for (i=start; i&lt;end ; i++)  </div><div class="line">    &#123; </div><div class="line">      mysum += (x[i] * y[i]); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">   /* </div><div class="line">   Lock a mutex prior to updating the value in the shared </div><div class="line">   structure, and unlock it upon updating. </div><div class="line">   */ </div><div class="line">   pthread_mutex_lock (&amp;mutexsum); </div><div class="line">   dotstr.sum += mysum; </div><div class="line">   pthread_mutex_unlock (&amp;mutexsum); </div><div class="line"> </div><div class="line">   pthread_exit((void*) 0); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">/*  </div><div class="line">The main program creates threads which do all the work and then  </div><div class="line">print out result upon completion. Before creating the threads, </div><div class="line">the input data is created. Since all threads update a shared structure,  </div><div class="line">we need a mutex for mutual exclusion. The main thread needs to wait for </div><div class="line">all threads to complete, it waits for each one of the threads. We specify </div><div class="line">a thread attribute value that allow the main thread to join with the </div><div class="line">threads it creates. Note also that we free up handles when they are </div><div class="line">no longer needed. </div><div class="line">*/ </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">   int i; </div><div class="line">   double *a, *b; </div><div class="line">   void *status; </div><div class="line">   pthread_attr_t attr; </div><div class="line"> </div><div class="line">   /* Assign storage and initialize values */ </div><div class="line">   a = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); </div><div class="line">   b = (double*) malloc (NUMTHRDS*VECLEN*sizeof(double)); </div><div class="line">   </div><div class="line">   for (i=0; i&lt;VECLEN*NUMTHRDS; i++) </div><div class="line">    &#123; </div><div class="line">     a[i]=1.0; </div><div class="line">     b[i]=a[i]; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">   dotstr.veclen = VECLEN;  </div><div class="line">   dotstr.a = a;  </div><div class="line">   dotstr.b = b;  </div><div class="line">   dotstr.sum=0; </div><div class="line"> </div><div class="line">   pthread_mutex_init(&amp;mutexsum, NULL); </div><div class="line">          </div><div class="line">   /* Create threads to perform the dotproduct  */ </div><div class="line">   pthread_attr_init(&amp;attr); </div><div class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line"> </div><div class="line">        for(i=0; i&lt;NUMTHRDS; i++) </div><div class="line">        &#123; </div><div class="line">        /*  </div><div class="line">        Each thread works on a different set of data. </div><div class="line">        The offset is specified by &apos;i&apos;. The size of </div><div class="line">        the data for each thread is indicated by VECLEN. </div><div class="line">        */ </div><div class="line">        pthread_create( &amp;callThd[i], &amp;attr, dotprod, (void *)i); </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">        pthread_attr_destroy(&amp;attr); </div><div class="line"> </div><div class="line">        /* Wait on the other threads */ </div><div class="line">        for(i=0; i&lt;NUMTHRDS; i++) </div><div class="line">        &#123; </div><div class="line">          pthread_join( callThd[i], &amp;status); </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">   /* After joining, print out the results and cleanup */ </div><div class="line">   printf (&quot;Sum =  %f /n&quot;, dotstr.sum); </div><div class="line">   free (a); </div><div class="line">   free (b); </div><div class="line">   pthread_mutex_destroy(&amp;mutexsum); </div><div class="line">   pthread_exit(NULL); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="7-条件变量（Condition-Variables）"><a href="#7-条件变量（Condition-Variables）" class="headerlink" title=" 7. 条件变量（Condition Variables）"></a><a id="7"></a> 7. 条件变量（Condition Variables）</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title=" 7.1 概述"></a><a id="7.1"></a> 7.1 概述</h4><p>条件变量提供了另一种同步的方式。互斥量通过控制对数据的访问实现了同步，而条件变量允许根据实际的数据值来实现同步。 </p>
<p>没有条件变量，程序员就必须使用线程去轮询（可能在临界区），查看条件是否满足。这样比较消耗资源，因为线程连续繁忙工作。条件变量是一种可以实现这种轮询的方式。 </p>
<p>条件变量往往和互斥一起使用 </p>
<p>使用条件变量的代表性顺序如下： </p>
<pre><code>主线程（Main Thread）  
o                                声明和初始化需要同步的全局数据/变量（如“count”） 
o                                生命和初始化一个条件变量对象 
o                                声明和初始化一个相关的互斥量 
o                                创建工作线程A和B 

Thread A  
o                                工作，一直到一定的条件满足（如“count”等于一个指定的值） 
o                                锁定相关互斥量并检查全局变量的值 
o                                调用pthread_cond_wait()阻塞等待Thread-B的信号。注意pthread_cond_wait()能够自动地并且原子地解锁相关的互斥量，以至于它可以被Thread-B使用。 
o                                当收到信号，唤醒线程，互斥量被自动，原子地锁定。 
o                                显式解锁互斥量 
o                                继续 
Thread B  
o                                工作 
o                                锁定相关互斥量 
o                                改变Thread-A所等待的全局变量 
o                                检查全局变量的值，若达到需要的条件，像Thread-A发信号。 
o                                解锁互斥量 
o                                继续 

Main Thread  
Join / Continue  
</code></pre><hr>
<h4 id="7-2-创建和销毁条件变量"><a href="#7-2-创建和销毁条件变量" class="headerlink" title=" 7.2 创建和销毁条件变量"></a><a id="7.2"></a> 7.2 创建和销毁条件变量</h4><p><strong>Routines</strong>:  </p>
<pre><code>pthread_cond_init (condition,attr)  
pthread_cond_destroy (condition)  
pthread_condattr_init (attr)  
pthread_condattr_destroy (attr)  
</code></pre><p><strong>Usage</strong>:  </p>
<p>条件变量必须声明为pthread_cond_t类型，必须在使用前初始化。有两种方式可以初始条件变量： </p>
<p>声明时静态地。如：</p>
<pre><code>pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER;  
</code></pre><p>用pthread_cond_init()函数动态地。创建的条件变量ID通过condition参数返回给调用线程。该方式允许设置条件变量对象的属性，attr。 </p>
<p>可选的attr对象用于设定条件变量的属性。仅有一个属性被定义：线程共享（process-shared），可以使条件变量被其它进程中的线程看到。若要使用属性对象，必须定义为pthread_condattr_t类型（可以指定为NULL设为默认）。 </p>
<p>注意所有实现都提供了线程共享属性。 </p>
<p>pthread_condattr_init()和pthread_condattr_destroy()用于创建和销毁条件变量属性对象。 </p>
<p>条件变量不需要再使用时，应用pthread_cond_destroy()释放条件变量。 </p>
<hr>
<h4 id="7-3-在条件变量上等待（Waiting）和发送信号（Signaling）"><a href="#7-3-在条件变量上等待（Waiting）和发送信号（Signaling）" class="headerlink" title=" 7.3 在条件变量上等待（Waiting）和发送信号（Signaling）"></a><a id="7.3"></a> 7.3 在条件变量上等待（Waiting）和发送信号（Signaling）</h4><p><strong>函数</strong>：</p>
<pre><code>pthread_cond_wait (condition,mutex)  
pthread_cond_signal (condition)  
pthread_cond_broadcast (condition)  
</code></pre><p><strong>用法</strong>：</p>
<p>pthread_cond_wait()阻塞调用线程直到指定的条件受信（signaled）。该函数应该在互斥量锁定时调用，当在等待时会自动解锁互斥量。在信号被发送，线程被激活后，互斥量会自动被锁定，当线程结束时，由程序员负责解锁互斥量。 </p>
<p>pthread_cond_signal()函数用于向其他等待在条件变量上的线程发送信号（激活其它线程）。应该在互斥量被锁定后调用。 </p>
<p>若不止一个线程阻塞在条件变量上，则应用pthread_cond_broadcast()向其它所以线程发生信号。 </p>
<p>在调用pthread_cond_wait()前调用pthread_cond_signal()会发生逻辑错误。 </p>
<p>使用这些函数时适当的锁定和解锁相关的互斥量是非常重要的。如： </p>
<ul>
<li>调用pthread_cond_wait()前锁定互斥量失败可能导致线程不会阻塞。 </li>
<li>调用pthread_cond_signal()后解锁互斥量失败可能会不允许相应的pthread_cond_wait()函数结束（保存阻塞）。 </li>
</ul>
<p><strong>例子：使用条件变量 </strong></p>
<p>Example Code - Using Condition Variables  </p>
<p>例子演示了使用Pthreads条件变量的几个函数。主程序创建了三个线程，两个线程工作，根系“count”变量。第三个线程等待count变量值达到指定的值。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;pthread.h&gt; </div><div class="line">#include &lt;stdio.h&gt; </div><div class="line"> </div><div class="line">#define NUM_THREADS  3 </div><div class="line">#define TCOUNT 10 </div><div class="line">#define COUNT_LIMIT 12 </div><div class="line"> </div><div class="line">int     count = 0; </div><div class="line">int     thread_ids[3] = &#123;0,1,2&#125;; </div><div class="line">pthread_mutex_t count_mutex; </div><div class="line">pthread_cond_t count_threshold_cv; </div><div class="line"> </div><div class="line">void *inc_count(void *idp)  </div><div class="line">&#123; </div><div class="line">  int j,i; </div><div class="line">  double result=0.0; </div><div class="line">  int *my_id = idp; </div><div class="line"> </div><div class="line">  for (i=0; i&lt;TCOUNT; i++) &#123; </div><div class="line">    pthread_mutex_lock(&amp;count_mutex); </div><div class="line">    count++; </div><div class="line"> </div><div class="line">    /*  </div><div class="line">    Check the value of count and signal waiting thread when condition is </div><div class="line">    reached.  Note that this occurs while mutex is locked.  </div><div class="line">    */ </div><div class="line">    if (count == COUNT_LIMIT) &#123; </div><div class="line">      pthread_cond_signal(&amp;count_threshold_cv); </div><div class="line">      printf(&quot;inc_count(): thread %d, count = %d  Threshold reached./n&quot;,  </div><div class="line">             *my_id, count); </div><div class="line">      &#125; </div><div class="line">    printf(&quot;inc_count(): thread %d, count = %d, unlocking mutex/n&quot;,  </div><div class="line">           *my_id, count); </div><div class="line">    pthread_mutex_unlock(&amp;count_mutex); </div><div class="line"> </div><div class="line">    /* Do some work so threads can alternate on mutex lock */ </div><div class="line">    for (j=0; j&lt;1000; j++) </div><div class="line">      result = result + (double)random(); </div><div class="line">    &#125; </div><div class="line">  pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">void *watch_count(void *idp)  </div><div class="line">&#123; </div><div class="line">  int *my_id = idp; </div><div class="line"> </div><div class="line">  printf(&quot;Starting watch_count(): thread %d/n&quot;, *my_id); </div><div class="line"> </div><div class="line">  /* </div><div class="line">  Lock mutex and wait for signal.  Note that the pthread_cond_wait  </div><div class="line">  routine will automatically and atomically unlock mutex while it waits.  </div><div class="line">  Also, note that if COUNT_LIMIT is reached before this routine is run by </div><div class="line">  the waiting thread, the loop will be skipped to prevent pthread_cond_wait </div><div class="line">  from never returning.  </div><div class="line">  */ </div><div class="line">  pthread_mutex_lock(&amp;count_mutex); </div><div class="line">  if (count&lt;COUNT_LIMIT) &#123; </div><div class="line">    pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex); </div><div class="line">    printf(&quot;watch_count(): thread %d Condition signal  </div><div class="line">           received./n&quot;, *my_id); </div><div class="line">    &#125; </div><div class="line">  pthread_mutex_unlock(&amp;count_mutex); </div><div class="line">  pthread_exit(NULL); </div><div class="line">&#125; </div><div class="line"> </div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123; </div><div class="line">  int i, rc; </div><div class="line">  pthread_t threads[3]; </div><div class="line">  pthread_attr_t attr; </div><div class="line"> </div><div class="line">  /* Initialize mutex and condition variable objects */ </div><div class="line">  pthread_mutex_init(&amp;count_mutex, NULL); </div><div class="line">  pthread_cond_init (&amp;count_threshold_cv, NULL); </div><div class="line"> </div><div class="line">  /* For portability, explicitly create threads in a joinable state */ </div><div class="line">  pthread_attr_init(&amp;attr); </div><div class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </div><div class="line">  pthread_create(&amp;threads[0], &amp;attr, inc_count, (void *)&amp;thread_ids[0]); </div><div class="line">  pthread_create(&amp;threads[1], &amp;attr, inc_count, (void *)&amp;thread_ids[1]); </div><div class="line">  pthread_create(&amp;threads[2], &amp;attr, watch_count, (void *)&amp;thread_ids[2]); </div><div class="line"> </div><div class="line">  /* Wait for all threads to complete */ </div><div class="line">  for (i=0; i&lt;NUM_THREADS; i++) &#123; </div><div class="line">    pthread_join(threads[i], NULL); </div><div class="line">  &#125; </div><div class="line">  printf (&quot;Main(): Waited on %d  threads. Done./n&quot;, NUM_THREADS); </div><div class="line"> </div><div class="line">  /* Clean up and exit */ </div><div class="line">  pthread_attr_destroy(&amp;attr); </div><div class="line">  pthread_mutex_destroy(&amp;count_mutex); </div><div class="line">  pthread_cond_destroy(&amp;count_threshold_cv); </div><div class="line">  pthread_exit(NULL); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="8-没有覆盖的主题"><a href="#8-没有覆盖的主题" class="headerlink" title=" 8. 没有覆盖的主题"></a><a id="8"></a> 8. 没有覆盖的主题</h3><p>Pthread API的几个特性在该教程中并没有包含。把它们列在下面： </p>
<ul>
<li>线程调度<br><strong> 线程如何调度的实现往往是不同的，在大多数情况下，默认的机制是可以胜任的。 
</strong> Pthreads　API提供了显式设定线程调度策略和优先级的函数，它们可以重载默认机制。 </li>
<li>API不需要实现去支持这些特性 </li>
<li>Keys：线程数据（TSD） </li>
<li>互斥量的Protocol属性和优先级管理 </li>
<li>跨进程的条件变量共享 </li>
<li>取消线程（Thread Cancellation ） </li>
<li>多线程和信号（Threads and Signals）  </li>
</ul>
<hr>
<h3 id="9-Pthread-库API参考"><a href="#9-Pthread-库API参考" class="headerlink" title=" 9. Pthread 库API参考"></a><a id="9"></a> 9. Pthread 库API参考</h3><p><strong>Pthread Functions</strong>:</p>
<ul>
<li><p>Thread Management  </p>
<p>  pthread_create<br>  pthread_exit<br>  pthread_join<br>  pthread_once<br>  pthread_kill<br>  pthread_self<br>  pthread_equal<br>  pthread_yield<br>  pthread_detach   </p>
</li>
<li><p>Thread-Specific Data </p>
<p>  pthread_key_create<br>  pthread_key_delete<br>  pthread_getspecific<br>  pthread_setspecific </p>
</li>
<li><p>Thread Cancellation<br><strong> pthread_cancel 
</strong> pthread_cleanup_pop<br><strong> pthread_cleanup_push 
</strong> pthread_setcancelstate<br><strong> pthread_getcancelstate  
</strong> pthread_testcancel </p>
</li>
<li><p>Thread Scheduling<br><strong> pthread_getschedparam 
</strong> pthread_setschedparam </p>
</li>
<li><p>Signals<br>** pthread_sigmask </p>
</li>
</ul>
<p><strong>Pthread Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management<br><strong> pthread_attr_init 
</strong> pthread_attr_destroy </p>
</li>
<li><p>Detachable or Joinable<br><strong> pthread_attr_setdetachstate 
</strong> pthread_attr_getdetachstate </p>
</li>
<li><p>Specifying Stack Information<br><strong> pthread_attr_getstackaddr 
</strong> pthread_attr_getstacksize<br><strong> pthread_attr_setstackaddr 
</strong> pthread_attr_setstacksize </p>
</li>
<li><p>Thread Scheduling Attributes<br><strong> pthread_attr_getschedparam 
</strong> pthread_attr_setschedparam<br><strong> pthread_attr_getschedpolicy 
</strong> pthread_attr_setschedpolicy<br><strong> pthread_attr_setinheritsched 
</strong> pthread_attr_getinheritsched<br><strong> pthread_attr_setscope 
</strong> pthread_attr_getscope </p>
</li>
</ul>
<p><strong>Mutex Functions</strong>:</p>
<ul>
<li><p>Mutex Management<br><strong> pthread_mutex_init 
</strong> pthread_mutex_destroy<br><strong> pthread_mutex_lock 
</strong> pthread_mutex_unlock<br>** pthread_mutex_trylock </p>
</li>
<li><p>Priority Management<br><strong> pthread_mutex_setprioceiling 
</strong> pthread_mutex_getprioceiling </p>
</li>
</ul>
<p><strong>Mutex Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management<br><strong> pthread_mutexattr_init 
</strong> pthread_mutexattr_destroy </p>
</li>
<li><p>Sharing<br><strong> pthread_mutexattr_getpshared 
</strong> pthread_mutexattr_setpshared </p>
</li>
<li><p>Protocol Attributes<br><strong> pthread_mutexattr_getprotocol 
</strong> pthread_mutexattr_setprotocol </p>
</li>
<li><p>Priority Management<br><strong> pthread_mutexattr_setprioceiling 
</strong> pthread_mutexattr_getprioceiling </p>
</li>
</ul>
<p><strong>Condition Variable Functions</strong>:</p>
<ul>
<li>Basic Management<br><strong> pthread_cond_init 
</strong> pthread_cond_destroy<br><strong> pthread_cond_signal 
</strong> pthread_cond_broadcast<br><strong> pthread_cond_wait 
</strong> pthread_cond_timedwait </li>
</ul>
<p><strong>Condition Variable Attribute Functions</strong>:</p>
<ul>
<li><p>Basic Management </p>
<p>  pthread_condattr_init<br>  pthread_condattr_destroy </p>
</li>
<li><p>Sharing </p>
<p>  pthread_condattr_getpshared<br>  pthread_condattr_setpshared </p>
</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title=" 参考资料"></a><a id="10"></a> 参考资料</h3><ul>
<li>Author: Blaise Barney, Livermore Computing.  </li>
<li>“Pthreads Programming”. B. Nichols et al. O’Reilly and Associates.  </li>
<li>“Threads Primer”. B. Lewis and D. Berg. Prentice Hall  </li>
<li>“Programming With POSIX Threads”. D. Butenhof. Addison Wesley </li>
<li>www.awl.com/cseng/titles/0-201-63392-2  </li>
<li>“Programming With Threads”. S. Kleiman et al. Prentice Hall  </li>
</ul>
<p>(完)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="David++" />
          <p class="site-author-name" itemprop="name">David++</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">91</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/david-pp" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/davidpp" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gamelab" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/future_fighter/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2007 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David++</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tiny-lab"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>
